--- ghdl-r150-ori/disp_xml.adb	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-r150/disp_xml.adb	2013-06-10 15:12:33.000000000 +0200
@@ -0,0 +1,1827 @@
+--  Node displaying (for debugging).
+--  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GHDL; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+with Types; use Types;
+with Ada.Text_IO; use Ada.Text_IO;
+with Name_Table;
+with Iirs_Utils; use Iirs_Utils;
+with Tokens;
+with Errorout;
+with Files_Map;
+--with PSL.Dump_Tree;
+--with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
+
+package body Disp_Xml is
+
+
+
+   procedure Disp_Tab (Tab: Natural) is
+      Blanks : constant String (1 .. Tab) := (others => ' ');
+   begin
+      Put (Blanks);
+   end Disp_Tab;
+   pragma Unreferenced (Disp_Tab);
+
+   function Disp_Iir_Address (Node: Iir) return U_String
+   is
+      Res : String (1 .. 10);
+      Hex_Digits : constant array (Int32 range 0 .. 15) of Character
+        := "0123456789abcdef";
+      N : Int32 := Int32 (Node);
+   begin
+      for I in reverse 2 .. 9 loop
+         Res (I) := Hex_Digits (N mod 16);
+         N := N / 16;
+      end loop;
+      Res (1) := '[';
+      Res (10) := ']';
+      return + (Res);
+   end Disp_Iir_Address;
+
+   function Inc_Tab (Tab: Natural) return Natural is
+   begin
+      return Tab + 4;
+   end Inc_Tab;
+   pragma Unreferenced (Inc_Tab);
+
+   -- For iir.
+
+   function Disp_Xml_Flat (p : Xml_Node_Acc; N: U_String; Tree: Iir)
+                           return Xml_Node_Acc;
+
+   procedure Disp_Xml_List
+     (p : Xml_Node_Acc; N: U_String; Tree_List: Iir_List;
+      Flat_Decl : Boolean := False)
+   is
+      El: Iir;
+      Idx : Int32 := 0;
+      L : Xml_Node_Acc;
+   begin
+      if Tree_List = Null_Iir_List then
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"null-list"));
+      elsif Tree_List = Iir_List_All then
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"list-all"));
+      elsif Tree_List = Iir_List_Others then
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"list-others"));
+      else
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"list"));
+         for I in Natural loop
+            El := Get_Nth_Element (Tree_List, I);
+            exit when El = Null_Iir;
+            Disp_Xml (L, + ("idx-" & Int32'Image(Idx)), El, Flat_Decl);
+            Idx := Idx + 1;
+         end loop;
+      end if;
+      AddAttr (L, +"pos", N );
+   end Disp_Xml_List;
+
+   procedure Disp_Xml_Chain
+     (p : Xml_Node_Acc; V: U_String; Tree_Chain: Iir;
+      Flat_Decl : Boolean := False)
+   is
+      El: Iir;
+      Idx : Int32 := 0;
+      L : Xml_Node_Acc;
+   begin
+      L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"chain"));
+      El := Tree_Chain;
+      while El /= Null_Iir loop
+         Disp_Xml (L, + ("idx-" & Int32'Image(Idx)), El, Flat_Decl);
+         El := Get_Chain (El);
+         Idx := Idx + 1;
+      end loop;
+      AddAttr (L, +"pos", V );
+   end Disp_Xml_Chain;
+
+   procedure Disp_Xml_Flat_Chain (p : Xml_Node_Acc; V: U_String;
+          Tree_Chain: Iir)
+   is
+      El: Iir;
+      Idx : Int32 := 0;
+      e:Xml_Node_Acc;
+      L : Xml_Node_Acc;
+      pragma Unreferenced (e);
+   begin
+      El := Tree_Chain;
+      L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"chain"));
+      while El /= Null_Iir loop
+         e := Disp_Xml_Flat (L, + ("idx-" & Int32'Image(Idx)), El);
+         El := Get_Chain (El);
+         Idx := Idx + 1;
+      end loop;
+      AddAttr (L, +"pos", V );
+   end Disp_Xml_Flat_Chain;
+
+   procedure Disp_Xml_List_Flat (p : Xml_Node_Acc; V: U_String;
+            Tree_List: Iir_List)
+   is
+      Idx : Int32 := 0;
+      El: Iir;
+      L : Xml_Node_Acc;
+      e:Xml_Node_Acc;
+      pragma Unreferenced (e);
+   begin
+      if Tree_List = Null_Iir_List then
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"null-list"));
+      elsif Tree_List = Iir_List_All then
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"list-all"));
+      elsif Tree_List = Iir_List_Others then
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"list-others"));
+      else
+         L := Xml_Node_Acc(Create_Xml_Node_Pretty(p,+"list"));
+         for I in Natural loop
+            El := Get_Nth_Element (Tree_List, I);
+            exit when El = Null_Iir;
+            e:=Disp_Xml_Flat (L,+ ("idx-" & Int32'Image(Idx)),El);
+            Idx := Idx + 1;
+         end loop;
+      end if;
+      AddAttr (L, +"pos", V );
+   end Disp_Xml_List_Flat;
+
+   function Disp_Ident (Ident: Name_Id) return U_String is
+      use Name_Table;
+   begin
+      if Ident /= Null_Identifier then
+         Image (Ident);
+         return + (" '" & Name_Buffer (1 .. Name_Length) & ''');
+      else
+         return + (" <anonymous>");
+      end if;
+   end Disp_Ident;
+
+   function Disp_Xml_Flat (p : Xml_Node_Acc; N: U_String; Tree: Iir)
+                           return Xml_Node_Acc
+   is
+      procedure Disp_Identifier (Identifying: Iir)
+      is
+         Ident : Name_Id;
+         pragma Unreferenced (Ident);
+      begin
+         if Identifying /= Null_Iir then
+            Ident := Get_Identifier (Identifying);
+            --Put_Line(- Disp_Ident (Ident));
+         else
+            null;--New_Line;
+         end if;
+      end Disp_Identifier;
+
+      procedure Disp_Decl_Ident
+      is
+         A_Type: Iir;
+      begin
+         A_Type := Get_Type_Declarator (Tree);
+         if A_Type /= Null_Iir then
+            Disp_Identifier (A_Type);
+         else
+            --Put_Line (" <unnamed>");
+            return;
+         end if;
+      end Disp_Decl_Ident;
+      pragma Unreferenced (Disp_Decl_Ident);
+      typ : U_String := + "<skip>";
+      val, iir : U_String;
+      e : Xml_Node_Acc := null;
+   begin
+      --Put_Line(-N);
+      iir := Disp_Iir_Address (Tree);
+      val := + "";
+      if Tree = Null_Iir then
+         typ := + ("NULL");
+      else
+         case Get_Kind (Tree) is
+
+         when Iir_Kind_Design_File =>
+            typ := +"design_file";
+         when Iir_Kind_Design_Unit =>
+            typ := +"design_unit";
+         when Iir_Kind_Use_Clause =>
+            typ := +"use_clause";
+         when Iir_Kind_Library_Clause =>
+            typ := +"library_clause";
+         when Iir_Kind_Library_Declaration =>
+            typ := +"library_declaration";
+         when Iir_Kind_Proxy =>
+            typ := +"proxy";
+         when Iir_Kind_Waveform_Element =>
+            typ := +"waveform_element";
+         when Iir_Kind_Package_Declaration =>
+            typ := +"package_declaration";
+         when Iir_Kind_Package_Body =>
+            typ := +"package_body";
+         when Iir_Kind_Entity_Declaration =>
+            typ := +"entity_declaration";
+         when Iir_Kind_Architecture_Declaration =>
+            typ := +"architecture_declaration";
+         when Iir_Kind_Configuration_Declaration =>
+            typ := +"configuration_declaration";
+         when Iir_Kind_Function_Declaration =>
+            typ := +"function_declaration";
+         when Iir_Kind_Function_Body =>
+            typ := +"function_body";
+         when Iir_Kind_Procedure_Declaration =>
+            typ := +"procedure_declaration";
+         when Iir_Kind_Procedure_Body =>
+            typ := +"procedure_body";
+         when Iir_Kind_Object_Alias_Declaration =>
+            typ := +"object_alias_declaration";
+         when Iir_Kind_Non_Object_Alias_Declaration =>
+            typ := +"non_object_alias_declaration";
+         when Iir_Kind_Signal_Interface_Declaration =>
+            typ := +"signal_interface_declaration";
+         when Iir_Kind_Signal_Declaration =>
+            typ := +"signal_declaration";
+         when Iir_Kind_Variable_Interface_Declaration =>
+            typ := +"variable_interface_declaration";
+         when Iir_Kind_Variable_Declaration =>
+            typ := +"variable_declaration";
+         when Iir_Kind_Constant_Interface_Declaration =>
+            typ := +"constant_interface_declaration";
+         when Iir_Kind_Constant_Declaration =>
+            typ := +"constant_declaration";
+         when Iir_Kind_Iterator_Declaration =>
+            typ := +"iterator_declaration";
+         when Iir_Kind_File_Interface_Declaration =>
+            typ := +"file_interface_declaration";
+         when Iir_Kind_File_Declaration =>
+            typ := +"file_declaration";
+         when Iir_Kind_Type_Declaration =>
+            typ := +"type_declaration";
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            typ := +"anonymous_type_declaration";
+         when Iir_Kind_Subtype_Declaration =>
+            typ := +"subtype_declaration";
+         when Iir_Kind_Component_Declaration =>
+            typ := +"component_declaration";
+         when Iir_Kind_Element_Declaration =>
+            typ := +"element_declaration";
+         when Iir_Kind_Record_Element_Constraint =>
+            typ := +"record_element_constraint";
+         when Iir_Kind_Attribute_Declaration =>
+            typ := +"attribute_declaration";
+         when Iir_Kind_Group_Template_Declaration =>
+            typ := +"group_template_declaration";
+         when Iir_Kind_Group_Declaration =>
+            typ := +"group_declaration";
+         when Iir_Kind_Psl_Declaration =>
+            typ := +"psl_declaration";
+         when Iir_Kind_Psl_Expression =>
+            typ := +"psl_expression";
+         when Iir_Kind_Enumeration_Type_Definition =>
+            typ := +"enumeration_type_definition";
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            typ := +"enumeration_subtype_definition";
+         when Iir_Kind_Integer_Subtype_Definition =>
+            typ := +"integer_subtype_definition";
+         when Iir_Kind_Integer_Type_Definition =>
+            typ := +"integer_type_definition";
+         when Iir_Kind_Floating_Subtype_Definition =>
+            typ := +"floating_subtype_definition";
+         when Iir_Kind_Floating_Type_Definition =>
+            typ := +"floating_type_definition";
+         when Iir_Kind_Array_Subtype_Definition =>
+            typ := +"array_subtype_definition";
+         when Iir_Kind_Array_Type_Definition =>
+            typ := +"array_type_definition";
+         when Iir_Kind_Record_Type_Definition =>
+            typ := +"record_type_definition";
+         when Iir_Kind_Access_Type_Definition =>
+            typ := +"access_type_definition";
+         when Iir_Kind_File_Type_Definition =>
+            typ := +"file_type_definition";
+         when Iir_Kind_Subtype_Definition =>
+            typ := +"subtype_definition";
+         when Iir_Kind_Physical_Type_Definition =>
+            typ := +"physical_type_definition";
+         when Iir_Kind_Physical_Subtype_Definition =>
+            typ := +"physical_subtype_definition";
+         when Iir_Kind_Simple_Name =>
+            typ := +"simple_name";
+         when Iir_Kind_Operator_Symbol =>
+            typ := +"operator_symbol";
+         when Iir_Kind_Null_Literal =>
+            typ := +"null_literal";
+         when Iir_Kind_Physical_Int_Literal =>
+            typ := +"physical_int_literal";
+         when Iir_Kind_Physical_Fp_Literal =>
+            typ := +"physical_fp_literal";
+         when Iir_Kind_Component_Instantiation_Statement =>
+            typ := +"component_instantiation_statement";
+         when Iir_Kind_Block_Statement =>
+            typ := +"block_statement";
+         when Iir_Kind_Sensitized_Process_Statement =>
+            typ := +"sensitized_process_statement";
+         when Iir_Kind_Process_Statement =>
+            typ := +"process_statement";
+         when Iir_Kind_Case_Statement =>
+            typ := +"case_statement";
+         when Iir_Kind_If_Statement =>
+            typ := +"if_statement";
+         when Iir_Kind_Elsif =>
+            typ := +"elsif";
+         when Iir_Kind_For_Loop_Statement =>
+            typ := +"for_loop_statement";
+         when Iir_Kind_While_Loop_Statement =>
+            typ := +"while_loop_statement";
+         when Iir_Kind_Exit_Statement =>
+            typ := +"exit_statement";
+         when Iir_Kind_Next_Statement =>
+            typ := +"next_statement";
+         when Iir_Kind_Wait_Statement =>
+            typ := +"wait_statement";
+         when Iir_Kind_Assertion_Statement =>
+            typ := +"assertion_statement";
+         when Iir_Kind_Variable_Assignment_Statement =>
+            typ := +"variable_assignment_statement";
+         when Iir_Kind_Signal_Assignment_Statement =>
+            typ := +"signal_assignment_statement";
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            typ := +"concurrent_assertion_statement";
+         when Iir_Kind_Procedure_Call_Statement =>
+            typ := +"procedure_call_statement";
+         when Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            typ := +"concurrent_procedure_call_statement";
+         when Iir_Kind_Return_Statement =>
+            typ := +"return_statement";
+         when Iir_Kind_Null_Statement =>
+            typ := +"null_statement";
+         when Iir_Kind_Enumeration_Literal =>
+            typ := +"enumeration_literal";
+         when Iir_Kind_Character_Literal =>
+            typ := +"character_literal";
+         when Iir_Kind_Integer_Literal =>
+            typ := +"integer_literal";
+            val := + Iir_Int64'Image (Get_Value (Tree)) ;
+         when Iir_Kind_Floating_Point_Literal =>
+            typ := +"floating_point_literal";
+            val := + Iir_Fp64'Image (Get_Fp_Value (Tree)) ;
+         when Iir_Kind_String_Literal =>
+            typ := +"string_literal";
+            val := + Image_String_Lit (Tree) ;
+         when Iir_Kind_Unit_Declaration =>
+            typ := +"physical_unit";
+         when Iir_Kind_Entity_Class =>
+            typ := +"entity_class";
+            val := + Tokens.Image (Get_Entity_Class (Tree))  ;
+         when Iir_Kind_Attribute_Name =>
+            typ := +"attribute_name";
+         when Iir_Kind_Implicit_Function_Declaration =>
+            typ := +"implicit_function_declaration";
+         when Iir_Kind_Implicit_Procedure_Declaration =>
+            typ := +"implicit_procedure_declaration";
+         when others =>
+            typ := +Iir_Kind'Image (Get_Kind (Tree));
+
+         end case;
+      end if;
+
+      e := Xml_Node_Acc(Create_Xml_Node_Pretty(p,typ));
+      AddAttr (e, +"pos", N );
+      AddAttr (e, +"id", iir );
+      if Length(val) /= 0 then
+         AddAttr (e, +"val", val );
+      end if;
+      return e;
+   end Disp_Xml_Flat;
+
+   function Disp_Staticness (Static: Iir_Staticness) return U_String is
+   begin
+      case Static is
+         when Unknown =>
+            return (+"???");
+         when None =>
+            return (+"none");
+         when Globally =>
+            return (+"global");
+         when Locally =>
+            return (+"local");
+      end case;
+   end Disp_Staticness;
+
+   function Disp_Flag (Bool : Boolean) return U_String is
+   begin
+      if Bool then
+         return (+"true");
+      else
+         return (+"false");
+      end if;
+   end Disp_Flag;
+
+   function Disp_Expr_Staticness (Expr: Iir) return U_String is
+      pragma Unreferenced (Expr);
+   begin
+      return +"expr";
+      --Put (" expr: ");
+      --Disp_Staticness (Get_Expr_Staticness (Expr));
+      --New_Line;
+   end Disp_Expr_Staticness;
+
+   function Disp_Type_Staticness (Atype: Iir) return U_String is
+      pragma Unreferenced (Atype);
+   begin
+      return +"type";
+      --Put (" type: ");
+      --Disp_Staticness (Get_Type_Staticness (Atype));
+      --New_Line;
+   end Disp_Type_Staticness;
+
+   function Disp_Name_Staticness (Expr: Iir) return U_String  is
+      pragma Unreferenced (Expr);
+   begin
+      return +"name";
+      --Put (" expr: ");
+      --Disp_Staticness (Get_Expr_Staticness (Expr));
+      --Put (", name: ");
+      --Disp_Staticness (Get_Name_Staticness (Expr));
+      --New_Line;
+   end Disp_Name_Staticness;
+
+   function Disp_Choice_Staticness (Expr: Iir) return U_String  is
+      pragma Unreferenced (Expr);
+   begin
+      return +"choice";
+      --Put (" choice: ");
+      --Disp_Staticness (Get_Choice_Staticness (Expr));
+      --New_Line;
+   end Disp_Choice_Staticness;
+
+   function Disp_Type_Resolved_Flag (Atype : Iir) return U_String is
+   begin
+      if Get_Resolved_Flag (Atype) then
+         return (+"resolved");
+      else
+         return +"";
+      end if;
+   end Disp_Type_Resolved_Flag;
+
+   function Disp_Lexical_Layout (Decl : Iir) return U_String
+   is
+      pragma Unreferenced (Decl);
+      V : Iir_Lexical_Layout_Type;
+      pragma Unreferenced (V);
+   begin
+      return +"layout";
+      --  V := Get_Lexical_Layout (Decl);
+      --  if (V and Iir_Lexical_Has_Mode) /= 0 then
+      --     Put (" +mode");
+      --  end if;
+      --  if (V and Iir_Lexical_Has_Class) /= 0 then
+      --     Put (" +class");
+      --  end if;
+      --  if (V and Iir_Lexical_Has_Type) /= 0 then
+      --     Put (" +type");
+      --  end if;
+      --  New_Line;
+   end Disp_Lexical_Layout;
+
+   function Disp_Purity_State (State : Iir_Pure_State) return U_String
+   is
+   begin
+      case State is
+         when Pure =>
+            return (+" pure");
+         when Impure =>
+            return (+" impure");
+         when Maybe_Impure =>
+            return (+" maybe_impure");
+         when Unknown =>
+            return (+" unknown");
+      end case;
+   end Disp_Purity_State;
+
+   function Disp_State (State : Tri_State_Type) return U_String
+   is
+   begin
+      case State is
+         when True =>
+            return (+" true");
+         when False =>
+            return (+" false");
+         when Unknown =>
+            return (+" unknown");
+      end case;
+   end Disp_State;
+
+   function Disp_Depth (Depth : Iir_Int32) return U_String is
+   begin
+      return + (Iir_Int32'Image (Depth));
+   end Disp_Depth;
+
+   procedure flag(P : in Xml_Node_Acc; N : U_String; V: U_String) is
+   begin
+      AddAttr(P,N,V);
+   end flag;
+
+   procedure Disp_Xml (p : Xml_Node_Acc; V: U_String;
+                        Tree: Iir;
+                        Flat_Decl: Boolean := false) is
+      --Ntab: constant Natural := 0; --Inc_Tab (Tab);
+      Kind : Iir_Kind;
+
+      procedure Header (Str: String; Nl: Boolean := true) is
+      pragma Unreferenced (Str);
+      begin
+         null;
+--         Disp_Tab (Ntab);
+--         if Nl then
+--            New_Line;
+--         end if;
+      end Header;
+
+      procedure Disp_Label (p : Xml_Node_Acc; Tree: Iir) is
+         Label : Name_Id;
+         pragma Unreferenced (p);
+      begin
+         Label := Get_Label (Tree);
+         if Label /= Null_Identifier then
+            Header ("label: "  & Name_Table.Image (Label));
+         else
+            Header ("label: -");
+         end if;
+      end Disp_Label;
+
+      e : Xml_Node_Acc;
+      child : Xml_Node_Acc := null;
+      pragma Unreferenced (child);
+   begin
+      e := Disp_Xml_Flat (p,V,Tree);
+      if Tree = Null_Iir then
+         return;
+      end if;
+
+      if Get_Location (Tree) /= Location_Nil then
+         AddAttr(e,+"loc", + Errorout.Get_Location_Str (Get_Location (Tree)));
+      end if;
+
+      Kind := Get_Kind (Tree);
+      case Kind is
+         when Iir_Kind_Overload_List =>
+            Disp_Xml_List(e,+"overload_list",
+            Get_Overload_List (Tree),
+             Flat_Decl);
+         when Iir_Kind_Error =>
+            null;
+         when Iir_Kind_Design_File =>
+            flag(e,+"design_file_filename",
+            + (Name_Table.Image (Get_Design_File_Filename (Tree))));
+            flag(e,+"design_file_directory",
+            + (Name_Table.Image (Get_Design_File_Directory (Tree))));
+            flag(e,+"analysis_time_stamp",
+            + (Files_Map.Get_Time_Stamp_String
+                    (Get_Analysis_Time_Stamp (Tree))));
+            flag(e,+"file_time_stamp",
+            + (Files_Map.Get_Time_Stamp_String
+                    (Get_File_Time_Stamp (Tree))));
+            child := Disp_Xml_Flat(e,+"library",
+            Get_Parent (Tree));
+            Disp_Xml_Chain(e,+"design_unit_chain",
+            Get_First_Design_Unit (Tree),
+             Flat_Decl);
+         when Iir_Kind_Design_Unit =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"date_state",
+            + (Date_State_Type'Image (Get_Date_State (Tree))
+                    ));
+            flag(e,+"elab",
+            + (Boolean'Image (Get_Elab_Flag (Tree))));
+            flag(e,+"date",
+            + (Date_Type'Image (Get_Date (Tree))));
+            child := Disp_Xml_Flat(e,
+            +"parent_(design_file)",
+            Get_Design_File (Tree));
+            Disp_Xml_List_Flat(e,+"dependence_list",
+            Get_Dependence_List (Tree));
+            if Get_Date_State (Tree) /= Date_Disk then
+               Disp_Xml_Chain(e,+"context_items",
+            Get_Context_Items (Tree));
+            end if;
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+            Disp_Xml(e,+"library_unit",
+            Get_Library_Unit (Tree));
+         when Iir_Kind_Use_Clause =>
+            Disp_Xml(e,+"selected_name",
+            Get_Selected_Name (Tree),
+             True);
+            Disp_Xml(e,+"use_clause_chain",
+            Get_Use_Clause_Chain (Tree));
+         when Iir_Kind_Library_Clause =>
+            child := Disp_Xml_Flat(e,+"library_declaration",
+            Get_Library_Declaration (Tree));
+         when Iir_Kind_Library_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"library_directory",
+            + (Name_Table.Image (Get_Library_Directory (Tree))));
+            Disp_Xml_Chain(e,+"design_file_list",
+            Get_Design_File_Chain (Tree));
+         when Iir_Kind_Entity_Declaration =>
+            Disp_Xml_Chain(e,+"generic_chain",
+            Get_Generic_Chain (Tree));
+            Disp_Xml_Chain(e,+"port_chain",
+            Get_Port_Chain (Tree));
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml_Chain(e,+"concurrent_statements",
+            Get_Concurrent_Statement_Chain (Tree));
+         when Iir_Kind_Package_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"need_body",
+            + (Boolean'Image (Get_Need_Body (Tree))));
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+         when Iir_Kind_Package_Body =>
+            child := Disp_Xml_Flat(e,+"package",
+            Get_Package (Tree));
+            Disp_Xml_Chain(e,+"declaration",
+            Get_Declaration_Chain (Tree));
+         when Iir_Kind_Architecture_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            child := Disp_Xml_Flat(e,+"entity",
+            Get_Entity (Tree));
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml_Chain(e,+"concurrent_statements",
+            Get_Concurrent_Statement_Chain (Tree));
+            child := Disp_Xml_Flat(e,
+            +"default_configuration",
+            Get_Default_Configuration_Declaration (Tree));
+         when Iir_Kind_Configuration_Declaration =>
+            child := Disp_Xml_Flat(e,+"entity",
+            Get_Entity (Tree));
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml(e,+"block_configuration",
+            Get_Block_Configuration (Tree),
+             True);
+         when Iir_Kind_Entity_Aspect_Entity =>
+            child := Disp_Xml_Flat(e,+"entity",
+            Get_Entity (Tree));
+            child := Disp_Xml_Flat(e,+"architecture",
+            Get_Architecture (Tree));
+         when Iir_Kind_Entity_Aspect_Configuration =>
+            Disp_Xml(e,+"configuration",
+            Get_Configuration (Tree),
+             True);
+         when Iir_Kind_Entity_Aspect_Open =>
+            null;
+         when Iir_Kind_Block_Configuration =>
+            Disp_Xml(e,+"block_specification",
+            Get_Block_Specification (Tree),
+             True);
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml_Chain(e,+"configuration_item_chain",
+            Get_Configuration_Item_Chain (Tree));
+            child := Disp_Xml_Flat(e,
+            +"prev_block_configuration",
+            Get_Prev_Block_Configuration (Tree));
+         when Iir_Kind_Attribute_Specification =>
+            Disp_Xml(e,+"attribute_designator",
+            Get_Attribute_Designator (Tree),
+             True);
+            Disp_Xml_List_Flat(e,+"entity_name_list",
+            Get_Entity_Name_List (Tree));
+            flag(e,+"entity_class",
+            + (Tokens.Image (Get_Entity_Class (Tree))));
+            Disp_Xml(e,+"expression",Get_Expression (Tree));
+            Disp_Xml_Chain(e,+"attribute_value_spec_chain",
+            Get_Attribute_Value_Spec_Chain (Tree));
+         when Iir_Kind_Configuration_Specification|
+           Iir_Kind_Component_Configuration =>
+            Disp_Xml_List_Flat(e,+"instantiation_list",
+            Get_Instantiation_List (Tree));
+            Disp_Xml(e,+"component_name",
+            Get_Component_Name (Tree),
+             True);
+            Disp_Xml(e,+"binding_indication",
+            Get_Binding_Indication (Tree));
+            if Kind = Iir_Kind_Component_Configuration then
+               Disp_Xml(e,+"block_configuration",
+            Get_Block_Configuration (Tree));
+            end if;
+         when Iir_Kind_Binding_Indication =>
+            Disp_Xml(e,+"entity_aspect",
+            Get_Entity_Aspect (Tree),
+             True);
+            Disp_Xml_Chain(e,+"generic_map_aspect_chain",
+            Get_Generic_Map_Aspect_Chain (Tree));
+            Disp_Xml_Chain(e,+"port_map_aspect_chain",
+            Get_Port_Map_Aspect_Chain (Tree));
+            Disp_Xml_Chain(e,
+            +"default_generic_map_aspect_chain",
+            Get_Default_Generic_Map_Aspect_Chain (Tree));
+            Disp_Xml_Chain(e,
+            +"default_port_map_aspect_chain",
+            Get_Default_Port_Map_Aspect_Chain (Tree));
+         when Iir_Kind_Block_Header =>
+            Disp_Xml_Chain(e,+"generic_chain",
+            Get_Generic_Chain (Tree));
+            Disp_Xml_Chain(e,+"generic_map_aspect_chain",
+            Get_Generic_Map_Aspect_Chain (Tree));
+            Disp_Xml_Chain(e,+"port_chain",
+            Get_Port_Chain (Tree));
+            Disp_Xml_Chain(e,+"port_map_aspect_chain",
+            Get_Port_Map_Aspect_Chain (Tree));
+         when Iir_Kind_Attribute_Value =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,
+            +"attribute_specification",
+            Get_Attribute_Specification (Tree));
+            child := Disp_Xml_Flat(e,+"designated_entity",
+            Get_Designated_Entity (Tree));
+         when Iir_Kind_Signature =>
+            child := Disp_Xml_Flat(e,+"return_type",
+            Get_Return_Type (Tree));
+            Disp_Xml_List(e,+"type_marks_list",
+            Get_Type_Marks_List (Tree));
+         when Iir_Kind_Disconnection_Specification =>
+            Disp_Xml_List(e,+"signal_list",
+            Get_Signal_List (Tree),
+             True);
+            Disp_Xml(e,+"type_mark",Get_Type (Tree), True);
+            Disp_Xml(e,+"time_expression",
+            Get_Expression (Tree));
+         when Iir_Kind_Association_Element_By_Expression =>
+            flag(e,+"whole_association_flag",
+             Disp_Flag(Get_Whole_Association_Flag (Tree)));
+            flag(e,+"collapse_signal_flag",
+             Disp_Flag(Get_Collapse_Signal_Flag (Tree)));
+            Disp_Xml(e,+"formal",Get_Formal (Tree), True);
+            Disp_Xml(e,+"out_conversion",
+            Get_Out_Conversion (Tree),
+             True);
+            Disp_Xml(e,+"actual",Get_Actual (Tree), True);
+            Disp_Xml(e,+"in_conversion",
+            Get_In_Conversion (Tree),
+             True);
+         when Iir_Kind_Association_Element_By_Individual =>
+            flag(e,+"whole_association_flag",
+             Disp_Flag(Get_Whole_Association_Flag (Tree)));
+            Disp_Xml(e,+"formal",Get_Formal (Tree), True);
+            Disp_Xml(e,+"actual_type",
+            Get_Actual_Type (Tree),
+             True);
+            Disp_Xml_Chain(e,
+            +"individual_association_chain",
+            Get_Individual_Association_Chain (Tree));
+         when Iir_Kind_Association_Element_Open =>
+            Disp_Xml(e,+"formal",Get_Formal (Tree), True);
+         when Iir_Kind_Waveform_Element =>
+            Disp_Xml(e,+"value",Get_We_Value (Tree), True);
+            Disp_Xml(e,+"time",Get_Time (Tree));
+         when Iir_Kind_Conditional_Waveform =>
+            Disp_Xml(e,+"condition",Get_Condition (Tree));
+            Disp_Xml_Chain(e,+"waveform_chain",
+            Get_Waveform_Chain (Tree));
+         when Iir_Kind_Choice_By_Name =>
+            Disp_Xml(e,+"name",Get_Name (Tree));
+            Disp_Xml(e,+"associated",Get_Associated (Tree),
+             True);
+         when Iir_Kind_Choice_By_Others =>
+            Disp_Xml(e,+"associated",Get_Associated (Tree),
+             True);
+         when Iir_Kind_Choice_By_None =>
+            Disp_Xml(e,+"associated",Get_Associated (Tree),
+             True);
+         when Iir_Kind_Choice_By_Range =>
+            flag(e,+"staticness",
+             Disp_Choice_Staticness(Tree));
+            Disp_Xml(e,+"range",Get_Expression (Tree));
+            Disp_Xml(e,+"associated",Get_Associated (Tree),
+             True);
+         when Iir_Kind_Choice_By_Expression =>
+            Disp_Xml(e,+"expression",Get_Expression (Tree));
+            flag(e,+"staticness",
+             Disp_Choice_Staticness(Tree));
+            Disp_Xml(e,+"associated",Get_Associated (Tree),
+             True);
+         when Iir_Kind_Signal_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Name_Staticness(Tree));
+            flag(e,+"lexical_layout",
+             Disp_Lexical_Layout(Tree));
+            flag(e,+"mode",
+            + (Iir_Mode'Image (Get_Mode (Tree))));
+            flag(e,+"signal_kind",
+            + (Iir_Signal_Kind'Image (Get_Signal_Kind (Tree))));
+            flag(e,+"has_active_flag",
+             Disp_Flag(Get_Has_Active_Flag (Tree)));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml(e,+"default_value",
+            Get_Default_Value (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Variable_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Name_Staticness(Tree));
+            flag(e,+"lexical_layout",
+             Disp_Lexical_Layout(Tree));
+            flag(e,+"mode",
+            + (Iir_Mode'Image (Get_Mode (Tree))));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml(e,+"default_value",
+            Get_Default_Value (Tree),
+             True);
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Constant_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Name_Staticness(Tree));
+            flag(e,+"lexical_layout",
+             Disp_Lexical_Layout(Tree));
+            flag(e,+"mode",
+            + (Iir_Mode'Image (Get_Mode (Tree))));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml(e,+"default_value",
+            Get_Default_Value (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_File_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Name_Staticness(Tree));
+            flag(e,+"lexical_layout",
+             Disp_Lexical_Layout(Tree));
+            flag(e,+"mode",
+            + (Iir_Mode'Image (Get_Mode (Tree))));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Signal_Declaration|
+           Iir_Kind_Guard_Signal_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"kind",
+            + (Iir_Signal_Kind'Image (Get_Signal_Kind (Tree))));
+            flag(e,+"has_active_flag",
+             Disp_Flag(Get_Has_Active_Flag (Tree)));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            if Kind = Iir_Kind_Signal_Declaration then
+               Disp_Xml(e,+"default_value",
+            Get_Default_Value (Tree),
+             True);
+               child := Disp_Xml_Flat(e,+"signal_driver",
+            Get_Signal_Driver (Tree));
+            else
+               Disp_Xml(e,+"guard_expr",
+            Get_Guard_Expression (Tree));
+               Disp_Xml_List(e,+"guard_sensitivity_list",
+            Get_Guard_Sensitivity_List (Tree));
+            end if;
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Constant_Declaration|
+           Iir_Kind_Iterator_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            if Kind = Iir_Kind_Constant_Declaration then
+               flag(e,+"deferred_flag",+ (Boolean'Image
+                       (Get_Deferred_Declaration_Flag (Tree))));
+               Disp_Xml(e,+"deferred",
+            Get_Deferred_Declaration (Tree),
+             True);
+               Disp_Xml(e,+"default_value",
+            Get_Default_Value (Tree),
+             True);
+            end if;
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Variable_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"default_value",
+            Get_Default_Value (Tree),
+             True);
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_File_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"logical_name",
+            Get_File_Logical_Name (Tree));
+            flag(e,+"mode",
+            + (Iir_Mode'Image (Get_Mode (Tree))));
+            Disp_Xml(e,+"file_open_kind",
+            Get_File_Open_Kind (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Type_Declaration|
+           Iir_Kind_Subtype_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml(e,+"type_(definition)",
+            Get_Type (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml(e,+"type_(definition)",
+            Get_Type (Tree));
+         when Iir_Kind_Component_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml_Chain(e,+"generic_chain",
+            Get_Generic_Chain (Tree));
+            Disp_Xml_Chain(e,+"port_chain",
+            Get_Port_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Element_Declaration =>
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Record_Element_Constraint =>
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml(e,+"element_declaration",
+            Get_Element_Declaration (Tree));
+         when Iir_Kind_Attribute_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Psl_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+         when Iir_Kind_Psl_Expression =>
+            return;
+         when Iir_Kind_Function_Declaration|
+           Iir_Kind_Procedure_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml_Chain(e,+"interface_declaration_chain",
+            Get_Interface_Declaration_Chain (Tree));
+            if Kind = Iir_Kind_Function_Declaration then
+               Disp_Xml(e,+"return_type",
+            Get_Return_Type (Tree),
+             True);
+               flag(e,+"pure_flag",
+             Disp_Flag(Get_Pure_Flag (Tree)));
+            else
+               flag(e,+"purity_state",
+             Disp_Purity_State(Get_Purity_State (Tree)));
+            end if;
+            flag(e,+"wait_state",
+             Disp_State(Get_Wait_State (Tree)));
+            flag(e,+"all_sensitized_state",
+            + (Iir_All_Sensitized'Image
+                      (Get_All_Sensitized_State (Tree))));
+            flag(e,+"subprogram_depth",
+             Disp_Depth(Get_Subprogram_Depth (Tree)));
+            child := Disp_Xml_Flat(e,+"subprogram_body",
+            Get_Subprogram_Body (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Procedure_Body|
+           Iir_Kind_Function_Body =>
+            child := Disp_Xml_Flat(e,+"specification",
+            Get_Subprogram_Specification (Tree));
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml_Chain(e,+"statements",
+            Get_Sequential_Statement_Chain (Tree));
+         when Iir_Kind_Implicit_Function_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"operation",
+            + (Iir_Predefined_Functions'Image
+                    (Get_Implicit_Definition (Tree))));
+            Disp_Xml_Chain(e,+"interface_declaration_chain",
+            Get_Interface_Declaration_Chain (Tree));
+            Disp_Xml(e,+"return_type",
+            Get_Return_Type (Tree),
+             True);
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Implicit_Procedure_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml_Chain(e,+"interface_declaration_chain",
+            Get_Interface_Declaration_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Object_Alias_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml(e,+"name",Get_Name (Tree));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Non_Object_Alias_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Xml(e,+"name",Get_Name (Tree));
+            Disp_Xml(e,+"signature",Get_Signature (Tree),
+             True);
+         when Iir_Kind_Group_Template_Declaration =>
+            Disp_Xml_Chain(e,+"entity_class_entry",
+            Get_Entity_Class_Entry_Chain (Tree));
+         when Iir_Kind_Group_Declaration =>
+            Disp_Xml_List_Flat(e,+"group_constituent_list",
+            Get_Group_Constituent_List (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Enumeration_Type_Definition =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"type_declarator",
+            Get_Type_Declarator (Tree));
+            Disp_Xml_List(e,+"literals",
+            Get_Enumeration_Literal_List (Tree));
+         when Iir_Kind_Integer_Type_Definition|
+           Iir_Kind_Floating_Type_Definition =>
+            if Flat_Decl and then not Is_Anonymous_Type_Definition (Tree)
+            then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"type_declarator",
+            Get_Type_Declarator (Tree));
+         when Iir_Kind_Integer_Subtype_Definition|
+           Iir_Kind_Floating_Subtype_Definition|
+           Iir_Kind_Physical_Subtype_Definition|
+           Iir_Kind_Enumeration_Subtype_Definition|
+           Iir_Kind_Subtype_Definition =>
+            if Flat_Decl
+              and then Kind /= Iir_Kind_Subtype_Definition
+              and then Get_Type_Declarator (Tree) /= Null_Iir
+            then
+               return;
+            end if;
+            if Kind /= Iir_Kind_Subtype_Definition then
+               flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+               flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+               flag(e,+"signal_type_flag",
+             Disp_Flag(Get_Signal_Type_Flag (Tree)));
+               flag(e,+"has_signal_flag",
+             Disp_Flag(Get_Has_Signal_Flag (Tree)));
+               Disp_Xml(e,+"type_declarator",
+            Get_Type_Declarator (Tree),
+             True);
+               Disp_Xml(e,+"base_type",Get_Base_Type (Tree),
+             True);
+            end if;
+            Disp_Xml(e,+"type_mark",Get_Type_Mark (Tree),
+             True);
+            child := Disp_Xml_Flat(e,+"resolution_function",
+            Get_Resolution_Function (Tree));
+            Disp_Xml(e,+"range_constraint",
+            Get_Range_Constraint (Tree));
+         when Iir_Kind_Range_Expression =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            Disp_Xml(e,+"left_limit",Get_Left_Limit (Tree),
+             True);
+            Disp_Xml(e,+"right_limit",
+            Get_Right_Limit (Tree),
+             True);
+            flag(e,+"direction",
+            + (Iir_Direction'Image (Get_Direction (Tree))));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Array_Subtype_Definition =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+            flag(e,+"signal_type_flag",
+             Disp_Flag(Get_Signal_Type_Flag (Tree)));
+            flag(e,+"has_signal_flag",
+             Disp_Flag(Get_Has_Signal_Flag (Tree)));
+            child := Disp_Xml_Flat(e,+"type_declarator",
+            Get_Type_Declarator (Tree));
+            declare
+               Base : constant Iir := Get_Base_Type (Tree);
+               Fl : Boolean;
+            begin
+               if Base /= Null_Iir
+                 and then Get_Kind (Base) = Iir_Kind_Array_Type_Definition
+               then
+                  Fl := Get_Type_Declarator (Base)
+                    /= Get_Type_Declarator (Tree);
+               else
+                  Fl := False;
+               end if;
+               Disp_Xml (e,+"base", Base, Fl);
+            end;
+            Disp_Xml(e,+"type_mark",Get_Type_Mark (Tree),
+             True);
+            Disp_Xml_List(e,+"index_subtype_list",
+            Get_Index_Subtype_List (Tree),
+             True);
+            Disp_Xml(e,+"element_subtype",
+            Get_Element_Subtype (Tree),
+             True);
+            child := Disp_Xml_Flat(e,+"resolution_function",
+            Get_Resolution_Function (Tree));
+            flag(e,+"index_constraint",
+             Disp_Flag(Get_Index_Constraint_Flag (Tree)));
+            flag(e,+"constraint_state",
+            + (Iir_Constraint'Image (Get_Constraint_State (Tree))));
+         when Iir_Kind_Array_Type_Definition =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+            flag(e,+"signal_type_flag",
+             Disp_Flag(Get_Signal_Type_Flag (Tree)));
+            flag(e,+"has_signal_flag",
+             Disp_Flag(Get_Has_Signal_Flag (Tree)));
+            Disp_Xml_List(e,+"index_subtype_list",
+            Get_Index_Subtype_List (Tree),
+             True);
+            Disp_Xml(e,+"element_subtype",
+            Get_Element_Subtype (Tree),
+             True);
+         when Iir_Kind_Record_Type_Definition =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+            flag(e,+"signal_type_flag",
+             Disp_Flag(Get_Signal_Type_Flag (Tree)));
+            flag(e,+"has_signal_flag",
+             Disp_Flag(Get_Has_Signal_Flag (Tree)));
+            flag(e,+"constraint_state",
+            + (Iir_Constraint'Image (Get_Constraint_State (Tree))));
+            Disp_Xml_List(e,+"elements",
+            Get_Elements_Declaration_List (Tree),
+             True);
+         when Iir_Kind_Record_Subtype_Definition =>
+            if Flat_Decl and then not Is_Anonymous_Type_Definition (Tree) then
+               return;
+            end if;
+            child := Disp_Xml_Flat(e,+"type_declarator",
+            Get_Type_Declarator (Tree));
+            flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+            flag(e,+"signal_type_flag",
+             Disp_Flag(Get_Signal_Type_Flag (Tree)));
+            Disp_Xml(e,+"base_type",Get_Base_Type (Tree),
+             True);
+            Disp_Xml(e,+"type_mark",Get_Type_Mark (Tree),
+             True);
+            child := Disp_Xml_Flat(e,+"resolution_function",
+            Get_Resolution_Function (Tree));
+            flag(e,+"constraint_state",
+            + (Iir_Constraint'Image (Get_Constraint_State (Tree))));
+            Disp_Xml_List(e,+"elements",
+            Get_Elements_Declaration_List (Tree),
+             True);
+         when Iir_Kind_Physical_Type_Definition =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+            child := Disp_Xml_Flat(e,+"declarator",
+            Get_Type_Declarator (Tree));
+            Disp_Xml_Chain(e,+"unit_chain",
+            Get_Unit_Chain (Tree));
+         when Iir_Kind_Unit_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"physical_literal",
+            Get_Physical_Literal (Tree),
+             True);
+            Disp_Xml(e,+"physical_Unit_Value",
+            Get_Physical_Unit_Value (Tree),
+             True);
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Access_Type_Definition =>
+            if Flat_Decl then
+               return;
+            end if;
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+            flag(e,+"signal_type_flag",
+             Disp_Flag(Get_Signal_Type_Flag (Tree)));
+            child := Disp_Xml_Flat(e,+"declarator",
+            Get_Type_Declarator (Tree));
+            child := Disp_Xml_Flat(e,+"designated_type",
+            Get_Designated_Type (Tree));
+         when Iir_Kind_Access_Subtype_Definition =>
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            flag(e,+"resolved_flag",
+             Disp_Type_Resolved_Flag(Tree));
+            child := Disp_Xml_Flat(e,+"declarator",
+            Get_Type_Declarator (Tree));
+            Disp_Xml(e,+"base_type",Get_Base_Type (Tree),
+             True);
+            Disp_Xml(e,+"type_mark",Get_Type_Mark (Tree),
+             True);
+            child := Disp_Xml_Flat(e,+"designated_type",
+            Get_Designated_Type (Tree));
+            child := Disp_Xml_Flat(e,+"resolution_function",
+            Get_Resolution_Function (Tree));
+         when Iir_Kind_Incomplete_Type_Definition =>
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"declarator",
+            Get_Type_Declarator (Tree));
+            Disp_Xml(e,+"base_type",Get_Base_Type (Tree),
+             True);
+         when Iir_Kind_File_Type_Definition =>
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"declarator",
+            Get_Type_Declarator (Tree));
+            child := Disp_Xml_Flat(e,+"type_mark",
+            Get_Type_Mark (Tree));
+         when Iir_Kind_Protected_Type_Declaration =>
+            flag(e,+"staticness",
+             Disp_Type_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"declarator",
+            Get_Type_Declarator (Tree));
+            child := Disp_Xml_Flat(e,+"protected_type_body",
+            Get_Protected_Type_Body (Tree));
+            Disp_Xml_Chain(e,+"declarative_part",
+            Get_Declaration_Chain (Tree));
+         when Iir_Kind_Protected_Type_Body =>
+            child := Disp_Xml_Flat(e,
+            +"protected_type_declaration",
+            Get_Protected_Type_Declaration (Tree));
+            Disp_Xml_Chain(e,+"declarative_part",
+            Get_Declaration_Chain (Tree));
+         when Iir_Kind_Block_Statement =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Label(e,Tree);
+            Disp_Xml(e,+"guard_decl",Get_Guard_Decl (Tree));
+            Disp_Xml(e,+"block_header",
+            Get_Block_Header (Tree));
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml_Chain(e,+"concurrent_statements",
+            Get_Concurrent_Statement_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Generate_Statement =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Label(e,Tree);
+            Disp_Xml(e,+"generation_scheme",
+            Get_Generation_Scheme (Tree));
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml_Chain(e,+"concurrent_statements",
+            Get_Concurrent_Statement_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Label(e,Tree);
+            Disp_Xml(e,+"instantiated_unit",
+            Get_Instantiated_Unit (Tree),
+             True);
+            Disp_Xml_Chain(e,+"generic_map_aspect_chain",
+            Get_Generic_Map_Aspect_Chain (Tree));
+            Disp_Xml_Chain(e,+"port_map_aspect_chain",
+            Get_Port_Map_Aspect_Chain (Tree));
+            Disp_Xml(e,+"component_configuration",
+            Get_Component_Configuration (Tree));
+            Disp_Xml(e,+"default_binding_indication",
+            Get_Default_Binding_Indication (Tree),
+             True);
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            flag(e,+"guarded_target_flag",
+            + (Tri_State_Type'Image (Get_Guarded_Target_State (Tree))));
+            Disp_Xml(e,+"target",Get_Target (Tree), True);
+            if Get_Guard (Tree) = Tree then
+               flag(e,+"guard",
+            + ("guarded" & "guard: guarded"));
+            else
+               child := Disp_Xml_Flat(e,+"guard",
+            Get_Guard (Tree));
+            end if;
+            Disp_Xml_Chain(e,+"conditional_waveform_chain",
+            Get_Conditional_Waveform_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Concurrent_Selected_Signal_Assignment =>
+            flag(e,+"guarded_target_flag",
+            + (Tri_State_Type'Image (Get_Guarded_Target_State (Tree))));
+            Disp_Xml(e,+"target",Get_Target (Tree), True);
+            if Get_Guard (Tree) = Tree then
+               flag(e,+"guard",
+            + ("guarded" & "guard: guarded"));
+            else
+               child := Disp_Xml_Flat(e,+"guard",
+            Get_Guard (Tree));
+            end if;
+            Disp_Xml_Chain(e,+"choices",
+            Get_Selected_Waveform_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            Disp_Xml(e,+"condition",
+            Get_Assertion_Condition (Tree));
+            Disp_Xml(e,+"report_expression",
+            Get_Report_Expression (Tree));
+            Disp_Xml(e,+"severity_expression",
+            Get_Severity_Expression (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Psl_Assert_Statement =>
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Psl_Default_Clock =>
+            null;
+         when Iir_Kind_Sensitized_Process_Statement|
+           Iir_Kind_Process_Statement =>
+            Disp_Label(e,Tree);
+            flag(e,+"passive",
+            + (Boolean'Image (Get_Passive_Flag (Tree))));
+            if Kind = Iir_Kind_Sensitized_Process_Statement then
+               Disp_Xml_List(e,+"sensivity_list",
+            Get_Sensitivity_List (Tree),
+             True);
+            end if;
+            Disp_Xml_Chain(e,+"declaration_chain",
+            Get_Declaration_Chain (Tree));
+            Disp_Xml_Chain(e,+"process_statements",
+            Get_Sequential_Statement_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_If_Statement =>
+            Disp_Xml(e,+"condition",Get_Condition (Tree),
+             True);
+            Disp_Xml_Chain(e,+"then_sequence",
+            Get_Sequential_Statement_Chain (Tree));
+            Disp_Xml(e,+"elsif",Get_Else_Clause (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Elsif =>
+            Disp_Xml(e,+"condition",Get_Condition (Tree));
+            Disp_Xml_Chain(e,+"then_sequence",
+            Get_Sequential_Statement_Chain (Tree));
+            Disp_Xml(e,+"elsif",Get_Else_Clause (Tree));
+         when Iir_Kind_For_Loop_Statement =>
+            Disp_Xml(e,+"iterator",
+            Get_Iterator_Scheme (Tree));
+            Disp_Xml_Chain(e,+"statements",
+            Get_Sequential_Statement_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_While_Loop_Statement =>
+            Disp_Xml(e,+"condition",Get_Condition (Tree));
+            Disp_Xml_Chain(e,+"statements",
+            Get_Sequential_Statement_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Case_Statement =>
+            Disp_Xml(e,+"expression",Get_Expression (Tree),
+             True);
+            Disp_Xml_Chain(e,+"choices_chain",
+            Get_Case_Statement_Alternative_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Signal_Assignment_Statement =>
+            flag(e,+"guarded_target_flag",
+            + (Tri_State_Type'Image (Get_Guarded_Target_State (Tree))));
+            Disp_Xml(e,+"target",Get_Target (Tree), True);
+            Disp_Xml_Chain(e,+"waveform_chain",
+            Get_Waveform_Chain (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Variable_Assignment_Statement =>
+            Disp_Xml(e,+"target",Get_Target (Tree), True);
+            Disp_Xml(e,+"expression",Get_Expression (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Assertion_Statement =>
+            Disp_Xml(e,+"condition",
+            Get_Assertion_Condition (Tree));
+            Disp_Xml(e,+"report_expression",
+            Get_Report_Expression (Tree));
+            Disp_Xml(e,+"severity_expression",
+            Get_Severity_Expression (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Report_Statement =>
+            Disp_Xml(e,+"report_expression",
+            Get_Report_Expression (Tree));
+            Disp_Xml(e,+"severity_expression",
+            Get_Severity_Expression (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Return_Statement =>
+            Disp_Xml(e,+"expression",Get_Expression (Tree),
+             True);
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Wait_Statement =>
+            Disp_Xml_List(e,+"sensitivity_list",
+            Get_Sensitivity_List (Tree),
+             True);
+            Disp_Xml(e,+"condition",
+            Get_Condition_Clause (Tree));
+            Disp_Xml(e,+"timeout",
+            Get_Timeout_Clause (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Procedure_Call_Statement|
+           Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            Disp_Label(e,Tree);
+            Disp_Xml(e,+"procedure_call",
+            Get_Procedure_Call (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Procedure_Call =>
+            Disp_Xml(e,+"implementation",
+            Get_Implementation (Tree),
+             True);
+            Disp_Xml(e,+"method_object",
+            Get_Method_Object (Tree));
+            Disp_Xml_Chain(e,+"parameters",
+            Get_Parameter_Association_Chain (Tree));
+         when Iir_Kind_Exit_Statement|
+           Iir_Kind_Next_Statement =>
+            child := Disp_Xml_Flat(e,+"loop",
+            Get_Loop (Tree));
+            Disp_Xml(e,+"condition",Get_Condition (Tree));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kind_Null_Statement =>
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+         when Iir_Kinds_Dyadic_Operator =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            Disp_Xml(e,+"implementation",
+            Get_Implementation (Tree),
+             True);
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"left",Get_Left (Tree), True);
+            Disp_Xml(e,+"right",Get_Right (Tree), True);
+         when Iir_Kinds_Monadic_Operator =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            Disp_Xml(e,+"implementation",
+            Get_Implementation (Tree),
+             True);
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"operand",Get_Operand (Tree), True);
+         when Iir_Kind_Function_Call =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            child := Disp_Xml_Flat(e,+"implementation",
+            Get_Implementation (Tree));
+            Disp_Xml(e,+"method_object",
+            Get_Method_Object (Tree));
+            Disp_Xml_Chain(e,+"parameters",
+            Get_Parameter_Association_Chain (Tree));
+         when Iir_Kind_Qualified_Expression =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"type_mark",Get_Type_Mark (Tree),
+             True);
+            Disp_Xml(e,+"expression",Get_Expression (Tree),
+             True);
+         when Iir_Kind_Type_Conversion =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"expression",Get_Expression (Tree),
+             True);
+         when Iir_Kind_Allocator_By_Expression =>
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"expression",Get_Expression (Tree),
+             True);
+         when Iir_Kind_Allocator_By_Subtype =>
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"subtype_indication",
+            Get_Expression (Tree),
+             True);
+         when Iir_Kind_Selected_Element =>
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree), True);
+            Disp_Xml(e,+"selected_element",
+            Get_Selected_Element (Tree),
+             True);
+         when Iir_Kind_Implicit_Dereference|
+           Iir_Kind_Dereference =>
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree), True);
+         when Iir_Kind_Aggregate =>
+            flag(e,+"value",
+             Disp_Staticness(Get_Value_Staticness (Tree)));
+            flag(e,+"staticness-expr",
+             Disp_Expr_Staticness(Tree));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml(e,+"aggregate_info",
+            Get_Aggregate_Info (Tree));
+            Disp_Xml_Chain(e,+"associations",
+            Get_Association_Choices_Chain (Tree));
+         when Iir_Kind_Aggregate_Info =>
+            flag(e,+"aggr_others_flag",
+             Disp_Flag(Get_Aggr_Others_Flag (Tree)));
+            flag(e,+"aggr_named_flag",
+             Disp_Flag(Get_Aggr_Named_Flag (Tree)));
+            flag(e,+"aggr_dynamic_flag",
+             Disp_Flag(Get_Aggr_Dynamic_Flag (Tree)));
+            Disp_Xml(e,+"aggr_low_limit",
+            Get_Aggr_Low_Limit (Tree),
+             False);
+            Disp_Xml(e,+"aggr_high_limit",
+            Get_Aggr_High_Limit (Tree),
+             False);
+            flag(e,+"aggr_max_length",
+            + (Iir_Int32'Image (Get_Aggr_Max_Length (Tree))));
+            Disp_Xml(e,+"sub_aggregate_info",
+            Get_Sub_Aggregate_Info (Tree));
+         when Iir_Kind_Operator_Symbol =>
+            null;
+         when Iir_Kind_Simple_Name =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Indexed_Name =>
+            flag(e,+"staticness",
+             Disp_Name_Staticness(Tree));
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree), True);
+            Disp_Xml_List(e,+"index",Get_Index_List (Tree),
+             True);
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Slice_Name =>
+            flag(e,+"staticness",
+             Disp_Name_Staticness(Tree));
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree), True);
+            Disp_Xml(e,+"suffix",Get_Suffix (Tree));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Parenthesis_Name =>
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree),
+             Flat_Decl);
+            Disp_Xml_Chain(e,+"association_chain",
+            Get_Association_Chain (Tree));
+         when Iir_Kind_Selected_By_All_Name =>
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree), True);
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+         when Iir_Kind_Selected_Name =>
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree), True);
+            flag(e,+"identifier",
+             Disp_Ident(Get_Suffix_Identifier (Tree)));
+         when Iir_Kind_Attribute_Name =>
+            Disp_Xml(e,+"prefix",Get_Prefix (Tree), True);
+            Disp_Xml(e,+"signature",Get_Signature (Tree));
+         when Iir_Kind_Base_Attribute =>
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Left_Type_Attribute|
+           Iir_Kind_Right_Type_Attribute|
+           Iir_Kind_High_Type_Attribute|
+           Iir_Kind_Low_Type_Attribute|
+           Iir_Kind_Ascending_Type_Attribute =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Image_Attribute|
+           Iir_Kind_Value_Attribute =>
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"parameter",Get_Parameter (Tree));
+         when Iir_Kind_Pos_Attribute|
+           Iir_Kind_Val_Attribute|
+           Iir_Kind_Succ_Attribute|
+           Iir_Kind_Pred_Attribute|
+           Iir_Kind_Leftof_Attribute|
+           Iir_Kind_Rightof_Attribute =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"parameter",Get_Parameter (Tree));
+         when Iir_Kind_Left_Array_Attribute|
+           Iir_Kind_Right_Array_Attribute|
+           Iir_Kind_High_Array_Attribute|
+           Iir_Kind_Low_Array_Attribute|
+           Iir_Kind_Range_Array_Attribute|
+           Iir_Kind_Reverse_Range_Array_Attribute|
+           Iir_Kind_Length_Array_Attribute|
+           Iir_Kind_Ascending_Array_Attribute =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"parameter",Get_Parameter (Tree));
+         when Iir_Kind_Delayed_Attribute|
+           Iir_Kind_Stable_Attribute|
+           Iir_Kind_Quiet_Attribute|
+           Iir_Kind_Transaction_Attribute =>
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            if Kind /= Iir_Kind_Transaction_Attribute then
+               Disp_Xml(e,+"parameter",
+            Get_Parameter (Tree));
+            end if;
+            flag(e,+"has_active_flag",
+             Disp_Flag(Get_Has_Active_Flag (Tree)));
+         when Iir_Kind_Event_Attribute|
+           Iir_Kind_Active_Attribute|
+           Iir_Kind_Last_Event_Attribute|
+           Iir_Kind_Last_Active_Attribute|
+           Iir_Kind_Last_Value_Attribute|
+           Iir_Kind_Driving_Attribute|
+           Iir_Kind_Driving_Value_Attribute =>
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Behavior_Attribute|
+           Iir_Kind_Structure_Attribute =>
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Simple_Name_Attribute|
+           Iir_Kind_Instance_Name_Attribute|
+           Iir_Kind_Path_Name_Attribute =>
+            child := Disp_Xml_Flat(e,+"prefix",
+            Get_Prefix (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Enumeration_Literal =>
+            if Flat_Decl and then Get_Literal_Origin (Tree) = Null_Iir then
+               return;
+            end if;
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            flag(e,+"value",
+            + (Iir_Int32'Image (Get_Enum_Pos (Tree))));
+            Disp_Xml_Flat_Chain(e,+"attribute_value_chain",
+            Get_Attribute_Value_Chain (Tree));
+            Disp_Xml(e,+"origin",Get_Literal_Origin (Tree),
+             True);
+         when Iir_Kind_Integer_Literal =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"origin",Get_Literal_Origin (Tree),
+             True);
+         when Iir_Kind_Floating_Point_Literal =>
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"origin",Get_Literal_Origin (Tree),
+             True);
+         when Iir_Kind_String_Literal =>
+            flag(e,+"value",
+            + (Iirs_Utils.Image_String_Lit (Tree) ));
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml(e,+"origin",Get_Literal_Origin (Tree),
+             True);
+         when Iir_Kind_Bit_String_Literal =>
+            flag(e,+"base",
+            + (Base_Type'Image (Get_Bit_String_Base (Tree))));
+            flag(e,+"value",
+            + (Iirs_Utils.Image_String_Lit (Tree) ));
+            flag(e,+"len",
+            + (Int32'Image (Get_String_Length (Tree))));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Character_Literal =>
+            flag(e,+"value",
+            + (Name_Table.Get_Character (Get_Identifier (Tree)) ));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Physical_Int_Literal =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            flag(e,+"value",
+            + (Iir_Int64'Image (Get_Value (Tree))));
+            child := Disp_Xml_Flat(e,+"unit_name",
+            Get_Unit_Name (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"origin",Get_Literal_Origin (Tree));
+         when Iir_Kind_Physical_Fp_Literal =>
+            flag(e,+"staticness",
+             Disp_Expr_Staticness(Tree));
+            flag(e,+"fp_value",
+            + (Iir_Fp64'Image (Get_Fp_Value (Tree))));
+            child := Disp_Xml_Flat(e,+"unit_name",
+            Get_Unit_Name (Tree));
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+            Disp_Xml(e,+"origin",Get_Literal_Origin (Tree));
+         when Iir_Kind_Null_Literal =>
+            child := Disp_Xml_Flat(e,+"type",
+            Get_Type (Tree));
+         when Iir_Kind_Simple_Aggregate =>
+            Disp_Xml_List(e,+"simple_aggregate_list",
+            Get_Simple_Aggregate_List (Tree),
+             True);
+            Disp_Xml(e,+"type",Get_Type (Tree), True);
+            Disp_Xml(e,+"origin",Get_Literal_Origin (Tree),
+             True);
+         when Iir_Kind_Proxy =>
+            child := Disp_Xml_Flat(e,+"proxy",
+            Get_Proxy (Tree));
+         when Iir_Kind_Entity_Class =>
+            null;
+      end case;
+   end Disp_Xml;
+
+   --  procedure Disp_Xml_For_Psl (N : Int32) is
+   --  begin
+   --     Disp_Xml_Flat (Iir (N), 1);
+   --  end Disp_Xml_For_Psl;
+end Disp_Xml;
--- ghdl-r150-ori/disp_xml.ads	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-r150/disp_xml.ads	2013-06-06 15:52:59.000000000 +0200
@@ -0,0 +1,29 @@
+--  Node displaying (for debugging).
+--  Copyright (C) 2002, 2003, 2004, 2005, 2009 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GHDL; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+--with Types; use Types;
+with Iirs; use Iirs;
+--  with Disp_Tree; use Disp_Tree;
+with disp_xml_node; use disp_xml_node;
+
+package Disp_Xml is
+   --  Disp TREE recursively.
+   procedure Disp_Xml (p : Xml_Node_Acc; V: U_String;
+    Tree: Iir;
+    Flat_Decl: Boolean := false);
+
+end Disp_Xml;
--- ghdl-r150-ori/disp_vhdl.adb	2013-04-18 21:16:37.000000000 +0200
+++ ghdl-r150/disp_vhdl.adb	2013-06-12 15:19:49.000000000 +0200
@@ -186,7 +186,12 @@
          end if;
          Disp_Expression (Get_Right_Limit (Decl));
       else
-         Disp_Subtype_Indication (Decl);
+         if (Get_Kind(Decl) = Iir_Kind_Range_Array_Attribute) then
+            Disp_Expression(Get_Prefix(Decl));
+            Put ("'range "); -- f:typ
+         else
+            Disp_Subtype_Indication (Decl);
+         end if;
          --  Disp_Name_Of (Get_Type_Declarator (Decl));
       end if;
    end Disp_Range;
--- ghdl-r150-ori/nodes.adb	2013-04-18 21:16:37.000000000 +0200
+++ ghdl-r150/nodes.adb	2013-06-10 18:33:40.000000000 +0200
@@ -16,6 +16,7 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with GNAT.Table;
+--with Ada.Text_IO; use Ada.Text_IO;
 
 package body Nodes is
    --  Suppress the access check of the table base.  This is really safe to
@@ -127,6 +128,7 @@
 
    function Get_Location (N: Node_Type) return Location_Type is
    begin
+      --Put_Line(Integer'Image(Integer(N)));
       return Nodet.Table (N).Location;
    end Get_Location;
 
--- ghdl-r150-ori/ortho/debug/ortho_debug.adb	2013-04-18 21:16:35.000000000 +0200
+++ ghdl-r150/ortho/debug/ortho_debug.adb	2013-04-18 20:03:05.000000000 +0200
@@ -1311,8 +1311,9 @@
    is
       subtype O_Dnode_Const_Value is O_Dnode_Type (ON_Const_Value);
       N : O_Dnode;
+      V : constant O_Dnode := Const;
    begin
-      Const := Const;
+      Const := V;
 
       if Const.Const_Value /= O_Dnode_Null then
          --  Constant already has a value.
@@ -1341,8 +1342,9 @@
 
    procedure Finish_Const_Value (Const : in out O_Dnode; Val : O_Cnode)
    is
+      V : constant O_Dnode := Const;
    begin
-      Const := Const;
+      Const := V;
 
       if Const.Const_Value = O_Dnode_Null then
          --  Start_Const_Value not called.
--- ghdl-r150-ori/ortho/gcc/Makefile	2013-04-18 21:16:35.000000000 +0200
+++ ghdl-r150/ortho/gcc/Makefile	2013-04-18 19:31:05.000000000 +0200
@@ -16,7 +16,7 @@
 ORTHO_PACKAGE=Ortho_Gcc
 
 #LIBFLAGS=$(HOME)/dist/mpfr-2.3.1/.libs/libmpfr.a $(HOME)/dist/gmp-4.2.2/.libs/libgmp.a
-LIBFLAGS=-L$(HOME)/dist/build/lib -lmpc -lmpfr -lgmp -lz -ldl #$(AGCC_GCCOBJ_DIR)/intl/libintl.a -liconv -lz
+LIBFLAGS=-L$(HOME)/dist/build/lib -lmpc -lmpfr -lgmp -lz -ldl -liconv -lz #$(AGCC_GCCOBJ_DIR)/intl/libintl.a -liconv -lz
 
 $(ortho_exec): $(AGCC_DEPS) $(ORTHO_BASENAME).ads force
 	$(GNATMAKE) -m -o $@ -g -aI$(ortho_srcdir) \
--- ghdl-r150-ori/ortho/gcc/ortho-lang.c	2013-04-18 21:16:35.000000000 +0200
+++ ghdl-r150/ortho/gcc/ortho-lang.c	2013-04-18 19:58:12.000000000 +0200
@@ -629,6 +629,8 @@
 
   if (precision <= MAX_BITS_PER_WORD)
     signed_and_unsigned_types[precision][unsignedp] = t;
+  else
+    t = NULL_TREE;
 
   return t;
 }
--- ghdl-r150-ori/translate/gcc/dist-common.sh	2013-04-18 21:16:33.000000000 +0200
+++ ghdl-r150/translate/gcc/dist-common.sh	2013-04-18 22:19:53.000000000 +0200
@@ -56,6 +56,8 @@
 std_names.ads
 disp_tree.adb
 disp_tree.ads
+disp_xml.adb
+disp_xml.ads
 iirs_utils.adb
 iirs_utils.ads
 std_package.adb
--- ghdl-r150-ori/translate/ghdldrv/ghdllocal.adb	2013-04-18 21:16:33.000000000 +0200
+++ ghdl-r150/translate/ghdldrv/ghdllocal.adb	2013-06-12 15:22:37.000000000 +0200
@@ -71,6 +71,7 @@
          raise Compilation_Error;
       end if;
 
+      --Disp_Vhdl.Disp_Vhdl (Unit);
       if (Main or Flags.List_All) and then Flags.List_Sem then
          Disp_Vhdl.Disp_Vhdl (Unit);
       end if;
--- ghdl-r150-ori/translate/ghdldrv/ghdlprint.adb	2013-04-18 21:16:33.000000000 +0200
+++ ghdl-r150/translate/ghdldrv/ghdlprint.adb	2013-06-12 15:43:03.000000000 +0200
@@ -30,8 +30,11 @@
 with Scan;
 with Version;
 with Xrefs;
+with Disp_Xml; use Disp_Xml;
 with Ghdlmain; use Ghdlmain;
 with Ghdllocal; use Ghdllocal;
+with disp_xml_node; use disp_xml_node;
+with disp_xml_vhdl; use disp_xml_vhdl;
 
 package body Ghdlprint is
    type Html_Format_Type is (Html_2, Html_Css);
@@ -1563,6 +1566,126 @@
          Error ("xrefs has failed due to compilation error");
    end Perform_Action;
 
+   --  Command --xml
+   type Command_Xml is new Command_Lib with record
+      Output_Dir : String_Access := null;
+   end record;
+
+   function Decode_Command (Cmd : Command_Xml; Name : String)
+                           return Boolean;
+   function Get_Short_Help (Cmd : Command_Xml) return String;
+   procedure Decode_Option (Cmd : in out Command_Xml;
+                            Option : String;
+                            Arg : String;
+                            Res : out Option_Res);
+
+   procedure Perform_Action (Cmd : in out Command_Xml;
+                             Files_Name : Argument_List);
+
+   function Decode_Command (Cmd : Command_Xml; Name : String)
+                           return Boolean
+   is
+      pragma Unreferenced (Cmd);
+   begin
+      return Name = "--xml";
+   end Decode_Command;
+
+   procedure Decode_Option (Cmd : in out Command_Xml;
+                            Option : String;
+                            Arg : String;
+                            Res : out Option_Res)
+   is
+   begin
+      if Option = "-o" then
+         if Arg = "" then
+            Res := Option_Arg_Req;
+         else
+            Cmd.Output_Dir := new String'(Arg);
+            Res := Option_Arg;
+         end if;
+      else
+         Decode_Option (Command_Lib (Cmd), Option, Arg, Res);
+      end if;
+   end Decode_Option;
+
+   function Get_Short_Help (Cmd : Command_Xml) return String
+   is
+      pragma Unreferenced (Cmd);
+   begin
+      return "--xml FILEs  Generate xml";
+   end Get_Short_Help;
+
+   procedure Perform_Action
+     (Cmd : in out Command_Xml; Files_Name : Argument_List)
+   is
+      pragma Unreferenced (Cmd);
+
+      use Files_Map;
+
+      Id : Name_Id;
+      File : Source_File_Entry;
+
+      type File_Data is record
+         Fe : Source_File_Entry;
+         Design_File : Iir;
+      end record;
+      type File_Data_Array is array (Files_Name'Range) of File_Data;
+
+      Files : File_Data_Array;
+      Unit : Iir;
+      Root,N : Xml_Node_Acc;
+   begin
+      --  Load work library.
+      Setup_Libraries (True);
+
+      Xrefs.Init;
+      Flags.Flag_Xref := True;
+
+      --  Parse all files.
+      for I in Files'Range loop
+         Id := Get_Identifier (Files_Name (I).all);
+         File := Load_Source_File (Libraries.Local_Directory, Id);
+         if File = No_Source_File_Entry then
+            Error ("cannot open " & Image (Id));
+            return;
+         end if;
+         Files (I).Fe := File;
+         Files (I).Design_File := Libraries.Load_File (File);
+         if Files (I).Design_File = Null_Iir then
+            return;
+         end if;
+         --  Put units in library.
+         --  Note: design_units stay while design_file get empty.
+         Libraries.Add_Design_File_Into_Library (Files (I).Design_File);
+      end loop;
+
+      --  Analyze all files.
+      for I in Files'Range loop
+         Analyze_Design_File_Units (Files (I).Design_File);
+      end loop;
+
+      Xrefs.Fix_End_Xrefs;
+      Xrefs.Sort_By_Node_Location;
+
+      Root := Xml_Node_Acc(Create_Xml_Node_Pretty(null,+"root"));
+      for F in Files'Range loop
+
+         Unit := Get_First_Design_Unit (Files (F).Design_File);
+         while Unit /= Null_Iir loop
+            N := NewN(Root,+"xml");
+            Disp_Xml.Disp_Xml(N,+"root",Unit);
+            SetTag(N.all,+"xml_xml");
+            disp_xml_vhdl.Disp_Xml_Vhdl(Root,NewN(Root,+"vhdl"),Unit);
+            Unit := Get_Chain (Unit);
+         end loop;
+
+      end loop;
+      Print(Root.all,0);
+   exception
+      when Compilation_Error =>
+         Error ("xrefs has failed due to compilation error");
+   end Perform_Action;
+
    procedure Register_Commands is
    begin
       Register_Command (new Command_Chop);
@@ -1570,5 +1693,6 @@
       Register_Command (new Command_PP_Html);
       Register_Command (new Command_Xref_Html);
       Register_Command (new Command_Xref);
+      Register_Command (new Command_Xml);
    end Register_Commands;
 end Ghdlprint;
--- ghdl-r150-ori/disp.pl	2013-07-10 13:07:15.000000000 +0200
+++ ghdl-r150/disp.pl	2013-06-08 21:56:44.000000000 +0200
@@ -0,0 +1,544 @@
+#!/usr/bin/perl
+use File::Basename;
+use File::Path;
+use FindBin qw($Bin);
+use FindBin qw($Bin);
+use lib "$Bin/../lib";
+require "$Bin/disp_data.pl";
+use Data::Dumper;
+
+$RE_comment_Cpp =                q{(?:\/\*(?:(?!\*\/)[\s\S])*\*\/|\/\/[^\n]*\n)};
+$RE_string =                     qr{"((?:\\.|[^\\"])*)"};
+$RE_string_one =                 qr{'((?:\\.|[^\\'])*)'}; #"
+$id =                            qr{(?:[a-zA-Z_][a-zA-Z_0-9]*)};
+$RE_balanced_squarebrackets =    qr'(?:[\[]((?:(?>[^\[\]]+)|(??{$RE_balanced_squarebrackets}))*)[\]])'s;
+$RE_balanced_smothbrackets =     qr'(?:[\(]((?:(?>[^\(\)]+)|(??{$RE_balanced_smothbrackets}))*)[\)])'s;
+$RE_if = qr'(?:(?:if)((?:(?>(?:(?!\b(?:end\s+)?if\b).)+)|(??{$RE_if}))*)(?:end\s+if))'s;
+$RE_h  = qr"(?:\b(Header)\s*($RE_balanced_smothbrackets)\s*;?)";
+$RE_d  = qr"(?:\b((?:Disp[a-zA-Z0-9_]*))\s*($RE_balanced_smothbrackets)\s*;?)";
+
+sub filename {
+    my ($str) = @_;
+    $str =~ s/([<>])/sprintf("_%02X_",ord($1))/eg;
+    return $str;
+}
+
+sub readfile {
+    my ($in) = @_;
+    usage(\*STDOUT) if (length($in) == 0) ;
+    open IN, "$in" or die "Reading \"$in\":".$!;
+    local $/ = undef;
+    $m = <IN>;
+    close IN;
+    return $m;
+}
+
+sub writefile {
+    my ($out,$re,$temp) = @_;
+    $out = filename($out);
+    my $dir = dirname($out);
+    if ($dir) {
+        mkpath($dir);
+    }
+    open OUT, ">$out" or die ($out.$!);
+    print OUT ($re);
+    close OUT;
+}
+$d = 0;
+$ln = 1;
+sub peel    { my ($m) = @_; $m =~ s/^\s*\(//; $m =~ s/\)\s*$//; return $m; }
+sub pre     { my ($m,$pre,$c) = @_; my $l = $pre.$c; $ln += ($l =~ tr/\n//); return (substr($m,length($pre.$c)),$pre,$c); }
+sub dbg     { my $m = substr($_[0],0,64); $m =~ s/\n/\\n/g; return "(ln:$ln) ".'"'.$m.'"'; }
+sub rmspace { my $m = $_[0]; $m =~ s/^[;\s]+//; return $m; }
+sub delspace { my $m = $_[0]; $m =~ s/^[\s]+//; $m =~ s/[\s]+$//; return $m; }
+
+$typcase = "\n";
+
+sub case {
+    my ($n,$str) = @_; my $pre,$c, $str0, $n0 = "", $v0 = "", $shared = 0;
+    my @str = @{$str};
+    
+    print("                $n: ***** Process ".length(@str)."\n") if ($d);
+    
+    $typcase .= ("         when $n =>\n");
+    if (scalar(@str) == 1 && ($str[0]{'typ'} eq 'Put_Line' || $str[0]{'typ'} eq 'Put')) {
+    put:
+      my $b = peel($str[0]{'b'});
+      my @b = split("&",$b);
+      if ($b =~ /^$RE_string/) {
+        ($b,$pre,$c,$str0) = (pre($typ, $`, $&),$1);
+        if (($n0 = $str0) =~ /^(.*):/) {
+          $n0 = $1;
+          ($str0) = pre($str0, $`, $&);
+          $str0 = rmspace($str0);
+          die ("String left: error: $str0") if (length($str0)) ;
+          $v0 = $b[1];
+        } elsif (($n0 = $str0) =~ /^(.*)'/) {
+          $n0 = $1;
+          $v0 = $b[1];
+        }
+        $n0 = delspace($n0);
+	$n0 =~ s/\s/_/g; $n0 =~ s/[,:]//g;
+        $typcase .= ("            typ := +\"$n0\";\n");
+        $typcase .= ("            val := +$v0 ;\n") if (length($v0));
+      } else {
+        die ("Cannot find string") if (scalar(@b) != 1);
+        $v0 = $b[0];
+        $typcase .= ("            typ := +$v0;\n");
+        #$typcase .= ("            val := +$v0 ;\n") if (length($v0));
+      }
+    } elsif (scalar(@str) == 2 && $str[0]{'typ'} eq 'Put') {
+      my $b = peel($str[0]{'b'});
+      if ($b =~ /^$RE_string/) {
+        $n0 = $1;
+      }
+      $n0 = delspace($n0);
+      $n0 =~ s/\s/_/g; $n0 =~ s/[,:]//g;
+      $typcase .= ("            typ := +\"$n0\";\n");
+      $typcase .= ("            val :=  +$v0 ;\n") if (length($v0));
+    } elsif (scalar(@str) == 3 && $str[0]{'typ'} eq 'if') {
+      $shared = shift(@str);
+      $shared = 1;
+      goto put;
+    } elsif (scalar(@str) == 4 && $str[0]{'typ'} eq 'Put' && $str[1]{'typ'} eq 'Name_Table.Image') {
+      goto put;
+    } else {
+      die("Unknown combination\nlen:".scalar(@str)." typ:".$str[0]{'typ'}."\n"); 
+    }
+}
+
+$state = 0;
+
+#todo: enable again: 
+#$typ = "";
+$n = "";
+
+sub parse_typ {
+  my ($typ) = @_; my @disp, @str;
+  my ($state) = (0);
+  while(length($typ = rmspace($typ))) {
+    if ($state == 0) {
+      if ($typ =~ /case[^\n]+is/) {
+        ($typ,$pre,$c) = pre($typ, $`, $&);
+        $state = 1;
+      } else {
+        die ("Expecting case in ".dbg($typ)."\n");
+      }
+    } elsif ($state == 1) {
+      if ($typ =~ /^when\s+($id)\s*=>/) {
+        $pren = $n;
+        ($typ,$pre,$c,$n) = (pre($typ, $`, $&),$1);
+        case($pren, \@str) if (length($pren));
+        undef(@disp); undef(@str);
+        print("Found type case $n\n") if ($d);
+      } elsif ($typ =~ /^end\s+case/) {
+        case($n, \@str);
+        undef(@disp); undef(@str);
+        print("Finished type parse\n") if ($d);
+        last;
+      } elsif ($typ =~ /^((?:Put|Put_Line))\s*($RE_balanced_smothbrackets)\s*;?/) {
+        ($typ,$pre,$c,$p,$str) = (pre($typ, $`, $&),$1,$2);
+        push(@str, {'typ'=>$p, 'l'=>$c, 'b'=>$str});
+        print("                $n:$str (".scalar(@str).")\n") if ($d);
+      } elsif (($typ=rmspace($typ)) =~ /^((?:Disp_Identifier|Disp_Ident))\s*($RE_balanced_smothbrackets)\s*;?/) {
+        ($typ,$pre,$c,$p,$_disp) = (pre($typ, $`, $&),$1,$2);
+        push(@str, {'typ'=>$p, 'l'=>$c, 'd'=>$_disp});
+        print("                $n:$_disp (".scalar(@str).")\n") if ($d);
+      } elsif (($typ=rmspace($typ)) =~ /^Disp_Decl_Ident\s*;?/) {
+        ($typ,$pre,$c) = (pre($typ, $`, $&));
+        push(@str, {'typ'=>'Disp_Decl_Ident', 'l'=>$c});
+        print("                $n:Disp_Decl_Ident (".scalar(@str).")\n") if ($d);
+      } elsif (($typ=rmspace($typ)) =~ /^Name_Table.Image\s*$RE_balanced_smothbrackets/ms) {
+        ($typ,$pre,$c) = (pre($typ, $`, $&));
+        push(@str, {'typ'=>'Name_Table.Image', 'l'=>$c});
+        print("                $n:Name_Table.Image (".scalar(@str).")\n") if ($d);
+      } elsif (($typ=rmspace($typ)) =~ /^$RE_if/s) {
+        ($typ,$pre,$c) = (pre($typ, $`, $&));
+        push(@str, {'typ'=>'if', 'l'=>$c});
+        print("                $n:found if\n") if ($d);
+      } else {
+        die ("Cannot scan typ in ".dbg($typ)."\n");
+      }
+    } elsif ($state == 2) {
+      
+    }
+  }
+}
+parse_typ($typ);
+#print($typ);
+#exit(1);
+
+sub scanheaderline {
+  my ($m) = @_;
+  $m = rmspace($m);
+  if (($m = rmspace($m)) =~ /^$RE_string/) {
+    print ($1);
+  }
+  return undef;
+}
+sub scanheader {
+  my ($_m, $n) = @_; my $d = 0, $multi = 0;
+  my @b = split("&",$_m); my @r = ();
+  for (my $i = 0; $i < scalar(@b); $i++) {
+    $m = rmspace($b[$i]);
+    if ((($m = rmspace($m)) =~ /^$RE_string/) &&
+        ($l = $1) &&
+        ($l =~ /^((?:flags: |staticness: ))?([^:]+)\s*:?\s*('?)$/)) {
+      my ($n,$pre,$post) = ($2,$1,$3);
+      $n =~ s/[,:]//g; $n = delspace($n); $n =~ s/\s/_/g;
+      push(@r,{'n'=>$n,'b'=>[],'pre'=>$pre,'post'=>$post});
+    } else {
+      if ($#r < 0 || !defined($r[$#r]{'b'})) {
+        if (($m =~ /^$RE_string/) &&
+            ($l = $1) &&
+            ($l =~ /^?([^:]+)\s*:\s*(.*)$/)) { # Header("guard: guarded");
+          push(@r,{'n'=>$1,'b'=>["\"".$2."\""]});
+        } else {
+          die("First headerstring must be ident: $m\n");
+        }
+      }
+      if (!($m eq "'''" || $m eq "\"\"\"\"") ) {
+        push(@{$r[$#r]{'b'}},$m); 
+      }
+      $multi = 1;
+    }
+  }
+  if($multi) {
+  }
+  return (\@r,$multi);
+}
+
+$out = 1;
+sub merge {
+  my ($str) = @_; my ($typ,$f);;
+  my @r = ();
+  
+  for (my $i = 0; $i < scalar(@$str); $i++) {
+    
+    my @p = (); my $multi = 0;
+    if ($$str[$i]{'typ'} eq 'Header') {
+      my $p; ($p,$multi) = scanheader(peel($$str[$i]{'l'}));
+      @p = @$p;      
+    }
+    if ($multi) {
+      die ("Cannot find promary flag\n") if (!scalar(@p));
+      foreach my $b (@p)  {
+        push(@r,{'typ'=>'flags', 'n'=>$$b{'n'}, 'v'=>"(".join(" & ",@{$$b{'b'}}).")"});
+      }
+    } elsif ($$str[$i]{'typ'} eq 'null') {
+      push(@r,$$str[$i]);
+    } elsif ($$str[$i]{'typ'} eq 'if') {
+      push(@r,$$str[$i]);
+    } elsif ($$str[$i]{'typ'} eq 'return') {
+      push(@r,$$str[$i]);
+    } elsif ($$str[$i]{'typ'} eq 'psl') {
+    } elsif ($$str[$i]{'typ'} eq 'Header' &&
+             $$str[$i+1]{'typ'} eq 'decl') {
+        push(@r,{'typ'=>'decl', 'n'=>$p[0]{'n'} });
+      $i++;
+    } elsif ($$str[$i]{'typ'} eq 'Disp_Label') {
+      push(@r,$$str[$i]);
+    } elsif (($i+1 < scalar(@$str)) &&
+             ($$str[$i]{'typ'} eq 'Header') &&
+             (($typ = $$str[$i+1]{'typ'}) =~ /^Disp/) 
+            ) {
+      
+      my $di = $$str[$i+1];
+      $f = $p[0]{'n'};
+      $l = peel($$di{'l'});
+      
+      if ($typ eq 'Disp_Xml') {
+        
+        print("Disp_Xml            : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'Disp_Xml', 'n'=>$f, 'v'=>$l});
+
+      } elsif ($typ eq 'Disp_Xml_List') {
+
+        print("Disp_Xml_List       : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'Disp_Xml_List', 'n'=>$f, 'v'=>$l});
+        
+      } elsif ($typ eq 'Disp_Xml_Chain') {
+
+        print("Disp_Xml_Chain      : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'Disp_Xml_Chain', 'n'=>$f, 'v'=>$l});
+
+      } elsif ($typ eq 'Disp_Xml_Flat') {
+        
+        print("Disp_Xml_Flat       : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'Disp_Xml_Flat', 'n'=>$f, 'v'=>$l});
+        
+      } elsif ($typ eq 'Disp_Xml_List_Flat') {
+        
+        print("Disp_Xml_List_Flat  : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'Disp_Xml_List_Flat', 'n'=>$f, 'v'=>$l});
+        
+      } elsif ($typ eq 'Disp_Xml_Flat_Chain') {
+        
+        print("Disp_Xml_Flat_Chain : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'Disp_Xml_Flat_Chain', 'n'=>$f, 'v'=>$l});
+        
+      } elsif ($typ eq 'Disp_Flag') {
+        
+        print("Disp_Flag           : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Flag($l)"});
+
+        
+      } elsif ($typ eq 'Disp_Expr_Staticness') {
+        
+        print("Disp_Expr_Staticness: ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Expr_Staticness($l)"});
+        
+      } elsif ($typ eq 'Disp_Staticness') {
+        
+        (($$str[$i+2]{'typ'}) =~ /^Disp_Expr_Staticness/) or die("Cannot parse Disp_Staticness\n");
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Staticness($l)"});
+        my $l2 = peel($$str[$i+2]{'l'});
+        push(@r,{'typ'=>'flags', 'n'=>'staticness-expr', 'v'=>"Disp_Expr_Staticness($l2)"});
+        $i++;
+        
+      } elsif ($typ eq 'Disp_Choice_Staticness') {
+        
+        print("Disp_Choice_Staticness: ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Choice_Staticness($l)"});
+        
+      } elsif ($typ eq 'Disp_Name_Staticness') {
+        
+        print("Disp_Name_Staticness: ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Name_Staticness($l)"});
+        
+      } elsif ($typ eq 'Disp_Type_Staticness') {
+        
+        print("Disp_Type_Staticness: ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Type_Staticness($l)"});
+        
+      } elsif ($typ eq 'Disp_Lexical_Layout') {
+        
+        print("Disp_Lexical_Layout : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Lexical_Layout($l)"});
+        
+      } elsif ($typ eq 'Disp_State') {
+        
+        print("Disp_State           : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_State($l)"});
+
+      } elsif ($typ eq 'Disp_Purity_State') {
+        
+        print("Disp_Purity_State    : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Purity_State($l)"});
+
+      } elsif ($typ eq 'Disp_Type_Resolved_Flag') {
+        
+        print("Disp_Type_Resolved_Flag: ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Type_Resolved_Flag($l)"});
+        
+      } elsif ($typ eq 'Disp_Depth') {
+
+        print("Disp_Depth           : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Depth($l)"});
+
+      } elsif ($typ eq 'Disp_Ident') {
+        
+        print("Disp_Ident           : ".$f.":$l\n") if ($d);
+        push(@r,{'typ'=>'flags', 'n'=>$f, 'v'=>"Disp_Ident($l)"});
+
+      } else {
+        die("Unknown disp $typ");
+      }
+      $i++;
+
+    } else {
+      die("Error: cannot merge: ".$$str[$i]{'typ'}." $i of ".scalar(@$str)."\n".Dumper($str));
+    } 
+  }
+  return \@r;
+}
+
+sub parse_disp_block {
+  my ($disp,$n) = @_;
+  my $state = 0; my @n = (); my @pren = (); my @str = (); my $pre,$c,$n, $str, $block;
+  my @n = @$n;
+  my @b = ();
+  while(length($disp = rmspace($disp))) {
+    if ($disp =~ /^null/) {
+      ($disp,$pre,$c) = (pre($disp, $`, $&));
+      push(@str, {'typ'=>'null'});
+      print("                \"".join("|",@n)."\":null\n") if ($d);
+    } elsif ($disp =~ /^return/) {
+      ($disp,$pre,$c) = (pre($disp, $`, $&));
+      push(@str, {'typ'=>'return'});
+      print("                \"".join("|",@n)."\":null\n") if ($d);
+    } elsif ($disp =~ /^$RE_h/) {
+      ($disp,$pre,$c,$p,$str) = (pre($disp, $`, $&),$1,$2);
+      push(@str, {'typ'=>$p, 'l'=>$str});
+      print("                \"".join("|",@n)."\":found header\n") if ($d);
+    } elsif ($disp =~ /^$RE_d/) {
+      ($disp,$pre,$c,$p,$str) = (pre($disp, $`, $&),$1,$2);
+      push(@str, {'typ'=>$p, 'l'=>$str});
+      print("                \"".join("|",@n)."\":found disp\n") if ($d);
+    } elsif (($disp=rmspace($disp)) =~ /^($RE_if)/s) {
+      ($disp,$pre,$c,$block) = (pre($disp, $`, $&),$1);
+      my $t,$f = undef,$_block=$block,$case; 
+      $block =~ /^\s*if.*?(?<!and )then/s or die("No if statment at beginning of $block\n");
+      $case = substr($block,0,length($`. $&));
+      $block = substr($block,length($`. $&));
+      ($block,$t) =  parse_disp_block($block,$n);
+      if (($block = rmspace($block)) =~ /^else/) {
+        ($block,$pre,$c) = (pre($block, $`, $&));
+        ($block,$f) =  parse_disp_block($block,$n);
+      }
+      $block =~ s/\s*end\s*if// or die("No end if statment at end: $block\n");
+      
+      push(@str, {'typ'=>'if', 'l'=>$c, 't'=>$t, 'f'=>$f, 'case' =>$case});
+      print("                \"".join("|",@n)."\":found if\n") if ($d);
+      
+    } elsif (($disp=rmspace($disp)) =~ /^declare.*begin.*end;/s) {
+      ($disp,$pre,$c) = (pre($disp, $`, $&));
+      push(@str, {'typ'=>'decl', 'l'=>$c});
+      print("                \"".join("|",@n)."\":found $c\n") if ($d);
+    } elsif (($disp=rmspace($disp)) =~ /^PSL.Dump_Tree.Dump_Tree\s*$RE_balanced_smothbrackets\s*;/s) {
+      ($disp,$pre,$c) = (pre($disp, $`, $&));
+      push(@str, {'typ'=>'psl', 'l'=>$c});
+      print("                \"".join("|",@n)."\":found $c\n") if ($d);
+    } else {
+      last;
+    }
+  }
+  my $a = merge(\@str);
+  return ($disp,$a);
+}
+
+sub parse_disp {
+  my ($disp) = @_;
+  my $state = 0; my @n = (); my @pren = (); my @str = (); my $pre,$c,$n, $str;
+  my @dec = ();
+  while(length($disp = rmspace($disp))) {
+    if ($state == 0) {
+      if ($disp =~ /case[^\n]+is/) {
+        ($disp,$pre,$c) = pre($disp, $`, $&);
+        $state = 1;
+      } else {
+        die ("Expecting case in ".dbg($disp)."\n");
+      }
+    } elsif ($state == 1) {
+      if ($disp =~ /^when\s+($id(?:\s*\|\s*$id)*)\s*=>/) {
+        ($disp,$pre,$c,$n) = (pre($disp, $`, $&),$1);
+        my @n = split('\s*\|\s*',$n);
+        undef(@disp); undef(@str);
+        print("Found type case \"".join("|",@n)."\"".dbg($n)."\n") if ($d);
+        push(@dec,{'n'=>\@n});
+      } elsif ($disp =~ /^end\s+case/) {
+        undef(@disp); undef(@str);
+        print("Finished type parse\n") if ($d);
+        last;
+      } else {
+        my $b;
+        ($disp,$b) = parse_disp_block($disp,\@n);
+        $dec[$#dec]{'b'} = $b;
+        #die ("Cannot scan in disp ".dbg($disp)."\n") if (scalar(@$b) <= 0);
+      }
+    } elsif ($state == 2) {
+      
+    }
+  }
+  return \@dec;
+}
+
+@dec = @{parse_disp($disp)};
+
+sub tabs { my ($n) = @_; my $r = ""; for (my $i = 0; $i < $n; $i++) { $r = $r.'   '; } return $r; }
+sub ntab { my ($n) = @_; $n =~ s/, Ntab//; return $n; }
+
+sub out_block {
+  my ($b,$t) = @_;
+  my @b = @{$b}; my $f = "";
+  foreach my $b (@b) {
+    if ($$b{'typ'} eq 'if') {
+      $f .= (ntab(tabs($t)."   ".rmspace($$b{'case'})."\n"));
+      $f .=out_block($$b{'t'},$t+1);
+      if ($$b{'f'}) {
+        $f .= (ntab(tabs($t)."   else\n"));
+        $f .=out_block($$b{'f'},$t+1);
+      }
+      $f .= (ntab(tabs($t)."   end if;\n"));
+    } elsif ($$b{'typ'} eq 'return') {
+      $f .=(ntab(tabs($t)."   return;\n"));
+    } elsif ($$b{'typ'} eq 'null') {
+      $f .=(ntab(tabs($t)."   null;\n"));
+    } elsif ($$b{'typ'} eq 'flags') {
+      my $pre = "+";
+      $pre = "" if ($$b{'v'} =~ /^\s*Disp/);
+      my $n = $$b{'n'}; $n =~ s/ /_/g;
+      $f .=(ntab(tabs($t)."   flag(e,+\"".$n."\",$pre ".$$b{'v'}.");\n"));
+    } elsif ($$b{'typ'} eq 'Disp_Label') {
+      $f .=(ntab(tabs($t)."   ".$$b{'typ'}."(e,Tree);\n"));
+    } elsif ($$b{'typ'} =~ /^Disp/) {
+      my $pre = "";
+      if ($$b{'typ'} =~ /^Disp_Xml_Flat\s*$/) {
+        $pre = "child := ";
+      }
+      $f .=(ntab(tabs($t)."   $pre".$$b{'typ'}."(e,+\"".$$b{'n'}."\",".$$b{'v'}.");\n"));
+    } elsif ($$b{'typ'} eq 'decl') {
+
+        $f .= <<DEC;
+            declare
+               Base : constant Iir := Get_Base_Type (Tree);
+               Fl : Boolean;
+            begin
+               if Base /= Null_Iir
+                 and then Get_Kind (Base) = Iir_Kind_Array_Type_Definition
+               then
+                  Fl := Get_Type_Declarator (Base)
+                    /= Get_Type_Declarator (Tree);
+               else
+                  Fl := False;
+               end if;
+               Disp_Xml (e,+"base", Base, Fl);
+            end;
+DEC
+      #$f .=(ntab(tabs($t)."    ".$$b{'typ'}."(e,\"".$$b{'n'}."\",".$$b{'v'}.");\n"));
+    } else {
+        die("Error:".$$b{'typ'});
+    }
+  }
+  return $f;
+}
+
+my $f = "";
+foreach my $d (@dec) {
+  my @n = @{$$d{'n'}};
+  $f .= ("         when ".join("|\n           ",@n)." =>\n"); 
+  $f .= out_block($$d{'b'},3);
+  
+}
+
+@_f = ();
+@f = split("\n",$f);
+foreach my $f (@f) {
+    my $fl = $f;
+    if (length($f) > 60) {
+        my @l = split(",",$f);
+        my @fl = ();
+        while(scalar(@l) && length(join(",",(@fl,$l[0]))) < 60) {
+            push(@fl,shift(@l));
+        }
+        $fl = join(",", @fl);
+        if (scalar(@l) > 0) {
+            if (length($fl)) {
+                $fl .= ",\n            ";
+            }
+            $fl .= join(",\n            ", @l);
+        }
+        #print($f."\n".$fl."\n");
+    }
+    push(@_f,$fl);
+}
+$f = join("\n",@_f);
+$tmp = readfile("disp_xml_template.adb");
+$tmp =~ s/\@typ\@/$typcase/;
+$tmp =~ s/\@disp\@/$f/;
+writefile("disp_xml.adb",$tmp);
+
+# Local Variables:
+# c-basic-offset:4
+# indent-tabs-mode:nil
+# End:
--- ghdl-r150-ori/disp_data.pl	2013-07-10 13:07:17.000000000 +0200
+++ ghdl-r150/disp_data.pl	2013-06-25 20:59:11.000000000 +0200
@@ -0,0 +1,1562 @@
+
+$typ= <<TYP;
+
+      case Get_Kind (Tree) is
+         when Iir_Kind_Design_File =>
+            Put_Line ("design file");
+
+         when Iir_Kind_Design_Unit =>
+            Put ("design_unit");
+            Disp_Identifier (Tree);
+
+         when Iir_Kind_Use_Clause =>
+            Put_Line ("use_clause");
+         when Iir_Kind_Slice_Name =>
+            Put_Line ("slice_name");
+         when Iir_Kind_Library_Clause =>
+            Put ("library clause");
+            Disp_Identifier (Tree);
+
+         when Iir_Kind_Library_Declaration =>
+            Put ("library declaration");
+            Disp_Identifier (Tree);
+
+         when Iir_Kind_Proxy =>
+            Put_Line ("proxy");
+         when Iir_Kind_Allocator_By_Expression =>
+            Put_Line ("allocator_by_expression");
+
+         when Iir_Kind_Selected_Name =>
+            Put_Line ("selected name");
+         when Iir_Kind_Implicit_Dereference =>
+            Put_Line ("implicit_dereference");
+         when Iir_Kind_Selected_Element =>
+            Put_Line ("selected element");
+
+         when Iir_Kind_Waveform_Element =>
+            Put_Line ("waveform_element");
+         when Iir_Kind_Type_Conversion =>
+            Put_Line ("type_conversion");
+         when Iir_Kind_Qualified_Expression =>
+            Put_Line ("qualified_expression");
+
+         when Iir_Kind_Package_Declaration =>
+            Put ("package_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Package_Body =>
+            Put ("package_body");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Entity_Declaration =>
+            Put ("entity_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Architecture_Declaration =>
+            Put ("architecture_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Configuration_Declaration =>
+            Put ("configuration_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Function_Declaration =>
+            Put ("function_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Function_Body =>
+            Put_Line ("function_body");
+         when Iir_Kind_Procedure_Declaration =>
+            Put ("procedure_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Procedure_Body =>
+            Put_Line ("procedure_body");
+         when Iir_Kind_Object_Alias_Declaration =>
+            Put ("object_alias_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Non_Object_Alias_Declaration =>
+            Put ("non_object_alias_declaration");
+            Disp_Identifier (Tree);
+
+         when Iir_Kind_Signal_Interface_Declaration =>
+            Put ("signal_interface_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Signal_Declaration =>
+            Put ("signal_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Variable_Interface_Declaration =>
+            Put ("variable_interface_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Variable_Declaration =>
+            if Get_Shared_Flag (Tree) then Put ("(shared) "); end if;
+            Put ("variable_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Constant_Interface_Declaration =>
+            Put ("constant_interface_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Constant_Declaration =>
+            Put ("constant_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Iterator_Declaration =>
+            Put ("iterator_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_File_Interface_Declaration =>
+            Put ("file_interface_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_File_Declaration =>
+            Put ("file_declaration");
+            Disp_Identifier (Tree);
+
+         when Iir_Kind_Type_Declaration =>
+            Put ("type_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            Put ("anonymous_type_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Subtype_Declaration =>
+            Put ("subtype_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Component_Declaration =>
+            Put ("component_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Element_Declaration =>
+            Put ("element_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Record_Element_Constraint =>
+            Put ("record_element_constraint");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Attribute_Declaration =>
+            Put ("attribute_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Group_Template_Declaration =>
+            Put ("group_template_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Group_Declaration =>
+            Put ("group_declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Psl_Declaration =>
+            Put ("psl declaration");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Psl_Expression =>
+            Put ("psl expression");
+
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Put ("enumeration_type_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            Put ("enumeration_subtype_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_Integer_Subtype_Definition =>
+            Put ("integer_subtype_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_Integer_Type_Definition =>
+            Put ("integer_type_definition");
+            Disp_Identifier (Get_Type_Declarator (Tree));
+         when Iir_Kind_Floating_Subtype_Definition =>
+            Put ("floating_subtype_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_Floating_Type_Definition =>
+            Put ("floating_type_definition");
+            Disp_Identifier (Get_Type_Declarator (Tree));
+         when Iir_Kind_Array_Subtype_Definition =>
+            Put ("array_subtype_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_Array_Type_Definition =>
+            Put ("array_type_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_Record_Type_Definition =>
+            Put ("record_type_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_Access_Type_Definition =>
+            Put ("access_type_definition");
+            Disp_Decl_Ident;
+         when Iir_Kind_File_Type_Definition =>
+            Put ("file_type_definition");
+            Disp_Identifier (Get_Type_Declarator (Tree));
+         when Iir_Kind_Subtype_Definition =>
+            Put_Line ("subtype_definition");
+         when Iir_Kind_Physical_Type_Definition =>
+            Put ("physical_type_definition");
+            Disp_Identifier (Get_Type_Declarator (Tree));
+         when Iir_Kind_Physical_Subtype_Definition =>
+            Put_Line ("physical_subtype_definition");
+
+         when Iir_Kind_Simple_Name =>
+            Put ("simple_name ");
+            Disp_Identifier (Tree);
+
+         when Iir_Kind_Operator_Symbol =>
+            Put ("operator_symbol """);
+            Name_Table.Image (Get_Identifier (Tree));
+            Put (Name_Table.Name_Buffer (1 .. Name_Table.Name_Length));
+            Put_Line ("""");
+
+         when Iir_Kind_Null_Literal =>
+            Put_Line ("null_literal");
+
+         when Iir_Kind_Physical_Int_Literal =>
+            Put_Line ("physical_int_literal");
+
+         when Iir_Kind_Bit_String_Literal =>
+            Put_Line ("bitstring_literal");
+
+         when Iir_Kind_Physical_Fp_Literal =>
+            Put_Line ("physical_fp_literal");
+
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Put ("component_instantiation_statement");
+            Disp_Ident (Get_Label (Tree));
+         when Iir_Kind_Block_Statement =>
+            Put ("block_statement");
+            Disp_Ident (Get_Label (Tree));
+         when Iir_Kind_Sensitized_Process_Statement =>
+            Put ("sensitized_process_statement");
+            Disp_Ident (Get_Label (Tree));
+         when Iir_Kind_Process_Statement =>
+            Put ("process_statement");
+            Disp_Ident (Get_Label (Tree));
+         when Iir_Kind_Case_Statement =>
+            Put_Line ("case_statement");
+         when Iir_Kind_If_Statement =>
+            Put_Line ("if_statement");
+         when Iir_Kind_Elsif =>
+            Put_Line ("elsif");
+         when Iir_Kind_For_Loop_Statement =>
+            Put_Line ("for_loop_statement");
+         when Iir_Kind_While_Loop_Statement =>
+            Put_Line ("while_loop_statement");
+         when Iir_Kind_Exit_Statement =>
+            Put_Line ("exit_statement");
+         when Iir_Kind_Next_Statement =>
+            Put_Line ("next_statement");
+         when Iir_Kind_Wait_Statement =>
+            Put_Line ("wait_statement");
+         when Iir_Kind_Assertion_Statement =>
+            Put_Line ("assertion_statement");
+         when Iir_Kind_Variable_Assignment_Statement =>
+            Put_Line ("variable_assignment_statement");
+         when Iir_Kind_Signal_Assignment_Statement =>
+            Put_Line ("signal_assignment_statement");
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            Put_Line ("concurrent_assertion_statement");
+         when Iir_Kind_Procedure_Call_Statement =>
+            Put_Line ("procedure_call_statement");
+         when Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            Put_Line ("concurrent_procedure_call_statement");
+         when Iir_Kind_Return_Statement =>
+            Put_Line ("return_statement");
+         when Iir_Kind_Null_Statement =>
+            Put_Line ("null_statement");
+
+         when Iir_Kind_Enumeration_Literal =>
+            Put ("enumeration_literal");
+            Disp_Identifier (Tree);
+
+         when Iir_Kind_Character_Literal =>
+            Put_Line ("character_literal");
+         when Iir_Kind_Integer_Literal =>
+            Put_Line ("integer_literal: "
+                      & Iir_Int64'Image (Get_Value (Tree)));
+         when Iir_Kind_Floating_Point_Literal =>
+            Put_Line ("floating_point_literal: "
+                      & Iir_Fp64'Image (Get_Fp_Value (Tree)));
+         when Iir_Kind_String_Literal =>
+            Put_Line ("string_literal: " & Image_String_Lit (Tree));
+         when Iir_Kind_Unit_Declaration =>
+            Put ("physical unit");
+            Disp_Identifier (Tree);
+         when Iir_Kind_Entity_Class =>
+            Put_Line ("entity_class '"
+                      & Tokens.Image (Get_Entity_Class (Tree)) & ''');
+
+         when Iir_Kind_Attribute_Name =>
+            Put ("attribute_name");
+            Disp_Ident (Get_Attribute_Identifier (Tree));
+
+         when Iir_Kind_Implicit_Function_Declaration =>
+            Put ("implicit_function_declaration: ");
+            Put_Line (Iirs_Utils.Get_Predefined_Function_Name
+                      (Get_Implicit_Definition (Tree)));
+         when Iir_Kind_Implicit_Procedure_Declaration =>
+            Put ("implicit_procedure_declaration: ");
+            Put_Line (Iirs_Utils.Get_Predefined_Function_Name
+                      (Get_Implicit_Definition (Tree)));
+         when others =>
+            Put_Line (Iir_Kind'Image (Get_Kind (Tree)));
+
+      end case;
+
+TYP
+
+
+$disp = <<DISP;
+      case Kind is
+         when Iir_Kind_Overload_List =>
+            Header ("overload_list:");
+            Disp_Xml_List (Get_Overload_List (Tree), Ntab, Flat_Decl);
+
+         when Iir_Kind_Error =>
+            null;
+
+         when Iir_Kind_Design_File =>
+            Header ("design_file_filename: "
+                    & Name_Table.Image (Get_Design_File_Filename (Tree)));
+            Header ("design_file_directory: "
+                    & Name_Table.Image (Get_Design_File_Directory (Tree)));
+            Header ("analysis_time_stamp: "
+                    & Files_Map.Get_Time_Stamp_String
+                    (Get_Analysis_Time_Stamp (Tree)));
+            Header ("file_time_stamp: "
+                    & Files_Map.Get_Time_Stamp_String
+                    (Get_File_Time_Stamp (Tree)));
+            Header ("library:");
+            Disp_Xml_Flat (Get_Parent (Tree), Ntab);
+            Header ("design_unit_chain:");
+            Disp_Xml_Chain (Get_First_Design_Unit (Tree), Ntab, Flat_Decl);
+
+         when Iir_Kind_Design_Unit =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("flags: date_state: "
+                    & Date_State_Type'Image (Get_Date_State (Tree))
+                    & ", elab: "
+                    & Boolean'Image (Get_Elab_Flag (Tree)));
+            Header ("date:" & Date_Type'Image (Get_Date (Tree)));
+            Header ("parent (design file):");
+            Disp_Xml_Flat (Get_Design_File (Tree), Ntab);
+            Header ("dependence list:");
+            Disp_Xml_List_Flat (Get_Dependence_List (Tree), Ntab);
+            if Get_Date_State (Tree) /= Date_Disk then
+               Header ("context items:");
+               Disp_Xml_Chain (Get_Context_Items (Tree), Ntab);
+            end if;
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+            Header ("library unit:");
+            Disp_Xml (Get_Library_Unit (Tree), Ntab);
+         when Iir_Kind_Use_Clause =>
+            Header ("selected name:");
+            Disp_Xml (Get_Selected_Name (Tree), Ntab, True);
+            Header ("use_clause_chain:");
+            Disp_Xml (Get_Use_Clause_Chain (Tree), Ntab);
+         when Iir_Kind_Library_Clause =>
+            Header ("library declaration:");
+            Disp_Xml_Flat (Get_Library_Declaration (Tree), Ntab);
+
+         when Iir_Kind_Library_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("library_directory: "
+                    & Name_Table.Image (Get_Library_Directory (Tree)));
+            Header ("design file list:");
+            Disp_Xml_Chain (Get_Design_File_Chain (Tree), Ntab);
+
+         when Iir_Kind_Entity_Declaration =>
+            Header ("generic chain:");
+            Disp_Xml_Chain (Get_Generic_Chain (Tree), Ntab);
+            Header ("port chain:");
+            Disp_Xml_Chain (Get_Port_Chain (Tree), Ntab);
+            Header ("declaration chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("concurrent_statements:");
+            Disp_Xml_Chain (Get_Concurrent_Statement_Chain (Tree), Ntab);
+         when Iir_Kind_Package_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("need_body: " & Boolean'Image (Get_Need_Body (Tree)));
+            Header ("declaration chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+         when Iir_Kind_Package_Body =>
+            Header ("package:");
+            Disp_Xml_Flat (Get_Package (Tree), Ntab);
+            Header ("declaration:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+         when Iir_Kind_Architecture_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("entity:");
+            Disp_Xml_Flat (Get_Entity (Tree), Ntab);
+            Header ("declaration_chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("concurrent_statements:");
+            Disp_Xml_Chain (Get_Concurrent_Statement_Chain (Tree), Ntab);
+            Header ("default configuration:");
+            Disp_Xml_Flat
+              (Get_Default_Configuration_Declaration (Tree), Ntab);
+         when Iir_Kind_Configuration_Declaration =>
+            Header ("entity:");
+            Disp_Xml_Flat (Get_Entity (Tree), Ntab);
+            Header ("declaration_chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("block_configuration:");
+            Disp_Xml (Get_Block_Configuration (Tree), Ntab, True);
+
+         when Iir_Kind_Entity_Aspect_Entity =>
+            Header ("entity:");
+            Disp_Xml_Flat (Get_Entity (Tree), Ntab);
+            Header ("architecture:");
+            Disp_Xml_Flat (Get_Architecture (Tree), Ntab);
+         when Iir_Kind_Entity_Aspect_Configuration =>
+            Header ("configuration:");
+            Disp_Xml (Get_Configuration (Tree), Ntab, True);
+         when Iir_Kind_Entity_Aspect_Open =>
+            null;
+
+         when Iir_Kind_Block_Configuration =>
+            Header ("block_specification:");
+            Disp_Xml (Get_Block_Specification (Tree), Ntab, True);
+            Header ("declaration_chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("configuration_item_chain:");
+            Disp_Xml_Chain (Get_Configuration_Item_Chain (Tree), Ntab);
+            Header ("prev_block_configuration:");
+            Disp_Xml_Flat (Get_Prev_Block_Configuration (Tree), Ntab);
+         when Iir_Kind_Attribute_Specification =>
+            Header ("attribute_designator:");
+            Disp_Xml (Get_Attribute_Designator (Tree), Ntab, True);
+            Header ("entity_name_list:");
+            Disp_Xml_List_Flat (Get_Entity_Name_List (Tree), Ntab);
+            Header ("entity_class: "
+                    & Tokens.Image (Get_Entity_Class (Tree)));
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab);
+            Header ("attribute_value_spec_chain:");
+            Disp_Xml_Chain (Get_Attribute_Value_Spec_Chain (Tree), Ntab);
+         when Iir_Kind_Configuration_Specification
+           | Iir_Kind_Component_Configuration =>
+            Header ("instantiation_list:");
+            Disp_Xml_List_Flat (Get_Instantiation_List (Tree), Ntab);
+            Header ("component_name:");
+            Disp_Xml (Get_Component_Name (Tree), Ntab, True);
+            Header ("binding_indication:");
+            Disp_Xml (Get_Binding_Indication (Tree), Ntab);
+            if Kind = Iir_Kind_Component_Configuration then
+               Header ("block_configuration:");
+               Disp_Xml (Get_Block_Configuration (Tree), Ntab);
+            end if;
+         when Iir_Kind_Binding_Indication =>
+            Header ("entity_aspect:");
+            Disp_Xml (Get_Entity_Aspect (Tree), Ntab, True);
+            Header ("generic_map_aspect_chain:");
+            Disp_Xml_Chain (Get_Generic_Map_Aspect_Chain (Tree), Ntab);
+            Header ("port_map_aspect_chain:");
+            Disp_Xml_Chain (Get_Port_Map_Aspect_Chain (Tree), Ntab);
+            Header ("default_generic_map_aspect_chain:");
+            Disp_Xml_Chain
+              (Get_Default_Generic_Map_Aspect_Chain (Tree), Ntab);
+            Header ("default_port_map_aspect_chain:");
+            Disp_Xml_Chain (Get_Default_Port_Map_Aspect_Chain (Tree), Ntab);
+         when Iir_Kind_Block_Header =>
+            Header ("generic chain:");
+            Disp_Xml_Chain (Get_Generic_Chain (Tree), Ntab);
+            Header ("generic_map_aspect_chain:");
+            Disp_Xml_Chain (Get_Generic_Map_Aspect_Chain (Tree), Ntab);
+            Header ("port chain:");
+            Disp_Xml_Chain (Get_Port_Chain (Tree), Ntab);
+            Header ("port_map_aspect_chain:");
+            Disp_Xml_Chain (Get_Port_Map_Aspect_Chain (Tree), Ntab);
+         when Iir_Kind_Attribute_Value =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("attribute_specification:");
+            Disp_Xml_Flat (Get_Attribute_Specification (Tree), Ntab);
+            Header ("designated_entity:");
+            Disp_Xml_Flat (Get_Designated_Entity (Tree), Ntab);
+         when Iir_Kind_Signature =>
+            Header ("return_type:");
+            Disp_Xml_Flat (Get_Return_Type (Tree), Ntab);
+            Header ("type_marks_list:");
+            Disp_Xml_List (Get_Type_Marks_List (Tree), Ntab);
+         when Iir_Kind_Disconnection_Specification =>
+            Header ("signal_list:");
+            Disp_Xml_List (Get_Signal_List (Tree), Ntab, True);
+            Header ("type_mark:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("time expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab);
+
+         when Iir_Kind_Association_Element_By_Expression =>
+            Header ("whole_association_flag: ", False);
+            Disp_Flag (Get_Whole_Association_Flag (Tree));
+            Header ("collapse_signal_flag: ", False);
+            Disp_Flag (Get_Collapse_Signal_Flag (Tree));
+            Header ("formal:");
+            Disp_Xml (Get_Formal (Tree), Ntab, True);
+            Header ("out_conversion:");
+            Disp_Xml (Get_Out_Conversion (Tree), Ntab, True);
+            Header ("actual:");
+            Disp_Xml (Get_Actual (Tree), Ntab, True);
+            Header ("in_conversion:");
+            Disp_Xml (Get_In_Conversion (Tree), Ntab, True);
+         when Iir_Kind_Association_Element_By_Individual =>
+            Header ("whole_association_flag: ", False);
+            Disp_Flag (Get_Whole_Association_Flag (Tree));
+            Header ("formal:");
+            Disp_Xml (Get_Formal (Tree), Ntab, True);
+            Header ("actual_type:");
+            Disp_Xml (Get_Actual_Type (Tree), Ntab, True);
+            Header ("individual_association_chain:");
+            Disp_Xml_Chain (Get_Individual_Association_Chain (Tree), Ntab);
+         when Iir_Kind_Association_Element_Open =>
+            Header ("formal:");
+            Disp_Xml (Get_Formal (Tree), Ntab, True);
+
+         when Iir_Kind_Waveform_Element =>
+            Header ("value:");
+            Disp_Xml (Get_We_Value (Tree), Ntab, True);
+            Header ("time:");
+            Disp_Xml (Get_Time (Tree), Ntab);
+         when Iir_Kind_Conditional_Waveform =>
+            Header ("condition:");
+            Disp_Xml (Get_Condition (Tree), Ntab);
+            Header ("waveform_chain:");
+            Disp_Xml_Chain (Get_Waveform_Chain (Tree), Ntab);
+
+         when Iir_Kind_Choice_By_Name =>
+            Header ("name:");
+            Disp_Xml (Get_Name (Tree), Ntab);
+            Header ("associated:");
+            Disp_Xml (Get_Associated (Tree), Ntab, True);
+         when Iir_Kind_Choice_By_Others =>
+            Header ("associated");
+            Disp_Xml (Get_Associated (Tree), Ntab, True);
+         when Iir_Kind_Choice_By_None =>
+            Header ("associated");
+            Disp_Xml (Get_Associated (Tree), Ntab, True);
+         when Iir_Kind_Choice_By_Range =>
+            Header ("staticness: ", False);
+            Disp_Choice_Staticness (Tree);
+            Header ("range:");
+            Disp_Xml (Get_Expression (Tree), Ntab);
+            Header ("associated");
+            Disp_Xml (Get_Associated (Tree), Ntab, True);
+         when Iir_Kind_Choice_By_Expression =>
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab);
+            Header ("staticness: ", False);
+            Disp_Choice_Staticness (Tree);
+            Header ("associated");
+            Disp_Xml (Get_Associated (Tree), Ntab, True);
+
+         when Iir_Kind_Signal_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Name_Staticness (Tree);
+            Header ("lexical layout:", False);
+            Disp_Lexical_Layout (Tree);
+            Header ("mode: " & Iir_Mode'Image (Get_Mode (Tree)));
+            Header ("signal kind: "
+                    & Iir_Signal_Kind'Image (Get_Signal_Kind (Tree)));
+            Header ("has_active_flag: ", False);
+            Disp_Flag (Get_Has_Active_Flag (Tree));
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("default value:");
+            Disp_Xml (Get_Default_Value (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Variable_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Name_Staticness (Tree);
+            Header ("lexical layout:", False);
+            Disp_Lexical_Layout (Tree);
+            Header ("mode: " & Iir_Mode'Image (Get_Mode (Tree)));
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("default value:");
+            Disp_Xml (Get_Default_Value (Tree), Ntab, True);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Constant_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Name_Staticness (Tree);
+            Header ("lexical layout:", False);
+            Disp_Lexical_Layout (Tree);
+            Header ("mode: " & Iir_Mode'Image (Get_Mode (Tree)));
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("default value:");
+            Disp_Xml (Get_Default_Value (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_File_Interface_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Name_Staticness (Tree);
+            Header ("lexical layout:", False);
+            Disp_Lexical_Layout (Tree);
+            Header ("mode: " & Iir_Mode'Image (Get_Mode (Tree)));
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+
+         when Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("kind: " & Iir_Signal_Kind'Image (Get_Signal_Kind (Tree)));
+            Header ("has_active_flag: ", False);
+            Disp_Flag (Get_Has_Active_Flag (Tree));
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            if Kind = Iir_Kind_Signal_Declaration then
+               Header ("default value:");
+               Disp_Xml (Get_Default_Value (Tree), Ntab, True);
+               Header ("signal_driver:");
+               Disp_Xml_Flat (Get_Signal_Driver (Tree), Ntab);
+            else
+               Header ("guard expr:");
+               Disp_Xml (Get_Guard_Expression (Tree), Ntab);
+               Header ("guard sensitivity list:");
+               Disp_Xml_List (Get_Guard_Sensitivity_List (Tree), Ntab);
+            end if;
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Constant_Declaration
+           | Iir_Kind_Iterator_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            if Kind = Iir_Kind_Constant_Declaration then
+               Header ("deferred flag: " & Boolean'Image
+                       (Get_Deferred_Declaration_Flag (Tree)));
+               Header ("deferred: ");
+               Disp_Xml (Get_Deferred_Declaration (Tree), Ntab, True);
+               Header ("default value:");
+               Disp_Xml (Get_Default_Value (Tree), Ntab, True);
+            end if;
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Variable_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("default value:");
+            Disp_Xml (Get_Default_Value (Tree), Ntab, True);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_File_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("logical name:");
+            Disp_Xml (Get_File_Logical_Name (Tree), Ntab);
+            Header ("mode: " & Iir_Mode'Image (Get_Mode (Tree)));
+            Header ("file_open_kind:");
+            Disp_Xml (Get_File_Open_Kind (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Subtype_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("type (definition):");
+            Disp_Xml (Get_Type (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("type (definition):");
+            Disp_Xml (Get_Type (Tree), Ntab);
+         when Iir_Kind_Component_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("generic chain:");
+            Disp_Xml_Chain (Get_Generic_Chain (Tree), Ntab);
+            Header ("port chain:");
+            Disp_Xml_Chain (Get_Port_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Element_Declaration =>
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Record_Element_Constraint =>
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("element_declaration:");
+            Disp_Xml (Get_Element_Declaration (Tree), Ntab);
+         when Iir_Kind_Attribute_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Psl_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+         when Iir_Kind_Psl_Expression =>
+            return;
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Procedure_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("interface_declaration_chain:");
+            Disp_Xml_Chain (Get_Interface_Declaration_Chain (Tree), Ntab);
+            if Kind = Iir_Kind_Function_Declaration then
+               Header ("return type:");
+               Disp_Xml (Get_Return_Type (Tree), Ntab, True);
+               Header ("pure_flag: ", False);
+               Disp_Flag (Get_Pure_Flag (Tree));
+            else
+               Header ("purity_state:", False);
+               Disp_Purity_State (Get_Purity_State (Tree));
+            end if;
+            Header ("wait_state:", False);
+            Disp_State (Get_Wait_State (Tree));
+            Header ("all_sensitized_state: " & Iir_All_Sensitized'Image
+                      (Get_All_Sensitized_State (Tree)));
+            Header ("subprogram_depth:", False);
+            Disp_Depth (Get_Subprogram_Depth (Tree));
+            Header ("subprogram_body:");
+            Disp_Xml_Flat (Get_Subprogram_Body (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Procedure_Body
+           | Iir_Kind_Function_Body =>
+            Header ("specification:");
+            Disp_Xml_Flat (Get_Subprogram_Specification (Tree), Ntab);
+            Header ("declaration_chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("statements:");
+            Disp_Xml_Chain (Get_Sequential_Statement_Chain (Tree), Ntab);
+         when Iir_Kind_Implicit_Function_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("operation: "
+                    & Iir_Predefined_Functions'Image
+                    (Get_Implicit_Definition (Tree)));
+            Header ("interface declaration chain:");
+            Disp_Xml_Chain (Get_Interface_Declaration_Chain (Tree), Ntab);
+            Header ("return type:");
+            Disp_Xml (Get_Return_Type (Tree), Ntab, True);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Implicit_Procedure_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("interface declaration chain:");
+            Disp_Xml_Chain (Get_Interface_Declaration_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Object_Alias_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("name:");
+            Disp_Xml (Get_Name (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Non_Object_Alias_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("name:");
+            Disp_Xml (Get_Name (Tree), Ntab);
+            Header ("signature:");
+            Disp_Xml (Get_Signature (Tree), Ntab, True);
+
+         when Iir_Kind_Group_Template_Declaration =>
+            Header ("entity_class_entry:");
+            Disp_Xml_Chain (Get_Entity_Class_Entry_Chain (Tree), Ntab);
+         when Iir_Kind_Group_Declaration =>
+            Header ("group_constituent_list:");
+            Disp_Xml_List_Flat (Get_Group_Constituent_List (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+
+         when Iir_Kind_Enumeration_Type_Definition =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("type declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("literals:");
+            Disp_Xml_List (Get_Enumeration_Literal_List (Tree), Ntab);
+         when Iir_Kind_Integer_Type_Definition
+           | Iir_Kind_Floating_Type_Definition =>
+            if Flat_Decl and then not Is_Anonymous_Type_Definition (Tree)
+            then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("type_declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+         when Iir_Kind_Integer_Subtype_Definition
+           | Iir_Kind_Floating_Subtype_Definition
+           | Iir_Kind_Physical_Subtype_Definition
+           | Iir_Kind_Enumeration_Subtype_Definition
+           | Iir_Kind_Subtype_Definition =>
+            if Flat_Decl
+              and then Kind /= Iir_Kind_Subtype_Definition
+              and then Get_Type_Declarator (Tree) /= Null_Iir
+            then
+               return;
+            end if;
+            if Kind /= Iir_Kind_Subtype_Definition then
+               Header ("staticness: ", False);
+               Disp_Type_Staticness (Tree);
+               Header ("resolved flag: ", False);
+               Disp_Type_Resolved_Flag (Tree);
+               Header ("signal_type_flag: ", False);
+               Disp_Flag (Get_Signal_Type_Flag (Tree));
+               Header ("has_signal_flag: ", False);
+               Disp_Flag (Get_Has_Signal_Flag (Tree));
+               Header ("type declarator:");
+               Disp_Xml (Get_Type_Declarator (Tree), Ntab, True);
+               Header ("base type:");
+               Disp_Xml (Get_Base_Type (Tree), Ntab, True);
+            end if;
+            Header ("type mark:");
+            Disp_Xml (Get_Type_Mark (Tree), Ntab, True);
+            Header ("resolution function:");
+            Disp_Xml_Flat (Get_Resolution_Function (Tree), Ntab);
+            Header ("range constraint:");
+            Disp_Xml (Get_Range_Constraint (Tree), Ntab);
+         when Iir_Kind_Range_Expression =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("left limit:");
+            Disp_Xml (Get_Left_Limit (Tree), Ntab, True);
+            Header ("right limit:");
+            Disp_Xml (Get_Right_Limit (Tree), Ntab, True);
+            Header ("direction: "
+                    & Iir_Direction'Image (Get_Direction (Tree)));
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Array_Subtype_Definition =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            Header ("staticness:", false);
+            Disp_Type_Staticness (Tree);
+            Header ("resolved flag: ", False);
+            Disp_Type_Resolved_Flag (Tree);
+            Header ("signal_type_flag: ", False);
+            Disp_Flag (Get_Signal_Type_Flag (Tree));
+            Header ("has_signal_flag: ", False);
+            Disp_Flag (Get_Has_Signal_Flag (Tree));
+            Header ("type declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("base type:");
+            declare
+               Base : constant Iir := Get_Base_Type (Tree);
+               Fl : Boolean;
+            begin
+               if Base /= Null_Iir
+                 and then Get_Kind (Base) = Iir_Kind_Array_Type_Definition
+               then
+                  Fl := Get_Type_Declarator (Base)
+                    /= Get_Type_Declarator (Tree);
+               else
+                  Fl := False;
+               end if;
+               Disp_Xml (Base, Ntab, Fl);
+            end;
+            Header ("type mark:");
+            Disp_Xml (Get_Type_Mark (Tree), Ntab, True);
+            Header ("index_subtype_list:");
+            Disp_Xml_List (Get_Index_Subtype_List (Tree), Ntab, True);
+            Header ("element_subtype:");
+            Disp_Xml (Get_Element_Subtype (Tree), Ntab, True);
+            Header ("resolution function:");
+            Disp_Xml_Flat (Get_Resolution_Function (Tree), Ntab);
+            Header ("index_constraint: ", False);
+            Disp_Flag (Get_Index_Constraint_Flag (Tree));
+            Header ("constraint_state: "
+                      & Iir_Constraint'Image (Get_Constraint_State (Tree)));
+         when Iir_Kind_Array_Type_Definition  =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("resolved flag: ", False);
+            Disp_Type_Resolved_Flag (Tree);
+            Header ("signal_type_flag: ", False);
+            Disp_Flag (Get_Signal_Type_Flag (Tree));
+            Header ("has_signal_flag: ", False);
+            Disp_Flag (Get_Has_Signal_Flag (Tree));
+            Header ("index_subtype_list:");
+            Disp_Xml_List (Get_Index_Subtype_List (Tree), Ntab, True);
+            Header ("element_subtype:");
+            Disp_Xml (Get_Element_Subtype (Tree), Ntab, True);
+         when Iir_Kind_Record_Type_Definition =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("resolved flag: ", False);
+            Disp_Type_Resolved_Flag (Tree);
+            Header ("signal_type_flag: ", False);
+            Disp_Flag (Get_Signal_Type_Flag (Tree));
+            Header ("has_signal_flag: ", False);
+            Disp_Flag (Get_Has_Signal_Flag (Tree));
+            Header ("constraint_state: "
+                      & Iir_Constraint'Image (Get_Constraint_State (Tree)));
+            Header ("elements:");
+            Disp_Xml_List (Get_Elements_Declaration_List (Tree), Ntab, True);
+         when Iir_Kind_Record_Subtype_Definition =>
+            if Flat_Decl and then not Is_Anonymous_Type_Definition (Tree) then
+               return;
+            end if;
+            Header ("type declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("resolved flag: ", False);
+            Disp_Type_Resolved_Flag (Tree);
+            Header ("signal_type_flag: ", False);
+            Disp_Flag (Get_Signal_Type_Flag (Tree));
+            Header ("base type:");
+            Disp_Xml (Get_Base_Type (Tree), Ntab, True);
+            Header ("type mark:");
+            Disp_Xml (Get_Type_Mark (Tree), Ntab, True);
+            Header ("resolution function:");
+            Disp_Xml_Flat (Get_Resolution_Function (Tree), Ntab);
+            Header ("constraint_state: "
+                      & Iir_Constraint'Image (Get_Constraint_State (Tree)));
+            Header ("elements:");
+            Disp_Xml_List (Get_Elements_Declaration_List (Tree), Ntab, True);
+         when Iir_Kind_Physical_Type_Definition =>
+            if Flat_Decl and then Get_Type_Declarator (Tree) /= Null_Iir then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("resolved flag: ", False);
+            Disp_Type_Resolved_Flag (Tree);
+            Header ("declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("unit chain:");
+            Disp_Xml_Chain (Get_Unit_Chain (Tree), Ntab);
+         when Iir_Kind_Unit_Declaration =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("physical_literal:");
+            Disp_Xml (Get_Physical_Literal (Tree), Ntab, True);
+            Header ("physical_Unit_Value:");
+            Disp_Xml (Get_Physical_Unit_Value (Tree), Ntab, True);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+
+         when Iir_Kind_Access_Type_Definition =>
+            if Flat_Decl then
+               return;
+            end if;
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("resolved flag: ", False);
+            Disp_Type_Resolved_Flag (Tree);
+            Header ("signal_type_flag: ", False);
+            Disp_Flag (Get_Signal_Type_Flag (Tree));
+            Header ("declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("designated type:");
+            Disp_Xml_Flat (Get_Designated_Type (Tree), Ntab);
+         when Iir_Kind_Access_Subtype_Definition =>
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("resolved flag: ", False);
+            Disp_Type_Resolved_Flag (Tree);
+            Header ("declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("base type:");
+            Disp_Xml (Get_Base_Type (Tree), Ntab, True);
+            Header ("type mark:");
+            Disp_Xml (Get_Type_Mark (Tree), Ntab, True);
+            Header ("designated type:");
+            Disp_Xml_Flat (Get_Designated_Type (Tree), Ntab);
+            Header ("resolution function:");
+            Disp_Xml_Flat (Get_Resolution_Function (Tree), Ntab);
+
+         when Iir_Kind_Incomplete_Type_Definition =>
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("base type:");
+            Disp_Xml (Get_Base_Type (Tree), Ntab, True);
+
+         when Iir_Kind_File_Type_Definition =>
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("type mark:");
+            Disp_Xml_Flat (Get_Type_Mark (Tree), Ntab);
+         when Iir_Kind_Protected_Type_Declaration =>
+            Header ("staticness: ", False);
+            Disp_Type_Staticness (Tree);
+            Header ("declarator:");
+            Disp_Xml_Flat (Get_Type_Declarator (Tree), Ntab);
+            Header ("protected_type_body:");
+            Disp_Xml_Flat (Get_Protected_Type_Body (Tree), Ntab);
+            Header ("declarative_part:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+         when Iir_Kind_Protected_Type_Body =>
+            Header ("protected_type_declaration:");
+            Disp_Xml_Flat (Get_Protected_Type_Declaration (Tree), Ntab);
+            Header ("declarative_part:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+
+         when Iir_Kind_Block_Statement =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Label (Tree);
+            Header ("guard decl:");
+            Disp_Xml (Get_Guard_Decl (Tree), Ntab);
+            Header ("block header:");
+            Disp_Xml (Get_Block_Header (Tree), Ntab);
+            Header ("declaration_chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("concurrent statements:");
+            Disp_Xml_Chain (Get_Concurrent_Statement_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Generate_Statement =>
+            if Flat_Decl then
+               return;
+            end if;
+            Disp_Label (Tree);
+            Header ("generation_scheme:");
+            Disp_Xml (Get_Generation_Scheme (Tree), Ntab);
+            Header ("declaration_chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("concurrent statements:");
+            Disp_Xml_Chain (Get_Concurrent_Statement_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Label (Tree);
+            Header ("instantiated unit:");
+            Disp_Xml (Get_Instantiated_Unit (Tree), Ntab, True);
+            Header ("generic map aspect chain:");
+            Disp_Xml_Chain (Get_Generic_Map_Aspect_Chain (Tree), Ntab);
+            Header ("port map aspect chain:");
+            Disp_Xml_Chain (Get_Port_Map_Aspect_Chain (Tree), Ntab);
+            Header ("component_configuration:");
+            Disp_Xml (Get_Component_Configuration (Tree), Ntab);
+            Header ("default binding indication:");
+            Disp_Xml (Get_Default_Binding_Indication (Tree), Ntab, True);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            Header ("guarded_target_flag: "
+                    & Tri_State_Type'Image (Get_Guarded_Target_State (Tree)));
+            Header ("target:");
+            Disp_Xml (Get_Target (Tree), Ntab, True);
+            if Get_Guard (Tree) = Tree then
+               Header ("guard: guarded");
+            else
+               Header ("guard:");
+               Disp_Xml_Flat (Get_Guard (Tree), Ntab);
+            end if;
+            Header ("conditional waveform chain:");
+            Disp_Xml_Chain (Get_Conditional_Waveform_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Concurrent_Selected_Signal_Assignment =>
+            Header ("guarded_target_flag: "
+                    & Tri_State_Type'Image (Get_Guarded_Target_State (Tree)));
+            Header ("target:");
+            Disp_Xml (Get_Target (Tree), Ntab, True);
+            if Get_Guard (Tree) = Tree then
+               Header ("guard: guarded");
+            else
+               Header ("guard:");
+               Disp_Xml_Flat (Get_Guard (Tree), Ntab);
+            end if;
+            Header ("choices:");
+            Disp_Xml_Chain (Get_Selected_Waveform_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            Header ("condition:");
+            Disp_Xml (Get_Assertion_Condition (Tree), Ntab);
+            Header ("report expression:");
+            Disp_Xml (Get_Report_Expression (Tree), Ntab);
+            Header ("severity expression:");
+            Disp_Xml (Get_Severity_Expression (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Psl_Assert_Statement =>
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+            PSL.Dump_Tree.Dump_Tree (Get_Psl_Property (Tree), True);
+         when Iir_Kind_Psl_Default_Clock =>
+            null;
+
+         when Iir_Kind_Sensitized_Process_Statement
+           | Iir_Kind_Process_Statement =>
+            Disp_Label (Tree);
+            Header ("passive: " & Boolean'Image (Get_Passive_Flag (Tree)));
+            if Kind = Iir_Kind_Sensitized_Process_Statement then
+               Header ("sensivity list:");
+               Disp_Xml_List (Get_Sensitivity_List (Tree), Ntab, True);
+            end if;
+            Header ("declaration_chain:");
+            Disp_Xml_Chain (Get_Declaration_Chain (Tree), Ntab);
+            Header ("process statements:");
+            Disp_Xml_Chain (Get_Sequential_Statement_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_If_Statement =>
+            Header ("condition:");
+            Disp_Xml (Get_Condition (Tree), Ntab, True);
+            Header ("then sequence:");
+            Disp_Xml_Chain (Get_Sequential_Statement_Chain (Tree), Ntab);
+            Header ("elsif:");
+            Disp_Xml (Get_Else_Clause (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Elsif =>
+            Header ("condition:");
+            Disp_Xml (Get_Condition (Tree), Ntab);
+            Header ("then sequence:");
+            Disp_Xml_Chain (Get_Sequential_Statement_Chain (Tree), Ntab);
+            Header ("elsif:");
+            Disp_Xml (Get_Else_Clause (Tree), Ntab);
+         when Iir_Kind_For_Loop_Statement =>
+            Header ("iterator:");
+            Disp_Xml (Get_Iterator_Scheme (Tree), Ntab);
+            Header ("statements:");
+            Disp_Xml_Chain (Get_Sequential_Statement_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_While_Loop_Statement =>
+            Header ("condition:");
+            Disp_Xml (Get_Condition (Tree), Ntab);
+            Header ("statements:");
+            Disp_Xml_Chain (Get_Sequential_Statement_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Case_Statement =>
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab, True);
+            Header ("choices chain:");
+            Disp_Xml_Chain
+              (Get_Case_Statement_Alternative_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Signal_Assignment_Statement =>
+            Header ("guarded_target_flag: "
+                    & Tri_State_Type'Image (Get_Guarded_Target_State (Tree)));
+            Header ("target:");
+            Disp_Xml (Get_Target (Tree), Ntab, True);
+            Header ("waveform_chain:");
+            Disp_Xml_Chain (Get_Waveform_Chain (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Variable_Assignment_Statement =>
+            Header ("target:");
+            Disp_Xml (Get_Target (Tree), Ntab, True);
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Assertion_Statement =>
+            Header ("condition:");
+            Disp_Xml (Get_Assertion_Condition (Tree), Ntab);
+            Header ("report expression:");
+            Disp_Xml (Get_Report_Expression (Tree), Ntab);
+            Header ("severity expression:");
+            Disp_Xml (Get_Severity_Expression (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Report_Statement =>
+            Header ("report expression:");
+            Disp_Xml (Get_Report_Expression (Tree), Ntab);
+            Header ("severity expression:");
+            Disp_Xml (Get_Severity_Expression (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Return_Statement =>
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab, True);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Wait_Statement =>
+            Header ("sensitivity list:");
+            Disp_Xml_List (Get_Sensitivity_List (Tree), Ntab, True);
+            Header ("condition:");
+            Disp_Xml (Get_Condition_Clause (Tree), Ntab);
+            Header ("timeout:");
+            Disp_Xml (Get_Timeout_Clause (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Procedure_Call_Statement
+           | Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            Disp_Label (Tree);
+            Header ("procedure_call:");
+            Disp_Xml (Get_Procedure_Call (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Procedure_Call =>
+            Header ("implementation:");
+            Disp_Xml (Get_Implementation (Tree), Ntab, True);
+            Header ("method_object:");
+            Disp_Xml (Get_Method_Object (Tree), Ntab);
+            Header ("parameters:");
+            Disp_Xml_Chain (Get_Parameter_Association_Chain (Tree), Ntab);
+         when Iir_Kind_Exit_Statement
+           | Iir_Kind_Next_Statement =>
+            Header ("loop:");
+            Disp_Xml_Flat (Get_Loop (Tree), Ntab);
+            Header ("condition:");
+            Disp_Xml (Get_Condition (Tree), Ntab);
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+         when Iir_Kind_Null_Statement =>
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+
+         when Iir_Kinds_Dyadic_Operator =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("implementation:");
+            Disp_Xml (Get_Implementation (Tree), Ntab, True);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("left:");
+            Disp_Xml (Get_Left (Tree), Ntab, True);
+            Header ("right:");
+            Disp_Xml (Get_Right (Tree), Ntab, True);
+
+         when Iir_Kinds_Monadic_Operator =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("implementation:");
+            Disp_Xml (Get_Implementation (Tree), Ntab, True);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("operand:");
+            Disp_Xml (Get_Operand (Tree), Ntab, True);
+
+         when Iir_Kind_Function_Call =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("implementation:");
+            Disp_Xml_Flat (Get_Implementation (Tree), Ntab);
+            Header ("method_object:");
+            Disp_Xml (Get_Method_Object (Tree), Ntab);
+            Header ("parameters:");
+            Disp_Xml_Chain (Get_Parameter_Association_Chain (Tree), Ntab);
+         when Iir_Kind_Qualified_Expression =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("type mark:");
+            Disp_Xml (Get_Type_Mark (Tree), Ntab, True);
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab, True);
+         when Iir_Kind_Type_Conversion =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab, True);
+         when Iir_Kind_Allocator_By_Expression =>
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("expression:");
+            Disp_Xml (Get_Expression (Tree), Ntab, True);
+         when Iir_Kind_Allocator_By_Subtype =>
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("subtype indication:");
+            Disp_Xml (Get_Expression (Tree), Ntab, True);
+         when Iir_Kind_Selected_Element =>
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, True);
+            Header ("selected element:");
+            Disp_Xml (Get_Selected_Element (Tree), Ntab, True);
+         when Iir_Kind_Implicit_Dereference
+           | Iir_Kind_Dereference =>
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, True);
+
+         when Iir_Kind_Aggregate =>
+            Header ("staticness: value: ", false);
+            Disp_Staticness (Get_Value_Staticness (Tree));
+            Disp_Expr_Staticness (Tree);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("aggregate_info:");
+            Disp_Xml (Get_Aggregate_Info (Tree), Ntab);
+            Header ("associations:");
+            Disp_Xml_Chain (Get_Association_Choices_Chain (Tree), Ntab);
+         when Iir_Kind_Aggregate_Info =>
+            Header ("aggr_others_flag: ", False);
+            Disp_Flag (Get_Aggr_Others_Flag (Tree));
+            Header ("aggr_named_flag: ", False);
+            Disp_Flag (Get_Aggr_Named_Flag (Tree));
+            Header ("aggr_dynamic_flag: ", False);
+            Disp_Flag (Get_Aggr_Dynamic_Flag (Tree));
+            Header ("aggr_low_limit:");
+            Disp_Xml (Get_Aggr_Low_Limit (Tree), Ntab, False);
+            Header ("aggr_high_limit:");
+            Disp_Xml (Get_Aggr_High_Limit (Tree), Ntab, False);
+            Header ("aggr_max_length:" &
+                    Iir_Int32'Image (Get_Aggr_Max_Length (Tree)));
+            Header ("sub_aggregate_info:");
+            Disp_Xml (Get_Sub_Aggregate_Info (Tree), Ntab);
+         when Iir_Kind_Operator_Symbol =>
+            null;
+         when Iir_Kind_Simple_Name =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Indexed_Name =>
+            Header ("staticness:", false);
+            Disp_Name_Staticness (Tree);
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, True);
+            Header ("index:");
+            Disp_Xml_List (Get_Index_List (Tree), Ntab, True);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Slice_Name =>
+            Header ("staticness:", false);
+            Disp_Name_Staticness (Tree);
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, True);
+            Header ("suffix:");
+            Disp_Xml (Get_Suffix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Parenthesis_Name =>
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, Flat_Decl);
+            Header ("association chain:");
+            Disp_Xml_Chain (Get_Association_Chain (Tree), Ntab);
+         when Iir_Kind_Selected_By_All_Name =>
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, True);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+         when Iir_Kind_Selected_Name =>
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, True);
+            Header ("identifier: ", False);
+            Disp_Ident (Get_Suffix_Identifier (Tree));
+
+         when Iir_Kind_Attribute_Name =>
+            Header ("prefix:");
+            Disp_Xml (Get_Prefix (Tree), Ntab, True);
+            Header ("signature:");
+            Disp_Xml (Get_Signature (Tree), Ntab);
+
+         when Iir_Kind_Base_Attribute =>
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+         when Iir_Kind_Left_Type_Attribute
+           | Iir_Kind_Right_Type_Attribute
+           | Iir_Kind_High_Type_Attribute
+           | Iir_Kind_Low_Type_Attribute
+           | Iir_Kind_Ascending_Type_Attribute =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+         when Iir_Kind_Image_Attribute
+           | Iir_Kind_Value_Attribute =>
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("parameter:");
+            Disp_Xml (Get_Parameter (Tree), Ntab);
+         when Iir_Kind_Pos_Attribute
+            | Iir_Kind_Val_Attribute
+            | Iir_Kind_Succ_Attribute
+            | Iir_Kind_Pred_Attribute
+            | Iir_Kind_Leftof_Attribute
+            | Iir_Kind_Rightof_Attribute =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("parameter:");
+            Disp_Xml (Get_Parameter (Tree), Ntab);
+         when Iir_Kind_Left_Array_Attribute
+           | Iir_Kind_Right_Array_Attribute
+           | Iir_Kind_High_Array_Attribute
+           | Iir_Kind_Low_Array_Attribute
+           | Iir_Kind_Range_Array_Attribute
+           | Iir_Kind_Reverse_Range_Array_Attribute
+           | Iir_Kind_Length_Array_Attribute
+           | Iir_Kind_Ascending_Array_Attribute =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("parameter:");
+            Disp_Xml (Get_Parameter (Tree), Ntab);
+         when Iir_Kind_Delayed_Attribute
+           | Iir_Kind_Stable_Attribute
+           | Iir_Kind_Quiet_Attribute
+           | Iir_Kind_Transaction_Attribute =>
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            if Kind /= Iir_Kind_Transaction_Attribute then
+               Header ("parameter:");
+               Disp_Xml (Get_Parameter (Tree), Ntab);
+            end if;
+            Header ("has_active_flag: ", False);
+            Disp_Flag (Get_Has_Active_Flag (Tree));
+         when Iir_Kind_Event_Attribute
+           | Iir_Kind_Active_Attribute
+           | Iir_Kind_Last_Event_Attribute
+           | Iir_Kind_Last_Active_Attribute
+           | Iir_Kind_Last_Value_Attribute
+           | Iir_Kind_Driving_Attribute
+           | Iir_Kind_Driving_Value_Attribute =>
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+         when Iir_Kind_Behavior_Attribute
+           | Iir_Kind_Structure_Attribute =>
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+         when Iir_Kind_Simple_Name_Attribute
+           | Iir_Kind_Instance_Name_Attribute
+           | Iir_Kind_Path_Name_Attribute =>
+            Header ("prefix:");
+            Disp_Xml_Flat (Get_Prefix (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+
+         when Iir_Kind_Enumeration_Literal =>
+            if Flat_Decl and then Get_Literal_Origin (Tree) = Null_Iir then
+               return;
+            end if;
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("value:" & Iir_Int32'Image (Get_Enum_Pos (Tree)));
+            Header ("attribute_value_chain:");
+            Disp_Xml_Flat_Chain (Get_Attribute_Value_Chain (Tree), Ntab);
+            Header ("origin:");
+            Disp_Xml (Get_Literal_Origin (Tree), Ntab, True);
+         when Iir_Kind_Integer_Literal =>
+            Header ("staticness:", false);
+            Disp_Expr_Staticness (Tree);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("origin:");
+            Disp_Xml (Get_Literal_Origin (Tree), Ntab, True);
+         when Iir_Kind_Floating_Point_Literal =>
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("origin:");
+            Disp_Xml (Get_Literal_Origin (Tree), Ntab, True);
+         when Iir_Kind_String_Literal =>
+            Header ("value: """ & Iirs_Utils.Image_String_Lit (Tree) & """");
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("origin:");
+            Disp_Xml (Get_Literal_Origin (Tree), Ntab, True);
+         when Iir_Kind_Bit_String_Literal =>
+            Header ("base: " & Base_Type'Image (Get_Bit_String_Base (Tree)));
+            Header ("value: """ & Iirs_Utils.Image_String_Lit (Tree) & """");
+            Header ("len:" & Int32'Image (Get_String_Length (Tree)));
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+         when Iir_Kind_Character_Literal =>
+            Header ("value: '" &
+                    Name_Table.Get_Character (Get_Identifier (Tree)) &
+                    ''');
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+         when Iir_Kind_Physical_Int_Literal =>
+            Header ("staticness:", False);
+            Disp_Expr_Staticness (Tree);
+            Header ("value: " & Iir_Int64'Image (Get_Value (Tree)));
+            Header ("unit_name: ");
+            Disp_Xml_Flat (Get_Unit_Name (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("origin:");
+            Disp_Xml (Get_Literal_Origin (Tree), Ntab);
+         when Iir_Kind_Physical_Fp_Literal =>
+            Header ("staticness:", False);
+            Disp_Expr_Staticness (Tree);
+            Header ("fp_value: " & Iir_Fp64'Image (Get_Fp_Value (Tree)));
+            Header ("unit_name: ");
+            Disp_Xml_Flat (Get_Unit_Name (Tree), Ntab);
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+            Header ("origin:");
+            Disp_Xml (Get_Literal_Origin (Tree), Ntab);
+         when Iir_Kind_Null_Literal =>
+            Header ("type:");
+            Disp_Xml_Flat (Get_Type (Tree), Ntab);
+         when Iir_Kind_Simple_Aggregate =>
+            Header ("simple_aggregate_list:");
+            Disp_Xml_List (Get_Simple_Aggregate_List (Tree), Ntab, True);
+            Header ("type:");
+            Disp_Xml (Get_Type (Tree), Ntab, True);
+            Header ("origin:");
+            Disp_Xml (Get_Literal_Origin (Tree), Ntab, True);
+
+         when Iir_Kind_Proxy =>
+            Header ("proxy:");
+            Disp_Xml_Flat (Get_Proxy (Tree), Ntab);
+         when Iir_Kind_Entity_Class =>
+            null;
+      end case;
+
+DISP
+
--- ghdl-r150-ori/disp_vhdl.pl	2013-07-10 13:07:23.000000000 +0200
+++ ghdl-r150/disp_vhdl.pl	2013-07-10 13:00:42.000000000 +0200
@@ -0,0 +1,732 @@
+#!/usr/bin/perl
+use File::Basename;
+use File::Path;
+use FindBin qw($Bin);
+use FindBin qw($Bin);
+use lib "$Bin/../lib";
+require "$Bin/disp_vhdl_data.pl";
+require "$Bin/disp_data.pl";
+use Data::Dumper;
+use Storable qw(dclone);
+
+$RE_comment_Cpp =                q{(?:\/\*(?:(?!\*\/)[\s\S])*\*\/|\/\/[^\n]*\n)};
+$RE_string =                     qr{"((?:\\.|[^\\"])*)"};
+$RE_string_one =                 qr{'((?:\\.|[^\\'])*)'}; #"
+$id =                            qr{(?:[a-zA-Z_][a-zA-Z_0-9]*)};
+$RE_balanced_squarebrackets =    qr'(?:[\[]((?:(?>[^\[\]]+)|(??{$RE_balanced_squarebrackets}))*)[\]])'s;
+$RE_balanced_smothbrackets =     qr'(?:[\(]((?:(?>[^\(\)]+)|(??{$RE_balanced_smothbrackets}))*)[\)])'s;
+
+$RE_b  = qr'(?:[\(]((?:(?>[^\(\)]+)|(??{$RE_b}))*)[\)])'s;
+
+$RE_if = qr'(?:(?:if)((?:(?>(?:(?!\b(?:end\s+)?if\b).)+)|(??{$RE_if}))*)(?:end\s+if))'s;
+$RE_d  = qr"(?:\b((?:Disp[a-zA-Z0-9_]*))\s*($RE_b)\s*;?)";
+
+sub filename {
+    my ($str) = @_;
+    $str =~ s/([<>])/sprintf("_%02X_",ord($1))/eg;
+    return $str;
+}
+
+sub readfile {
+    my ($in) = @_;
+    usage(\*STDOUT) if (length($in) == 0) ;
+    open IN, "$in" or die "Reading \"$in\":".$!;
+    local $/ = undef;
+    $m = <IN>;
+    close IN;
+    return $m;
+}
+
+sub writefile {
+    my ($out,$re,$temp) = @_;
+    $out = filename($out);
+    my $dir = dirname($out);
+    if ($dir) {
+        mkpath($dir);
+    }
+    open OUT, ">$out" or die ($out.$!);
+    print OUT ($re);
+    close OUT;
+}
+$d = 0;
+$ln = 1;
+sub peel     { my ($m) = @_; $m =~ s/^\s*\(//; $m =~ s/\)\s*$//; return $m; }
+sub pre      { my ($m,$pre,$c) = @_; my $l = $pre.$c; $ln += ($l =~ tr/\n//); return (substr($m,length($pre.$c)),$pre,$c); }
+sub dbg      { my $m = substr($_[0],0,64); $m =~ s/\n/\\n/g; return "(ln:$ln) ".'"'.$m.'"'; }
+sub rmspace  { my $m = $_[0]; $m =~ s/^[;\s]+//; $m =~ s/\r\n/\n/g; return $m; }
+sub delspace { my $m = $_[0]; $m =~ s/^[\s]+//; $m =~ s/[\s]+$//; return $m; }
+require "$Bin/disp_typ.pl";
+parse_typ($typ);
+
+$vhdl = readfile ("$Bin/disp_vhdl_template.adb");
+
+sub bracket {
+  my ($vhdl) = @_;
+  my $open = 1, $l = "";;
+  my $c = substr($vhdl,0,1);
+  die ("No brachet open at:".dbg($vhdl)) if ($c ne "(");
+  {
+    $l .= $c; $vhdl = substr($vhdl,1);
+    while (length($vhdl)) {
+      $c = substr($vhdl,0,1);
+      if ($c eq ")") {
+        $l .= $c; $vhdl = substr($vhdl,1);
+        if ((--$open) <= 0) {
+          last;
+        }
+      } elsif ($c eq "(") {
+        $l .= $c; $vhdl = substr($vhdl,1);
+        $open++
+      } elsif ($c eq "\"") {
+        ($vhdl =~ /^($RE_string)/s) or die("Cannot scan string \"$c\":".dbg($vhdl));
+        $l .= $&; $vhdl = substr($vhdl,length($&));
+      } elsif ((!($l=~ /$id$/)) && ($c eq "'")) {
+        ($vhdl =~ /^($RE_string_one)/s) or die("Cannot scan char \"$c\":".dbg($vhdl));
+        $l .= $&; $vhdl = substr($vhdl,length($&));
+      } else {
+        $l .= $c;
+        $vhdl = substr($vhdl,1);
+      }
+    }
+  }
+  return ($vhdl, $l);
+}
+
+sub eatline {
+    my ($vhdl,$hint) = @_;
+    my $l = "", $c = "", $last = "";
+    while (length($vhdl) && 
+           ((($c = substr($vhdl,0,1)) ne "\n") ||
+            length($l) < length($hint))) {
+        if ($c eq "\"" ) {
+            ($vhdl =~ /^($RE_string)/s) or die("Cannot scan string \"$c\":".dbg($vhdl));
+            #die("\nscan: \"$c\":".dbg($vhdl));
+            $l .= $&;
+            $vhdl = substr($vhdl,length($&));
+        } elsif ((!($l=~ /$id$/)) && ($c eq "'") ) {
+            ($vhdl =~ /^($RE_string_one)/s) or die("Cannot scan char \"$c\":".dbg($vhdl));
+            #print($vhdl);
+            #die("\nscan: \"$c\":".dbg($vhdl));
+            $l .= $&;
+            $vhdl = substr($vhdl,length($&));
+        } elsif ($c eq "(") {
+          my $_l = "";
+          ($vhdl,$_l) = bracket($vhdl);
+          $l .= $_l;
+        } else {
+            $l .= $c;
+            $vhdl = substr($vhdl,1);
+        }
+    }
+    if ($c eq "\n") {
+        $vhdl = substr($vhdl,1);
+        $l .= $c;
+    }
+    return ($vhdl,$l);
+}
+
+my @l = ();
+my $s = {'n'=>'top','l'=>[],'childs'=>[],'typ'=>'root'};
+my @state = ($s); my $ls;
+my $root = $s;
+my %procs = (); my @procs = ();
+
+while (length($vhdl)) {
+    my $state = $$s{'s'}, $n = $$s{'n'}; $ls=$$s{'childs'};
+    #print(":".dbg($vhdl)."\n");
+    if ($vhdl =~ /^\s*--/) {
+        ($vhdl,$l) = eatline($vhdl);
+        push(@{$ls},{'typ'=>'comment','o'=>$l});
+    } elsif ($vhdl =~ /^\s*\n/) {
+        ($vhdl,$l) = eatline($vhdl);
+        push(@{$ls},{'typ'=>'space','o'=>$l});
+    } elsif ($vhdl =~ /^\s*package\s+body\s+($id)/) {          ### package body ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'package_body','n'=>$1,'l'=>[],'childs'=>[],'typ'=>'package','o'=>$l});
+    } elsif ($vhdl =~ /^\s*procedure\s+$id\s*$RE_b\s*;/s) {    ### procedure ###
+        ($vhdl,$l) = eatline($vhdl,$&);
+        push(@{$ls},{'typ'=>'procedure_declare','o'=>$l});
+    } elsif ($vhdl =~ /^\s*procedure\s+($id)\s*$RE_b\s*is/s) { ### procedure ###
+        ($vhdl,$l) = eatline($vhdl,$&);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'procedure_decl','n'=>$1,'l'=>[],'childs'=>[],'typ'=>'procedure','o'=>$l});
+        $procs{$1} = $s; push(@procs, $s);
+    } elsif ($vhdl =~ /^\s*function\s+($id)\s*$RE_b\s*return\s+$id\s+is/s) { ### function ###
+        ($vhdl,$l) = eatline($vhdl,$&);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'function_decl','n'=>$1,'l'=>[],'childs'=>[],'typ'=>'function','o'=>$l});
+    } elsif ($vhdl =~ /^\s*begin\b/s) {            ### begin ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting procedure_decl|declare_decl|function_decl, got: $state\n") if 
+            !($state eq 'procedure_decl' || $state eq 'declare_decl' || $state eq 'function_decl');
+        if ($state eq 'procedure_decl') {
+            $$s{'s'} = 'procedure_body';
+            $$s{'decl'} = $$s{'childs'};
+            $$s{'childs'} = ($ls = []);
+        } elsif ($state eq 'declare_decl') {
+            $$s{'s'} = 'declare_body';
+            $$s{'decl'} = $$s{'childs'};
+            $$s{'childs'} = ($ls = []);
+        } elsif ($state eq 'function_decl') {
+            $$s{'s'} = 'function_body';
+            $$s{'decl'} = $$s{'childs'};
+            $$s{'childs'} = ($ls = []);
+        }
+        $$s{'close_decl'} = $l;
+
+    } elsif ($vhdl =~ /^\s*declare\b/s) {          ### declare ###
+        ($vhdl,$l) = eatline($vhdl,$&);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'declare_decl','n'=>$1,'l'=>[],'childs'=>[],'typ'=>'declare','o'=>$l});
+
+    } elsif ($vhdl =~ /^\s*if[^\n]+then\b/s) {     ### if then ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'if','n'=>$1,'l'=>[],'childs'=>[],'typ'=>'if','o'=>$l, 'true' => []});
+    } elsif ($vhdl =~ /^\s*if\b/s) {               ### if ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'if_clause','n'=>$1,'l'=>[],'childs'=>[],'typ'=>'if','o'=>$l});
+        
+    } elsif ($vhdl =~ /^\s*end\s+if\b/s) {         ### end if ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting if|else, got: $state at \"$l\"\n") if 
+            !($state eq 'if' || $state eq 'else');
+        if ($state eq 'if') {
+            push(@{$$s{'true'}},[ $$s{'o'}, $$s{'childs'}]);
+        } elsif ($state eq 'else') {
+            push(@{$$s{'false'}},[ $$s{'o'}, $$s{'childs'}]);
+        }
+        $$s{'childs'} = [];
+        $$s{'close'} = $l;
+        $s = pop(@state);$ls=$state[$#state]{'childs'}; 
+    } 
+    
+      elsif ($vhdl =~ /^\s*and\s+then\b/s) {       ### and then ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting if_clause, got: $state\n") if 
+            !($state eq 'if_clause');
+        $$s{'o'} .= $l;
+
+    } elsif ($vhdl =~ /^\s*then\b/s) {             ### then ###
+        ($vhdl,$l) = eatline($vhdl);
+        
+        die("If stack out of sync, expecting if_clause, got: $state\n") if 
+            !($state eq 'if_clause');
+        $$s{'s'} = 'if'; 
+        $$s{'o'} .= $l;
+
+    } elsif ($vhdl =~ /^\s*or\s+else\b/s) {        ### or else ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting if_clause, got: $state\n") if 
+            !($state eq 'if_clause');
+        if ($l =~ /\bthen\s*$/) {
+            $$s{'s'} = 'if'; 
+        }
+        $$s{'o'} .= $l;
+        
+    } elsif ($vhdl =~ /^\s*else\b/s) {             ### else ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting if, got: $state at \"$l\"\n") if 
+            !($state eq 'if');
+        $$s{'s'} = 'else'; 
+        push(@{$$s{'true'}},[ $$s{'o'}, $$s{'childs'}]);
+        $$s{'o'} = $l;
+        $$s{'childs'} = ($ls = []);
+   } 
+    
+      elsif ($vhdl =~ /^\s*end\s+loop\b/s) {       ### end loop ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting case, got: $state\n") if 
+            !($state eq 'loop');
+        $$s{'close'} = $l;
+        $s = pop(@state); $ls=$state[$#state]{'childs'}; 
+        
+    } elsif ($vhdl =~ /^\s*end\s+case\b/s) {       ### end case ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting case, got: $state\n") if 
+            !($state eq 'case' || $state eq 'when');
+        $s = pop(@state) if ($state eq 'when');
+        $ls=$$s{'childs'}; 
+        $state = $$s{'s'};
+        #print(Dumper($ls));
+        die("If stack out of sync, expecting case, got: $state\n") if 
+            !($state eq 'case');
+        $$s{'close'} = $l;
+        $s = pop(@state); $ls=$$s{'childs'};
+    } elsif ($vhdl =~ /^\s*end\s+($id)\s*;/s) {    ### end id ###
+        ($vhdl,$l) = eatline($vhdl);
+        if (($n = $$s{'n'}) ne $1) {
+            die("State stack out of sync. Expect $n($state) got :$l\n");
+        }
+        $$s{'close'} = $l;
+        $s = pop(@state); $ls=$$s{'childs'};
+        
+    } elsif ($vhdl =~ /^\s*end\s*;/s) {            ### end ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting declare_body, got: $state\n") if 
+            !($state eq 'declare_body');
+        $$s{'close'} = $l;
+        $s = pop(@state); $ls=$$s{'childs'};
+        
+        
+    } 
+      elsif ($vhdl =~ /^\s*for\b/s) {              ### for ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'loop','l'=>[],'childs'=>[],'typ'=>'for','o'=>$l});
+    } elsif ($vhdl =~ /^\s*loop\b/s) {             ### loop ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'loop','l'=>[],'childs'=>[],'typ'=>'loop','o'=>$l});
+    } elsif ($vhdl =~ /^\s*while\b/s) {            ### while ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'loop','l'=>[],'childs'=>[],'typ'=>'while','o'=>$l});
+    } 
+
+      elsif ($vhdl =~ /^\s*exit\s+when\b/s) {      ### exit when ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@{$ls},{'typ'=>'exit','o'=>$l});
+    } elsif ($vhdl =~ /^\s*elsif\b/s) {            ### elsif ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting if, got: $state at \"$l\"\n") if 
+            !($state eq 'if');
+        push(@{$$s{'true'}},[ $$s{'o'}, $$s{'childs'}]);
+        $$s{'o'} = $l;
+        $$s{'childs'} = ($ls = []);
+
+    } elsif ($vhdl =~ /^\s*return\b/s) {           ### return ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@{$ls},{'typ'=>'return','o'=>$l});
+    } elsif ($vhdl =~ /^\s*use\s+(?:$id|\.)+\s*;/s) { ### use ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@{$ls},{'typ'=>'use','o'=>$l});
+    } elsif ($vhdl =~ /^\s*with\s+(?:$id|\.)+\s*;/s) { ### with ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@{$ls},{'typ'=>'with','o'=>$l});
+    } 
+      elsif ($vhdl =~ /^\s*case\s+$id(?:\s*$RE_b)?\s+is/s) { ### case ###
+        ($vhdl,$l) = eatline($vhdl);
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'case','l'=>[],'childs'=>[],'typ'=>'case','o'=>$l});
+    } elsif ($vhdl =~ /^\s*when\s+($id)\s+/s) {              ### when ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting case,when, got: $state at \"$l\"\n") if
+            !($state eq 'case' | $state eq 'when');
+        $s = pop (@state) if ($state eq 'when');
+        die("If stack out of sync, expecting case, got: $state at \"$l\"\n") if
+            !($$s{'s'} eq 'case' );
+        push(@state,$s); $ls=$$s{'childs'}; push(@{$ls},$s={'s'=>'when_case','c'=>[$1],'l'=>[],'childs'=>[],'typ'=>'when','o'=>$l});
+        if ($l =~ /=>/) {
+            $$s{'s'} = 'when';
+        }
+    } elsif ($vhdl =~ /^\s*\|\s+($id)/s) {                   ### when continue ###
+        ($vhdl,$l) = eatline($vhdl);
+        die("If stack out of sync, expecting when_case, got: $state at \"$l\"\n") if
+            !($state eq 'when_case');
+        push(@{$$s{'c'}},$1);
+        if ($l =~ /=>/) {
+            $$s{'s'} = 'when'; 
+        }
+        $$s{'o'} .= $l;
+
+    } else {
+        ($vhdl,$l) = eatline($vhdl);
+
+        if ($state eq 'if_clause') {
+            $$s{'o'} .= $l;
+        } else {
+            #print(":".$l);
+            push(@{$ls},{'s'=>'line','o'=>$l,'typ'=>'line'});
+        }
+    }
+    push(@l,$l);
+}
+
+sub toproc_ar {
+    my ($a,$ctx) = @_;
+    foreach my $l (@$a) {
+      toproc($l,$ctx);
+    }
+    return $f;
+}
+
+sub extract_attr {
+  my ($o) = @_;
+  my %attr = (); 
+  if ($o =~ /\-\-\s*([^\n]+)$/m ) {
+    my $attr = $1;
+    #print(":\"$attr\":"."\n");
+    foreach my $a (split(",",$attr)) {
+      if ($a =~ /($id)\s*:\s*(.*)/) {
+        my ($n,$v) = ($1,$2);
+        $attr{rmspace($n)} = rmspace($v);
+      }
+    }
+  }
+  return \%attr;
+}
+
+sub spof { my ($m) = @_; $m =~ /^(\s*)/; return $1;}
+
+sub mergectx {
+  my ($a,$b) = @_;
+  my $h = dclone($a);
+  foreach my $k (keys %$b) { $$h{$k} = $$b{$k};}
+  return $h;
+}
+
+sub splitb {
+  my ($_a) = @_;
+  my %a = ();
+  if ($_a =~ /$RE_balanced_squarebrackets/) {
+    my $b = $1;
+    foreach my $a (split("\\|",$b)) {
+      if ($a =~ /($id)\s*=\s*(.*)/) {
+        my ($n,$v) = ($1,$2);
+        $v =~ s/[\r\n]//g;
+        $a{$n} = delspace($v);
+      }
+    }
+  }
+  return \%a;
+}
+
+sub addFlags {
+  my ($a, $sp, $ctx) = @_;
+  my $r = "";
+  if (defined($$a{'flags'})) {
+    if ($$a{'flags'} =~ /$RE_balanced_squarebrackets/) {
+      my $b = $1;
+      foreach my $a (split("\\|",$b)) {
+        if ($a =~ /($id)\s*=\s*(.*)/) {
+          my ($n,$v) = ($1,$2);
+          $r .= "${sp}AddAttr(".$$ctx{'e'}.",+\"$n\",+\"$v\");\n";
+        }
+      }
+    }
+  }
+  return $r;
+}
+
+%mapn = ('Disp_Name_Of' => 'Str_Name_Of',
+         'Disp_Name' => 'Str_Name',
+         'Disp_Ident' => 'Str_Ident',
+         'Disp_Identifier' => 'Str_Identifier',
+         'Disp_Label' => 'Str_Label',
+         'Disp_Signal_Kind' => 'Str_Signal_Kind',
+         'Disp_Mode' => 'Str_Mode',
+         'Disp_String_Literal' => 'Str_String_Literal',
+         'Disp_Function_Name' => 'Str_Function_Name',
+         'Disp_Int64' => 'Str_Int64',
+         'Disp_Fp64' => 'Str_Fp64',
+         'Disp_Entity_Kind' => 'Str_Entity_Kind' );
+
+sub toproc_line {
+  my ($id,$b,$_d,$o,$ctx,$typ) = @_;
+  my $e = $$ctx{'e'}, $m = "";
+  my $a = extract_attr($o);
+  if (defined($$a{'reent'})) {
+    $_d = "P,$e,";
+  }
+  if ($typ eq 'line' && 
+      defined($mapn{delspace($id)}) &&
+      defined($$a{'f'})) {
+    my $f = $$a{'f'};
+    $id = $mapn{delspace($id)};
+    $_d = "";
+    return "AddAttr($e,+\"$f\",$id($b))";
+  } else {
+    return "$id($_d$b)";
+  }
+}
+
+sub toproc_sub {
+  my ($o,$typ,$ctx) = @_; my $old = $o;
+  my $sp = spof($o);  my $e = $$ctx{'e'}, $ec = "ec";
+  my $a = extract_attr($o);
+  my $n = defined($$a{'p'}) ? $$a{'p'} : "-";
+  my $_d = ($typ eq 'procedure_declare') ?  "P,N:X;" : "$e,NewN($e,+\"$n\"),";
+  $o =~ s/((?:Disp[a-zA-Z0-9_]*)\s*)$RE_b/toproc_line($1,$2,$_d,$o,$ctx,$typ)/egs;
+  my $pre = "";
+
+  if ($typ eq 'line') {
+    if (defined($$a{'open'}) || defined($$a{'reopen'})) {
+      my $n = splitb(defined($$a{'open'}) ? $$a{'open'} : $$a{'reopen'});
+      my ($ec,$n) = ($$n{'v'},$$n{'n'});
+      $e = $$ctx{'_e'}[0] if defined($$a{'reopen'});
+      $pre = "${sp}$ec := NewN($e,+\"-\");\n${sp}SetTag($ec.all,+\"$n\");\n";
+      if (defined($$a{'open'})) {
+        push(@{$$ctx{'_e'}}, $$ctx{'e'});
+        $$ctx{'e'} = $e = $ec;
+      }
+    } elsif (defined($$a{'reopen'})) {
+      $$ctx{'e'} = shift(@{$$ctx{'_e'}});
+    } elsif (defined($$a{'close'})) {
+      my $v = $$ctx{'e'};
+      $e = $$ctx{'e'} = shift(@{$$ctx{'_e'}});
+    } 
+    
+    my $f = $$a{'f'}; $f =~ s/\r//g;
+    if ($o =~ /^(\s*)(?:Put|Put_Line)\s*\(/  ) {
+      my $b = substr($o,length($&)-1), $l, $sp = $1;
+      ($b,$l) = bracket($b);
+      if (defined($$a{'f'})) {
+        $l =~ s/' '\s*\&//;
+        $l =~ s/\&\s*' '//;
+        $l =~ s/\s+"\)$/")/; # remove last whitespace in Put(_Line)
+        $o = "${sp}AddAttr($e,+\"$f\",+$l);\n";
+      } elsif (defined($$a{'nop'}) ||
+               $l =~ /^\(\s*$RE_string\s*\)/ ||
+               $l =~ /^\(\s*$RE_string_one\s*\)/)  {
+        $o = "${sp}null;--$o";
+      }
+    } elsif ($o =~ /^(\s*)(?:New_Line)\s*/  ) {
+      $o = "${sp}null;--$o";
+    } elsif ($o =~ /^(\s*)(?:Set_Col)\s*/  ) {
+      $o = "${sp}null;--$o";
+    } elsif (defined($$a{'s'})) { 
+      my $n = splitb( $$a{'s'} );
+      my @k = keys(%$n);
+      my ($ec,$n) = ($k[0], $$n{$k[0]});
+      $o = "${sp}AddAttr($e,+\"$ec\",+\"$n\");\n$o\n";
+    }
+    $o = $pre.$o;
+  } elsif ($typ eq 'exit') {
+    my $epre = $$ctx{'_e'}[0];
+    if (defined($$a{'exitchain'})) {
+      my $n = $$a{'exitchain'};
+      if ($o =~ /^\s*exit\s+when\s+(.*);/) {
+        $o = "${sp}if $1 then\n${sp}   RemFrom(${epre},$e);\n${sp}end if;\n$o";
+      }
+    }
+  }
+  return $o;
+}
+
+sub toproc {
+    my ($d,$ctx) = @_;
+    my $typ = $$d{'typ'};
+    my $f = "";
+    if ($typ eq 'root') {
+        $f .= toproc_ar($$d{'childs'},$ctx);
+    } elsif ($typ eq 'comment') {
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+    } elsif ($typ eq 'space') {
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+    } elsif ($typ eq 'package') {
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+        $f .= toproc_ar($$d{'childs'},$ctx);
+       $$d{'close'} = toproc_sub($$d{'close'},$typ,$ctx);
+    } elsif ($typ eq 'procedure' || $typ eq 'function') {
+       $_ctx = mergectx($ctx, {'p',$d});
+       $$d{'o'} = ($$d{'o'});
+       toproc_ar($$d{'decl'},$_ctx);
+       $$d{'close_decl'} = toproc_sub($$d{'close_decl'},$typ,$ctx);
+       toproc_ar($$d{'childs'},$_ctx);
+       $$d{'close'} = toproc_sub($$d{'close'},$typ,$ctx);
+    } elsif ($typ eq 'declare') {
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+       toproc_ar($$d{'decl'},$ctx);
+       $$d{'close_decl'} = toproc_sub($$d{'close_decl'},$typ,$ctx);
+       toproc_ar($$d{'childs'},$ctx);
+       $$d{'close'} = toproc_sub($$d{'close'},$typ,$ctx);
+    } elsif ($typ eq 'if') {
+        foreach my $c (@{$$d{'true'}}) {
+            my ($o,$l) = @$c;
+            $$c[0] = toproc_sub($o,$typ,$ctx);
+            toproc_ar($l,$ctx);
+        }
+        foreach my $c (@{$$d{'false'}}) {
+            my ($o,$l) = @$c;
+            $$c[0] = toproc_sub($o,$typ,$ctx);
+            toproc_ar($l,$ctx);
+        }
+       $$d{'close'} = toproc_sub($$d{'close'},$typ,$ctx);
+        
+    } elsif ($typ eq 'case') {
+       my $a = extract_attr($$d{'o'});
+       if (defined($$a{'rename'})) {
+         my ($v,$sp) = ($$a{'rename'},spof($$d{'o'}));
+         $$d{'o'} = "${sp}ChangeTag(".$$ctx{'e'}.",$v);\n".addFlags($a,$sp,$ctx).$$d{'o'};
+       }
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+       toproc_ar($$d{'childs'},$ctx);
+       $$d{'close'} = toproc_sub($$d{'close'},$typ,$ctx);
+        
+    } elsif ($typ eq 'when') {
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+       toproc_ar($$d{'childs'},$ctx);
+        
+    } elsif ($typ eq 'procedure_declare') {
+      my $a = extract_attr($$d{'o'});
+      $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+    } elsif ($typ eq 'for' || $typ eq 'loop' || $typ eq 'while') {
+       my $_ctx = $ctx, $o = "";
+       my $a = extract_attr($$d{'o'});
+       if (defined($$a{'chain'})) {
+         my $sp = spof($$d{'o'}); $ctx = dclone($ctx); my $e = $$ctx{'e'};
+         my $n = splitb( $$a{'chain'} );
+         my ($ec,$n) = ($$n{'v'},$$n{'n'});
+         $o = "${sp}   $ec := NewN($e,+\"-\");\n${sp}   SetTag($ec.all,+\"$n\");\n";
+         push(@{$$ctx{'_e'}}, $$ctx{'e'});
+         $$ctx{'e'} = $ec;
+       }
+      
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx). $o;
+        $f .= toproc_ar($$d{'childs'},$ctx);
+       $$d{'close'} = toproc_sub($$d{'close'},$typ,$ctx);
+       $ctx = $_ctx;
+    } elsif ($typ eq 'return' || $typ eq 'exit' || $typ eq 'use' || $typ eq 'with') {
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+    } elsif ($typ eq 'line') {
+       $$d{'o'} = toproc_sub($$d{'o'},$typ,$ctx);
+    } else {
+        die("Cannot dump \"$typ\"\n");
+    }
+    return $f;
+}
+
+
+$process = 1;
+$process_add = 1;
+if ($process) {
+  my $ctx = {'e'=>'N'};
+  toproc($root,$ctx);
+  
+  if ($process_add) {
+    for my $s (@procs) {
+      my $o = $$s{'o'};
+      if ($o =~ /^(\s*)(procedure\s+)($id\s*)$RE_b(.*)$/s) {
+        my ($sp,$pre,$i,$b,$post) = ($1,$2,$3,$4,$5);
+        if ($i =~ /^Disp/) {
+          $$s{'o'} = $sp.$pre.$i."(P,N:X;".$b.")".$post;
+          $i =~ /Disp_($id)/;
+          my $in = $1, $iid = "";;
+          my @b = split("\\s*;\\s*",$b);
+          if ($b[0] =~ /([^:]+)\s*:\s*Iir\b/is) {
+            my $_in = delspace($1);
+            my @ids = split("\\s*,\\s*",$_in);
+            $iid = "$sp   SetId(N,".$ids[0].");\n";
+          }
+          
+
+          # unshift(@{$$s{'decl'}},{'typ'=>'line','o'=>"$sp   N: constant X := X(Create_Xml_Node_Pretty(P,+\"$1\"));\n"});
+          
+          
+          unshift(@{$$s{'childs'}},{'typ'=>'line','o'=>"$iid$sp   SetTag(N.all,+\"".lc($in)."\");\n"});
+          if ('Expression' ne $in && 'Range' ne $in && 
+              'Element_Constraint' ne $in &&
+              'Array_Element_Constraint' ne $in &&
+              'Concurrent_Statement' ne $in) {
+            unshift(@{$$s{'decl'}},{'typ'=>'line','o'=>"$sp   pragma Unreferenced (P);\n"});
+          }
+        }
+      }
+    }
+  }
+}
+
+sub todump_ar {
+    my ($a) = @_;
+    my $f = "";
+    foreach my $l (@$a) {
+        $f .= todump($l);
+    }
+    return $f;
+}
+
+sub todump {
+    my ($d) = @_;
+    my $typ = $$d{'typ'};
+    my $f = "";
+    if ($typ eq 'root') {
+        $f .= todump_ar($$d{'childs'});
+    } elsif ($typ eq 'comment') {
+        $f .= $$d{'o'};
+    } elsif ($typ eq 'space') {
+        $f .= $$d{'o'};
+    } elsif ($typ eq 'package') {
+        $f .= $$d{'o'};
+        $f .= todump_ar($$d{'childs'});
+        $f .= $$d{'close'};
+    } elsif ($typ eq 'procedure' || $typ eq 'function') {
+        $f .= $$d{'o'};
+        $f .= todump_ar($$d{'decl'});
+        $f .= $$d{'close_decl'};
+        $f .= todump_ar($$d{'childs'});
+        $f .= $$d{'close'};
+    } elsif ($typ eq 'declare') {
+        $f .= $$d{'o'};
+        $f .= todump_ar($$d{'decl'});
+        $f .= $$d{'close_decl'};
+        $f .= todump_ar($$d{'childs'});
+        $f .= $$d{'close'};
+    } elsif ($typ eq 'if') {
+        foreach my $c (@{$$d{'true'}}) {
+            my ($o,$l) = @$c;
+            $f .= $o;
+            $f .= todump_ar($l);
+        }
+        foreach my $c (@{$$d{'false'}}) {
+            my ($o,$l) = @$c;
+            $f .= $o;
+            $f .= todump_ar($l);
+        }
+        $f .= $$d{'close'};
+        
+    } elsif ($typ eq 'case') {
+        $f .= $$d{'o'};
+        $f .= todump_ar($$d{'childs'});
+        $f .= $$d{'close'};
+        
+    } elsif ($typ eq 'when') {
+        $f .= $$d{'o'};
+        $f .= todump_ar($$d{'childs'});
+        
+    } elsif ($typ eq 'procedure_declare') {
+        $f .= $$d{'o'};
+    } elsif ($typ eq 'for' || $typ eq 'loop' || $typ eq 'while') {
+        $f .= $$d{'o'};
+        $f .= todump_ar($$d{'childs'});
+        $f .= $$d{'close'};
+    } elsif ($typ eq 'return' || $typ eq 'exit' || $typ eq 'use' || $typ eq 'with') {
+        $f .= $$d{'o'};        
+    } elsif ($typ eq 'line') {
+        $f .= $$d{'o'};        
+    } else {
+        die("Cannot dump \"$typ\"\n");
+    }
+    return $f;
+}
+
+sub slit_len {
+  my ($m) = @_; my $post = "";
+  if (length($m) >= 78) {
+    while (length($m) >= 78) {
+      last if !($m =~ /([;])([^;]+)$/s || $m =~ /([,])([^,]+)$/s);
+      $post = $1.$2.$post;
+      $m = $`;
+    }
+    $m =~ s/[\s]+$//;
+    if ($m =~ /^[\s]+/) {
+      $post = $1.$post;
+    }
+    $m = $m."\n".$post;
+  }
+  return $m;
+}
+
+my $m = todump($root);
+
+@_f = ();
+@f = split("\n",$m);
+foreach my $f (@f) {
+    my $fl = slit_len($f);
+    push(@_f,$fl);
+}
+$m = join("\n",@_f);
+
+$m =~ s/\@typ\@/$typcase/;
+$m =~ s/\r\n/\n/g;
+$m =~ s/\r//g;
+
+writefile("disp_xml_vhdl.adb",$m);
+
+
+# Local Variables:
+# c-basic-offset:4
+# indent-tabs-mode:nil
+# End:
--- ghdl-r150-ori/disp_vhdl_data.pl	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-r150/disp_vhdl_data.pl	2013-06-10 13:40:54.000000000 +0200
@@ -0,0 +1,2501 @@
+
+$vhdl= <<'VHDLEND';
+
+--  VHDL regeneration from internal nodes.
+--  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GHDL; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+
+
+-- Disp an iir tree.
+-- Try to be as pretty as possible, and to keep line numbers and positions
+-- of the identifiers.
+with Ada.Text_IO; use Ada.Text_IO;
+with Std_Package;
+with Flags; use Flags;
+with Errorout; use Errorout;
+with Iirs_Utils; use Iirs_Utils;
+with Name_Table;
+with Std_Names;
+with Tokens;
+with PSL.Nodes;
+with PSL.Prints;
+with PSL.NFAs;
+
+package body Disp_Vhdl is
+
+   --  Disp the name of DECL.
+   procedure Disp_Name_Of (Decl: Iir);
+
+   Indentation: constant Count := 2;
+
+   -- If set, disp after a string literal the type enclosed into brackets.
+   Disp_String_Literal_Type: constant Boolean := False;
+
+   -- If set, disp position number of associations
+   --Disp_Position_Number: constant Boolean := False;
+
+--    procedure Disp_Tab (Tab: Natural) is
+--       Blanks : String (1 .. Tab) := (others => ' ');
+--    begin
+--       Put (Blanks);
+--    end Disp_Tab;
+
+   procedure Disp_Type (A_Type: Iir);
+
+   procedure Disp_Expression (Expr: Iir);
+   procedure Disp_Concurrent_Statement (Stmt: Iir);
+   procedure Disp_Concurrent_Statement_Chain (Parent: Iir; Indent : Count);
+   procedure Disp_Declaration_Chain (Parent : Iir; Indent: Count);
+   procedure Disp_Process_Statement (Process: Iir);
+   procedure Disp_Sequential_Statements (First : Iir);
+   procedure Disp_Choice (Choice: in out Iir);
+   procedure Disp_Association_Chain (Chain : Iir);
+   procedure Disp_Block_Configuration
+     (Block: Iir_Block_Configuration; Indent: Count);
+   procedure Disp_Subprogram_Declaration (Subprg: Iir);
+   procedure Disp_Binding_Indication (Bind : Iir; Indent : Count);
+   procedure Disp_Subtype_Indication (Def : Iir; Full_Decl : Boolean := False);
+
+   procedure Disp_Ident (Id: Name_Id) is
+   begin
+      Put (Name_Table.Image (Id));
+   end Disp_Ident;
+
+   procedure Disp_Identifier (Node : Iir) is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Identifier (Node);
+      if Ident /= Null_Identifier then
+         Disp_Ident (Ident);
+      else
+         Put ("<anonymous>");
+      end if;
+   end Disp_Identifier;
+
+   procedure Disp_Label (Node : Iir) is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Label (Node);
+      if Ident /= Null_Identifier then
+         Disp_Ident (Ident);
+      else
+         Put ("<anonymous>");
+      end if;
+   end Disp_Label;
+
+   procedure Disp_Character_Literal (Lit: Iir_Character_Literal) is
+   begin
+      Put (''' & Name_Table.Get_Character (Get_Identifier (Lit)) & ''');
+   end Disp_Character_Literal;
+
+   procedure Disp_Function_Name (Func: Iir)
+   is
+      use Name_Table;
+      use Std_Names;
+      Id: Name_Id;
+   begin
+      Id := Get_Identifier (Func);
+      case Id is
+         when Name_Id_Operators
+           | Name_Word_Operators
+           | Name_Xnor
+           | Name_Shift_Operators =>
+            Put ("""");
+            Put (Image (Id));
+            Put ("""");
+         when others =>
+            Disp_Ident (Id);
+      end case;
+   end Disp_Function_Name;
+
+   --  Disp the name of DECL.
+   procedure Disp_Name_Of (Decl: Iir) is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Component_Declaration
+           | Iir_Kind_Entity_Declaration
+           | Iir_Kind_Architecture_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Configuration_Declaration
+           | Iir_Kind_Type_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_Subtype_Declaration
+           | Iir_Kind_Element_Declaration
+           | Iir_Kind_Record_Element_Constraint
+           | Iir_Kind_Package_Declaration
+           | Iir_Kind_Object_Alias_Declaration
+           | Iir_Kind_Non_Object_Alias_Declaration
+           | Iir_Kind_Iterator_Declaration
+           | Iir_Kind_Library_Declaration
+           | Iir_Kind_Unit_Declaration =>
+            Disp_Identifier (Decl);
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            Put ('<');
+            Disp_Ident (Get_Identifier (Decl));
+            Put ('>');
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            Disp_Function_Name (Decl);
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            Disp_Identifier (Decl);
+         when Iir_Kind_Physical_Subtype_Definition
+           | Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Identifier (Get_Type_Declarator (Decl));
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Ident (Get_Label (Decl));
+         when Iir_Kind_Design_Unit =>
+            Disp_Name_Of (Get_Library_Unit (Decl));
+         when Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Simple_Name =>
+            Disp_Identifier (Decl);
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement =>
+            Disp_Label (Decl);
+         when others =>
+            Error_Kind ("disp_name_of", Decl);
+      end case;
+   end Disp_Name_Of;
+
+   procedure Disp_Range (Decl: Iir) is
+   begin
+      if Get_Kind (Decl) = Iir_Kind_Range_Expression then
+         Disp_Expression (Get_Left_Limit (Decl));
+         if Get_Direction (Decl) = Iir_To then
+            Put (" to ");
+         else
+            Put (" downto ");
+         end if;
+         Disp_Expression (Get_Right_Limit (Decl));
+      else
+         Disp_Subtype_Indication (Decl);
+         --  Disp_Name_Of (Get_Type_Declarator (Decl));
+      end if;
+   end Disp_Range;
+
+   procedure Disp_Name (Name: Iir) is
+   begin
+      case Get_Kind (Name) is
+         when Iir_Kind_Selected_By_All_Name =>
+            Disp_Name (Get_Prefix (Name));
+            Put (".all");
+         when Iir_Kind_Dereference =>
+            Disp_Name (Get_Prefix (Name));
+            Put (".all");
+         when Iir_Kind_Simple_Name =>
+            Put (Iirs_Utils.Image_Identifier (Name));
+         when Iir_Kind_Selected_Name =>
+            Disp_Name (Get_Prefix (Name));
+            Put (".");
+            Disp_Ident (Get_Suffix_Identifier (Name));
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Implicit_Function_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Function_Declaration
+           | Iir_Kind_Procedure_Declaration =>
+            Disp_Name_Of (Name);
+         when others =>
+            Error_Kind ("disp_name", Name);
+      end case;
+   end Disp_Name;
+
+   procedure Disp_Use_Clause (Clause: Iir_Use_Clause) is
+   begin
+      Put ("use ");
+      Disp_Name (Get_Selected_Name (Clause));
+      Put_Line (";");
+   end Disp_Use_Clause;
+
+   -- Disp the resolution function (if any) of type definition DEF.
+   procedure Disp_Resolution_Function (Subtype_Def: Iir)
+   is
+      procedure Inner (Def : Iir)
+      is
+         Decl: Iir;
+      begin
+         if Get_Kind (Def) in Iir_Kinds_Subtype_Definition then
+            Decl := Get_Resolution_Function (Def);
+            if Decl /= Null_Iir then
+               Disp_Name (Decl);
+            else
+               case Get_Kind (Def) is
+                  when Iir_Kind_Array_Subtype_Definition =>
+                     Put ('(');
+                     Inner (Get_Element_Subtype (Def));
+                     Put (')');
+                  when others =>
+                     Error_Kind ("disp_resolution_function", Def);
+               end case;
+            end if;
+         end if;
+      end Inner;
+
+   begin
+      if Get_Resolved_Flag (Subtype_Def) then
+         Inner (Subtype_Def);
+         Put (' ');
+      end if;
+   end Disp_Resolution_Function;
+
+   procedure Disp_Integer_Subtype_Definition
+     (Def: Iir_Integer_Subtype_Definition)
+   is
+      Base_Type: Iir_Integer_Type_Definition;
+      Decl: Iir;
+   begin
+      if Def /= Std_Package.Universal_Integer_Subtype_Definition then
+         Base_Type := Get_Base_Type (Def);
+         Decl := Get_Type_Declarator (Base_Type);
+         if Base_Type /= Std_Package.Universal_Integer_Subtype_Definition
+           and then Def /= Decl
+         then
+            Disp_Name_Of (Decl);
+            Put (" ");
+         end if;
+      end if;
+      Disp_Resolution_Function (Def);
+      Put ("range ");
+      Disp_Expression (Get_Range_Constraint (Def));
+      Put (";");
+   end Disp_Integer_Subtype_Definition;
+
+   procedure Disp_Floating_Subtype_Definition
+     (Def: Iir_Floating_Subtype_Definition)
+   is
+      Base_Type: Iir_Floating_Type_Definition;
+      Decl: Iir;
+   begin
+      if Def /= Std_Package.Universal_Real_Subtype_Definition then
+         Base_Type := Get_Base_Type (Def);
+         Decl := Get_Type_Declarator (Base_Type);
+         if Base_Type /= Std_Package.Universal_Real_Subtype_Definition
+           and then Def /= Decl
+         then
+            Disp_Name_Of (Decl);
+            Put (" ");
+         end if;
+      end if;
+      Disp_Resolution_Function (Def);
+      Put ("range ");
+      Disp_Expression (Get_Range_Constraint (Def));
+      Put (";");
+   end Disp_Floating_Subtype_Definition;
+
+   procedure Disp_Element_Constraint (Def : Iir; Type_Mark : Iir);
+
+   procedure Disp_Array_Element_Constraint (Def : Iir; Type_Mark : Iir)
+   is
+      Index : Iir;
+      Def_El : Iir;
+      Tm_El : Iir;
+      Has_Index : Boolean;
+      Has_Own_Element_Subtype : Boolean;
+   begin
+      Has_Index := Get_Index_Constraint_Flag (Def);
+      Def_El := Get_Element_Subtype (Def);
+      Tm_El := Get_Element_Subtype (Type_Mark);
+      Has_Own_Element_Subtype := Def_El /= Tm_El;
+
+      if not Has_Index and not Has_Own_Element_Subtype then
+         return;
+      end if;
+
+      Put (" (");
+      if Has_Index then
+         for I in Natural loop
+            Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+            exit when Index = Null_Iir;
+            if I /= 0 then
+               Put (", ");
+            end if;
+            --Disp_Expression (Get_Range_Constraint (Index));
+            Disp_Range (Index);
+         end loop;
+      else
+         Put ("open");
+      end if;
+      Put (")");
+
+      if Has_Own_Element_Subtype
+        and then Get_Kind (Def_El) in Iir_Kinds_Composite_Type_Definition
+      then
+         Disp_Element_Constraint (Def_El, Tm_El);
+      end if;
+   end Disp_Array_Element_Constraint;
+
+   procedure Disp_Record_Element_Constraint (Def : Iir)
+   is
+      El_List : constant Iir_List := Get_Elements_Declaration_List (Def);
+      El : Iir;
+      Has_El : Boolean := False;
+   begin
+      for I in Natural loop
+         El := Get_Nth_Element (El_List, I);
+         exit when El = Null_Iir;
+         if Get_Kind (El) = Iir_Kind_Record_Element_Constraint
+           and then Get_Parent (El) = Def
+         then
+            if Has_El then
+               Put (", ");
+            else
+               Put ("(");
+               Has_El := True;
+            end if;
+            Disp_Name_Of (El);
+            Disp_Element_Constraint (Get_Type (El),
+                                     Get_Base_Type (Get_Type (El)));
+         end if;
+      end loop;
+      if Has_El then
+         Put (")");
+      end if;
+   end Disp_Record_Element_Constraint;
+
+   procedure Disp_Element_Constraint (Def : Iir; Type_Mark : Iir) is
+   begin
+      case Get_Kind (Def) is
+         when Iir_Kind_Record_Subtype_Definition =>
+            Disp_Record_Element_Constraint (Def);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Element_Constraint (Def, Type_Mark);
+         when others =>
+            Error_Kind ("disp_element_constraint", Def);
+      end case;
+   end Disp_Element_Constraint;
+
+   procedure Disp_Subtype_Indication (Def : Iir; Full_Decl : Boolean := False)
+   is
+      Type_Mark : Iir;
+      Base_Type : Iir;
+      Decl : Iir;
+   begin
+      Decl := Get_Type_Declarator (Def);
+      if not Full_Decl and then Decl /= Null_Iir then
+         Disp_Name_Of (Decl);
+         return;
+      end if;
+
+      -- Resolution function name.
+      Disp_Resolution_Function (Def);
+
+      -- type mark.
+      Type_Mark := Get_Type_Mark (Def);
+      if Type_Mark /= Null_Iir then
+         Decl := Get_Type_Declarator (Type_Mark);
+         Disp_Name_Of (Decl);
+      end if;
+
+      Base_Type := Get_Base_Type (Def);
+      case Get_Kind (Base_Type) is
+         when Iir_Kind_Integer_Type_Definition
+           | Iir_Kind_Enumeration_Type_Definition
+           | Iir_Kind_Floating_Type_Definition
+           | Iir_Kind_Physical_Type_Definition =>
+            if Type_Mark = Null_Iir
+              or else Get_Range_Constraint (Def)
+              /= Get_Range_Constraint (Type_Mark)
+            then
+               if Type_Mark /= Null_Iir then
+                  Put (" range ");
+               end if;
+               Disp_Expression (Get_Range_Constraint (Def));
+            end if;
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Element_Constraint (Def, Type_Mark);
+         when Iir_Kind_Record_Type_Definition =>
+            Disp_Record_Element_Constraint (Def);
+         when others =>
+            Error_Kind ("disp_subtype_indication", Base_Type);
+      end case;
+   end Disp_Subtype_Indication;
+
+   procedure Disp_Enumeration_Type_Definition
+     (Def: Iir_Enumeration_Type_Definition)
+   is
+      Len : Count;
+      Start_Col: Count;
+      Decl: Name_Id;
+      A_Lit: Iir; --Enumeration_Literal_Acc;
+      pragma Unreferenced (Start_Col);
+   begin
+      for I in Natural loop
+         A_Lit := Get_Nth_Element (Get_Enumeration_Literal_List (Def), I);
+         exit when A_Lit = Null_Iir;
+         if I = Natural'first then
+            Put ("(");
+            Start_Col := Col;
+         else
+            Put (", ");
+         end if;
+         Decl := Get_Identifier (A_Lit);
+         if Name_Table.Is_Character (Decl) then
+            Len := 3;
+         else
+            Len := Count (Name_Table.Get_Name_Length (Decl));
+         end if;
+         if Col + Len + 2 > Line_Length then
+            New_Line;
+            Set_Col (Start_Col);
+         end if;
+         Disp_Name_Of (A_Lit);
+      end loop;
+      Put (");");
+   end Disp_Enumeration_Type_Definition;
+
+   procedure Disp_Enumeration_Subtype_Definition
+     (Def: Iir_Enumeration_Subtype_Definition)
+   is
+   begin
+      Disp_Resolution_Function (Def);
+      Put ("range ");
+      Disp_Range (Def);
+      Put (";");
+   end Disp_Enumeration_Subtype_Definition;
+
+   procedure Disp_Array_Subtype_Definition
+     (Def: Iir_Array_Subtype_Definition)
+   is
+      Index: Iir;
+   begin
+      Disp_Resolution_Function (Def);
+
+      Put ("array (");
+      for I in Natural loop
+         Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+         exit when Index = Null_Iir;
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Subtype_Indication (Index);
+      end loop;
+      Put (") of ");
+      Disp_Subtype_Indication (Get_Element_Subtype (Def));
+   end Disp_Array_Subtype_Definition;
+
+   procedure Disp_Array_Type_Definition (Def: Iir_Array_Type_Definition) is
+      Index: Iir;
+   begin
+      Put ("array (");
+      for I in Natural loop
+         Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+         exit when Index = Null_Iir;
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Subtype_Indication (Index);
+         Put (" range <>");
+      end loop;
+      Put (") of ");
+      Disp_Type (Get_Element_Subtype (Def));
+      Put (";");
+   end Disp_Array_Type_Definition;
+
+   procedure Disp_Physical_Literal (Lit: Iir) is
+   begin
+      case Get_Kind (Lit) is
+         when Iir_Kind_Physical_Int_Literal =>
+            Disp_Int64 (Get_Value (Lit));
+         when Iir_Kind_Physical_Fp_Literal =>
+            Disp_Fp64 (Get_Fp_Value (Lit));
+         when others =>
+            Error_Kind ("disp_physical_literal", Lit);
+      end case;
+      Put (' ');
+      Disp_Identifier (Get_Unit_Name (Lit));
+   end Disp_Physical_Literal;
+
+   procedure Disp_Physical_Subtype_Definition
+     (Def: Iir_Physical_Subtype_Definition; Indent: Count)
+   is
+      Base_Type: Iir;
+      Unit: Iir_Unit_Declaration;
+   begin
+      Disp_Resolution_Function (Def);
+      Put ("range ");
+      Disp_Expression (Get_Range_Constraint (Def));
+      Base_Type := Get_Base_Type (Def);
+      if Get_Type_Declarator (Base_Type) = Get_Type_Declarator (Def) then
+         Put_Line (" units");
+         Set_Col (Indent + Indentation);
+         Unit := Get_Unit_Chain (Base_Type);
+         Disp_Identifier (Unit);
+         Put_Line (";");
+         Unit := Get_Chain (Unit);
+         while Unit /= Null_Iir loop
+            Set_Col (Indent + Indentation);
+            Disp_Identifier (Unit);
+            Put (" = ");
+            Disp_Physical_Literal (Get_Physical_Literal (Unit));
+            Put_Line (";");
+            Unit := Get_Chain (Unit);
+         end loop;
+         Set_Col (Indent);
+         Put ("end units;");
+      end if;
+   end Disp_Physical_Subtype_Definition;
+
+   procedure Disp_Record_Type_Definition
+     (Def: Iir_Record_Type_Definition; Indent: Count)
+   is
+      List : Iir_List;
+      El: Iir_Element_Declaration;
+   begin
+      Put_Line ("record");
+      Set_Col (Indent);
+      Put_Line ("begin");
+      List := Get_Elements_Declaration_List (Def);
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         Set_Col (Indent + Indentation);
+         Disp_Identifier (El);
+         Put (" : ");
+         Disp_Subtype_Indication (Get_Type (El));
+         Put_Line (";");
+      end loop;
+      Set_Col (Indent);
+      Put ("end record;");
+   end Disp_Record_Type_Definition;
+
+   procedure Disp_Designator_List (List: Iir_List) is
+      El: Iir;
+   begin
+      if List = Null_Iir_List then
+         return;
+      end if;
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         if I > 0 then
+            Put (", ");
+         end if;
+         Disp_Expression (El);
+         --Disp_Text_Literal (El);
+      end loop;
+   end Disp_Designator_List;
+
+   -- Display the full definition of a type, ie the sequence that can create
+   -- such a type.
+   procedure Disp_Type_Definition (Decl: in Iir; Indent: Count) is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Enumeration_Type_Definition (Decl);
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            Disp_Enumeration_Subtype_Definition (Decl);
+         when Iir_Kind_Integer_Subtype_Definition =>
+            Disp_Integer_Subtype_Definition (Decl);
+         when Iir_Kind_Floating_Subtype_Definition =>
+            Disp_Floating_Subtype_Definition (Decl);
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Type_Definition (Decl);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Subtype_Definition (Decl);
+         when Iir_Kind_Physical_Subtype_Definition =>
+            Disp_Physical_Subtype_Definition (Decl, Indent);
+         when Iir_Kind_Record_Type_Definition =>
+            Disp_Record_Type_Definition (Decl, Indent);
+         when Iir_Kind_Access_Type_Definition =>
+            Put ("access ");
+            Disp_Subtype_Indication (Get_Designated_Type (Decl));
+            Put (';');
+         when Iir_Kind_File_Type_Definition =>
+            Put ("file of ");
+            Disp_Subtype_Indication (Get_Type_Mark (Decl));
+            Put (';');
+         when Iir_Kind_Protected_Type_Declaration =>
+            Put_Line ("protected");
+            Disp_Declaration_Chain (Decl, Indent + Indentation);
+            Set_Col (Indent);
+            Put ("end protected;");
+         when Iir_Kind_Integer_Type_Definition =>
+            Put ("<integer base type>");
+         when Iir_Kind_Floating_Type_Definition =>
+            Put ("<floating base type>");
+         when Iir_Kind_Physical_Type_Definition =>
+            Put ("<physical base type>");
+         when others =>
+            Error_Kind ("disp_type_definition", Decl);
+      end case;
+   end Disp_Type_Definition;
+
+   procedure Disp_Type_Declaration (Decl: Iir_Type_Declaration)
+   is
+      Indent: Count;
+      Def : Iir;
+   begin
+      Indent := Col;
+      Put ("type ");
+      Disp_Name_Of (Decl);
+      Def := Get_Type (Decl);
+      if Def = Null_Iir
+        or else Get_Kind (Def) = Iir_Kind_Incomplete_Type_Definition
+      then
+         Put_Line (";");
+      else
+         Put (" is ");
+         Disp_Type_Definition (Def, Indent);
+         New_Line;
+      end if;
+   end Disp_Type_Declaration;
+
+   procedure Disp_Anonymous_Type_Declaration
+     (Decl: Iir_Anonymous_Type_Declaration)
+   is
+      Indent: Count;
+      Def : Iir;
+   begin
+      Indent := Col;
+      Put ("-- type ");
+      Disp_Name_Of (Decl);
+      Put (" is ");
+      Def := Get_Type (Decl);
+      Disp_Type_Definition (Def, Indent);
+      if Get_Kind (Def) = Iir_Kind_Physical_Type_Definition then
+         declare
+            Unit : Iir_Unit_Declaration;
+         begin
+            Put_Line (" units");
+            Set_Col (Indent);
+            Put ("--   ");
+            Unit := Get_Unit_Chain (Def);
+            Disp_Identifier (Unit);
+            Put_Line (";");
+            Unit := Get_Chain (Unit);
+            while Unit /= Null_Iir loop
+               Set_Col (Indent);
+               Put ("--   ");
+               Disp_Identifier (Unit);
+               Put (" = ");
+               Disp_Physical_Literal (Get_Physical_Literal (Unit));
+               Put_Line (";");
+               Unit := Get_Chain (Unit);
+            end loop;
+            Set_Col (Indent);
+            Put ("-- end units;");
+         end;
+      end if;
+      New_Line;
+   end Disp_Anonymous_Type_Declaration;
+
+   procedure Disp_Subtype_Declaration (Decl: in Iir_Subtype_Declaration) is
+   begin
+      Put ("subtype ");
+      Disp_Name_Of (Decl);
+      Put (" is ");
+      Disp_Subtype_Indication (Get_Type (Decl), True);
+      Put_Line (";");
+   end Disp_Subtype_Declaration;
+
+   procedure Disp_Type (A_Type: Iir)
+   is
+      Decl: Iir;
+   begin
+      Decl := Get_Type_Declarator (A_Type);
+      if Decl /= Null_Iir then
+         Disp_Name_Of (Decl);
+      else
+         case Get_Kind (A_Type) is
+            when Iir_Kind_Enumeration_Type_Definition
+              | Iir_Kind_Integer_Type_Definition =>
+               raise Program_Error;
+            when Iir_Kind_Integer_Subtype_Definition
+              | Iir_Kind_Enumeration_Subtype_Definition =>
+               Disp_Subtype_Indication (A_Type);
+            when Iir_Kind_Array_Subtype_Definition =>
+               Disp_Subtype_Indication (A_Type);
+            when others =>
+               Error_Kind ("disp_type", A_Type);
+         end case;
+      end if;
+   end Disp_Type;
+
+   procedure Disp_Mode (Mode: Iir_Mode) is
+   begin
+      case Mode is
+         when Iir_In_Mode =>
+            Put ("in ");
+         when Iir_Out_Mode =>
+            Put ("out ");
+         when Iir_Inout_Mode =>
+            Put ("inout ");
+         when Iir_Buffer_Mode =>
+            Put ("buffer ");
+         when Iir_Linkage_Mode =>
+            Put ("linkage ");
+         when Iir_Unknown_Mode =>
+            Put ("<unknown> ");
+      end case;
+   end Disp_Mode;
+
+   procedure Disp_Signal_Kind (Kind: Iir_Signal_Kind) is
+   begin
+      case Kind is
+         when Iir_No_Signal_Kind =>
+            null;
+         when Iir_Register_Kind =>
+            Put (" register");
+         when Iir_Bus_Kind =>
+            Put (" bus");
+      end case;
+   end Disp_Signal_Kind;
+
+   procedure Disp_Interface_Declaration (Inter: Iir)
+   is
+      Default: Iir;
+   begin
+      case Get_Kind (Inter) is
+         when Iir_Kind_Signal_Interface_Declaration =>
+            Put ("signal ");
+         when Iir_Kind_Variable_Interface_Declaration =>
+            Put ("variable ");
+         when Iir_Kind_Constant_Interface_Declaration =>
+            Put ("constant ");
+         when Iir_Kind_File_Interface_Declaration =>
+            Put ("file ");
+         when others =>
+            Error_Kind ("disp_interface_declaration", Inter);
+      end case;
+      Disp_Name_Of (Inter);
+      Put (": ");
+      Disp_Mode (Get_Mode (Inter));
+      Disp_Type (Get_Type (Inter));
+      if Get_Kind (Inter) = Iir_Kind_Signal_Interface_Declaration then
+         Disp_Signal_Kind (Get_Signal_Kind (Inter));
+      end if;
+      Default := Get_Default_Value (Inter);
+      if Default /= Null_Iir then
+         Put (" := ");
+         Disp_Expression (Default);
+      end if;
+   end Disp_Interface_Declaration;
+
+   procedure Disp_Interface_Chain (Chain: Iir; Str: String)
+   is
+      Inter: Iir;
+      Start: Count;
+   begin
+      if Chain = Null_Iir then
+         return;
+      end if;
+      Put (" (");
+      Start := Col;
+      Inter := Chain;
+      while Inter /= Null_Iir loop
+         Set_Col (Start);
+         Disp_Interface_Declaration (Inter);
+         if Get_Chain (Inter) /= Null_Iir then
+            Put ("; ");
+         else
+            Put (')');
+            Put (Str);
+         end if;
+         Inter := Get_Chain (Inter);
+      end loop;
+   end Disp_Interface_Chain;
+
+   procedure Disp_Ports (Parent : Iir) is
+   begin
+      Put ("port");
+      Disp_Interface_Chain (Get_Port_Chain (Parent), ";");
+   end Disp_Ports;
+
+   procedure Disp_Generics (Parent : Iir) is
+   begin
+      Put ("generic");
+      Disp_Interface_Chain (Get_Generic_Chain (Parent), ";");
+   end Disp_Generics;
+
+   procedure Disp_Entity_Declaration (Decl: Iir_Entity_Declaration) is
+      Start: Count;
+   begin
+      Start := Col;
+      Put ("entity ");
+      Disp_Name_Of (Decl);
+      Put_Line (" is");
+      if Get_Generic_Chain (Decl) /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Disp_Generics (Decl);
+      end if;
+      if Get_Port_Chain (Decl) /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Disp_Ports (Decl);
+      end if;
+      Disp_Declaration_Chain (Decl, Start + Indentation);
+      if Get_Concurrent_Statement_Chain (Decl) /= Null_Iir then
+         Set_Col (Start);
+         Put_Line ("begin");
+         Disp_Concurrent_Statement_Chain (Decl, Start + Indentation);
+      end if;
+      Set_Col (Start);
+      Put_Line ("end entity;");
+   end Disp_Entity_Declaration;
+
+   procedure Disp_Component_Declaration (Decl: Iir_Component_Declaration)
+   is
+      Indent: Count;
+   begin
+      Indent := Col;
+      Put ("component ");
+      Disp_Name_Of (Decl);
+      if Get_Generic_Chain (Decl) /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Generics (Decl);
+      end if;
+      if Get_Port_Chain (Decl) /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Ports (Decl);
+      end if;
+      Set_Col (Indent);
+      Put ("end component;");
+   end Disp_Component_Declaration;
+
+   procedure Disp_Concurrent_Statement_Chain (Parent : Iir; Indent : Count)
+   is
+      El: Iir;
+   begin
+      El := Get_Concurrent_Statement_Chain (Parent);
+      while El /= Null_Iir loop
+         Set_Col (Indent);
+         Disp_Concurrent_Statement (El);
+         El := Get_Chain (El);
+      end loop;
+   end Disp_Concurrent_Statement_Chain;
+
+   procedure Disp_Architecture_Declaration (Arch: Iir_Architecture_Declaration)
+   is
+      Start: Count;
+   begin
+      Start := Col;
+      Put ("architecture ");
+      Disp_Name_Of (Arch);
+      Put (" of ");
+      Disp_Name_Of (Get_Entity (Arch));
+      Put_Line (" is");
+      Disp_Declaration_Chain (Arch, Start + Indentation);
+      Set_Col (Start);
+      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (Arch, Start + Indentation);
+      Set_Col (Start);
+      Put_Line ("end;");
+   end Disp_Architecture_Declaration;
+
+   procedure Disp_Object_Alias_Declaration (Decl: Iir_Object_Alias_Declaration)
+   is
+   begin
+      Put ("alias ");
+      Disp_Name_Of (Decl);
+      Put (": ");
+      Disp_Type (Get_Type (Decl));
+      Put (" is ");
+      Disp_Expression (Get_Name (Decl));
+      Put_Line (";");
+   end Disp_Object_Alias_Declaration;
+
+   procedure Disp_Non_Object_Alias_Declaration
+     (Decl: Iir_Non_Object_Alias_Declaration)
+   is
+   begin
+      Put ("alias ");
+      Disp_Function_Name (Decl);
+      Put (" is ");
+      Disp_Name (Get_Name (Decl));
+      Put_Line (";");
+   end Disp_Non_Object_Alias_Declaration;
+
+   procedure Disp_File_Declaration (Decl: Iir_File_Declaration) is
+      Expr: Iir;
+   begin
+      Put ("file ");
+      Disp_Name_Of (Decl);
+      Put (": ");
+      Disp_Type (Get_Type (Decl));
+      if Vhdl_Std = Vhdl_87 then
+         Put (" is ");
+         Disp_Mode (Get_Mode (Decl));
+         Disp_Expression (Get_File_Logical_Name (Decl));
+      else
+         Expr := Get_File_Open_Kind (Decl);
+         if Expr /= Null_Iir then
+            Put (" open ");
+            Disp_Expression (Expr);
+         end if;
+         Expr := Get_File_Logical_Name (Decl);
+         if Expr /= Null_Iir then
+            Put (" is ");
+            Disp_Expression (Expr);
+         end if;
+      end if;
+      Put (';');
+   end Disp_File_Declaration;
+
+   procedure Disp_Object_Declaration (Decl: Iir) is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Variable_Declaration =>
+            if Get_Shared_Flag (Decl) then
+               Put ("shared ");
+            end if;
+            Put ("variable ");
+         when Iir_Kind_Constant_Declaration =>
+            Put ("constant ");
+         when Iir_Kind_Signal_Declaration =>
+            Put ("signal ");
+         when Iir_Kind_Object_Alias_Declaration =>
+            Disp_Object_Alias_Declaration (Decl);
+            return;
+         when Iir_Kind_File_Declaration =>
+            Disp_File_Declaration (Decl);
+            return;
+         when others =>
+            raise Internal_Error;
+      end case;
+      Disp_Name_Of (Decl);
+      Put (": ");
+      Disp_Type (Get_Type (Decl));
+      if Get_Kind (Decl) = Iir_Kind_Signal_Declaration then
+         Disp_Signal_Kind (Get_Signal_Kind (Decl));
+      end if;
+
+      if Get_Default_Value (Decl) /= Null_Iir then
+         Put (" := ");
+         Disp_Expression (Get_Default_Value (Decl));
+      end if;
+      Put_Line (";");
+   end Disp_Object_Declaration;
+
+   procedure Disp_Subprogram_Declaration (Subprg: Iir) is
+   begin
+      case Get_Kind (Subprg) is
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            Put ("function ");
+            Disp_Function_Name (Subprg);
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            Put ("procedure ");
+            Disp_Identifier (Subprg);
+         when others =>
+            raise Internal_Error;
+      end case;
+
+      Disp_Interface_Chain (Get_Interface_Declaration_Chain (Subprg), "");
+
+      case Get_Kind (Subprg) is
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            Put (" return ");
+            Disp_Type (Get_Return_Type (Subprg));
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            null;
+         when others =>
+            raise Internal_Error;
+      end case;
+   end Disp_Subprogram_Declaration;
+
+   procedure Disp_Subprogram_Body (Subprg : Iir)
+   is
+      Decl : Iir;
+      Indent : Count;
+   begin
+      Decl := Get_Subprogram_Specification (Subprg);
+      Indent := Col;
+      if Get_Chain (Decl) /= Subprg then
+         Disp_Subprogram_Declaration (Decl);
+      end if;
+      Put_Line ("is");
+      Set_Col (Indent);
+      Disp_Declaration_Chain (Subprg, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("begin");
+      Set_Col (Indent + Indentation);
+      Disp_Sequential_Statements (Get_Sequential_Statement_Chain (Subprg));
+      Set_Col (Indent);
+      Put_Line ("end;");
+      New_Line;
+   end Disp_Subprogram_Body;
+
+   procedure Disp_Instantiation_List (Insts: Iir_List) is
+      El : Iir;
+   begin
+      if Insts = Iir_List_All then
+         Put ("all");
+      elsif Insts = Iir_List_Others then
+         Put ("others");
+      else
+         for I in Natural loop
+            El := Get_Nth_Element (Insts, I);
+            exit when El = Null_Iir;
+            if I /= Natural'First then
+               Put (", ");
+            end if;
+            Disp_Name_Of (El);
+         end loop;
+      end if;
+   end Disp_Instantiation_List;
+
+   procedure Disp_Configuration_Specification
+     (Spec : Iir_Configuration_Specification)
+   is
+      Indent : Count;
+   begin
+      Indent := Col;
+      Put ("for ");
+      Disp_Instantiation_List (Get_Instantiation_List (Spec));
+      Put (": ");
+      Disp_Name_Of (Get_Component_Name (Spec));
+      New_Line;
+      Disp_Binding_Indication (Get_Binding_Indication (Spec),
+                               Indent + Indentation);
+      Put_Line (";");
+   end Disp_Configuration_Specification;
+
+   procedure Disp_Disconnection_Specification
+     (Dis : Iir_Disconnection_Specification)
+   is
+   begin
+      Put ("disconnect ");
+      Disp_Instantiation_List (Get_Signal_List (Dis));
+      Put (": ");
+      Disp_Subtype_Indication (Get_Type (Dis));
+      Put (" after ");
+      Disp_Expression (Get_Expression (Dis));
+      Put_Line (";");
+   end Disp_Disconnection_Specification;
+
+   procedure Disp_Attribute_Declaration (Attr : Iir_Attribute_Declaration)
+   is
+   begin
+      Put ("attribute ");
+      Disp_Identifier (Attr);
+      Put (": ");
+      Disp_Type (Get_Type (Attr));
+      Put_Line (";");
+   end Disp_Attribute_Declaration;
+
+   procedure Disp_Entity_Kind (Tok : Tokens.Token_Type) is
+   begin
+      Put (Tokens.Image (Tok));
+   end Disp_Entity_Kind;
+
+   procedure Disp_Entity_Name_List (List : Iir_List)
+   is
+      El : Iir;
+   begin
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Name_Of (El);
+      end loop;
+   end Disp_Entity_Name_List;
+
+   procedure Disp_Attribute_Specification (Attr : Iir_Attribute_Specification)
+   is
+   begin
+      Put ("attribute ");
+      Disp_Identifier (Get_Attribute_Designator (Attr));
+      Put (" of ");
+      Disp_Entity_Name_List (Get_Entity_Name_List (Attr));
+      Put (": ");
+      Disp_Entity_Kind (Get_Entity_Class (Attr));
+      Put (" is ");
+      Disp_Expression (Get_Expression (Attr));
+      Put_Line (";");
+   end Disp_Attribute_Specification;
+
+   procedure Disp_Protected_Type_Body
+     (Bod : Iir_Protected_Type_Body; Indent : Count)
+   is
+   begin
+      Put ("type ");
+      Disp_Identifier (Bod);
+      Put (" is protected body");
+      New_Line;
+      Disp_Declaration_Chain (Bod, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end protected body;");
+   end Disp_Protected_Type_Body;
+
+   procedure Disp_Declaration_Chain (Parent : Iir; Indent: Count)
+   is
+      Decl: Iir;
+   begin
+      Decl := Get_Declaration_Chain (Parent);
+      while Decl /= Null_Iir loop
+         Set_Col (Indent);
+         case Get_Kind (Decl) is
+            when Iir_Kind_Type_Declaration =>
+               Disp_Type_Declaration (Decl);
+            when Iir_Kind_Anonymous_Type_Declaration =>
+               Disp_Anonymous_Type_Declaration (Decl);
+            when Iir_Kind_Subtype_Declaration =>
+               Disp_Subtype_Declaration (Decl);
+            when Iir_Kind_Use_Clause =>
+               Disp_Use_Clause (Decl);
+            when Iir_Kind_Component_Declaration =>
+               Disp_Component_Declaration (Decl);
+            when Iir_Kinds_Object_Declaration =>
+               Disp_Object_Declaration (Decl);
+            when Iir_Kind_Non_Object_Alias_Declaration =>
+               Disp_Non_Object_Alias_Declaration (Decl);
+            when Iir_Kind_Implicit_Function_Declaration
+              | Iir_Kind_Implicit_Procedure_Declaration =>
+               Disp_Subprogram_Declaration (Decl);
+               Put_Line (";");
+            when Iir_Kind_Function_Declaration
+              | Iir_Kind_Procedure_Declaration =>
+               Disp_Subprogram_Declaration (Decl);
+               if Get_Subprogram_Body (Decl) = Null_Iir
+                 or else Get_Subprogram_Body (Decl) /= Get_Chain (Decl)
+               then
+                  Put_Line (";");
+               end if;
+            when Iir_Kind_Function_Body
+              | Iir_Kind_Procedure_Body =>
+               Disp_Subprogram_Body (Decl);
+            when Iir_Kind_Protected_Type_Body =>
+               Disp_Protected_Type_Body (Decl, Indent);
+            when Iir_Kind_Configuration_Specification =>
+               Disp_Configuration_Specification (Decl);
+            when Iir_Kind_Disconnection_Specification =>
+               Disp_Disconnection_Specification (Decl);
+            when Iir_Kind_Attribute_Declaration =>
+               Disp_Attribute_Declaration (Decl);
+            when Iir_Kind_Attribute_Specification =>
+               Disp_Attribute_Specification (Decl);
+            when Iir_Kinds_Signal_Attribute =>
+               null;
+            when others =>
+               Error_Kind ("disp_declaration_chain", Decl);
+         end case;
+         Decl := Get_Chain (Decl);
+      end loop;
+   end Disp_Declaration_Chain;
+
+   procedure Disp_Waveform (Chain : Iir_Waveform_Element)
+   is
+      We: Iir_Waveform_Element;
+      Val : Iir;
+   begin
+      if Chain = Null_Iir then
+         Put ("null after {disconnection_time}");
+         return;
+      end if;
+      We := Chain;
+      while We /= Null_Iir loop
+         if We /= Chain then
+            Put (", ");
+         end if;
+         Val := Get_We_Value (We);
+         Disp_Expression (Val);
+         if Get_Time (We) /= Null_Iir then
+            Put (" after ");
+            Disp_Expression (Get_Time (We));
+         end if;
+         We := Get_Chain (We);
+      end loop;
+   end Disp_Waveform;
+
+   procedure Disp_Delay_Mechanism (Stmt: Iir) is
+      Expr: Iir;
+   begin
+      case Get_Delay_Mechanism (Stmt) is
+         when Iir_Transport_Delay =>
+            Put ("transport ");
+         when Iir_Inertial_Delay =>
+            Expr := Get_Reject_Time_Expression (Stmt);
+            if Expr /= Null_Iir then
+               Put ("reject ");
+               Disp_Expression (Expr);
+               Put (" inertial ");
+            end if;
+      end case;
+   end Disp_Delay_Mechanism;
+
+   procedure Disp_Signal_Assignment (Stmt: Iir) is
+   begin
+      Disp_Expression (Get_Target (Stmt));
+      Put (" <= ");
+      Disp_Delay_Mechanism (Stmt);
+      Disp_Waveform (Get_Waveform_Chain (Stmt));
+      Put_Line (";");
+   end Disp_Signal_Assignment;
+
+   procedure Disp_Variable_Assignment (Stmt: Iir) is
+   begin
+      Disp_Expression (Get_Target (Stmt));
+      Put (" := ");
+      Disp_Expression (Get_Expression (Stmt));
+      Put_Line (";");
+   end Disp_Variable_Assignment;
+
+   procedure Disp_Label (Label: Name_Id) is
+   begin
+      if Label /= Null_Identifier then
+         Disp_Ident (Label);
+         Put (": ");
+      end if;
+   end Disp_Label;
+
+   procedure Disp_Concurrent_Selected_Signal_Assignment (Stmt: Iir)
+   is
+      Indent: Count;
+      Assoc: Iir;
+      Assoc_Chain : Iir;
+   begin
+      Indent := Col;
+      Set_Col (Indent);
+      Disp_Label (Get_Label (Stmt));
+      Put ("with ");
+      Disp_Expression (Get_Expression (Stmt));
+      Put (" select ");
+      Disp_Expression (Get_Target (Stmt));
+      Put (" <= ");
+      if Get_Guard (Stmt) /= Null_Iir then
+         Put ("guarded ");
+      end if;
+      Disp_Delay_Mechanism (Stmt);
+      Assoc_Chain := Get_Selected_Waveform_Chain (Stmt);
+      Assoc := Assoc_Chain;
+      while Assoc /= Null_Iir loop
+         if Assoc /= Assoc_Chain then
+            Put_Line (",");
+         end if;
+         Set_Col (Indent + Indentation);
+         Disp_Waveform (Get_Associated (Assoc));
+         Put (" when ");
+         Disp_Choice (Assoc);
+      end loop;
+      Put_Line (";");
+   end Disp_Concurrent_Selected_Signal_Assignment;
+
+   procedure Disp_Concurrent_Conditional_Signal_Assignment (Stmt: Iir)
+   is
+      Indent: Count;
+      Cond_Wf : Iir_Conditional_Waveform;
+      Expr : Iir;
+   begin
+      Disp_Label (Get_Label (Stmt));
+      Disp_Expression (Get_Target (Stmt));
+      Put (" <= ");
+      if Get_Guard (Stmt) /= Null_Iir then
+         Put ("guarded ");
+      end if;
+      Disp_Delay_Mechanism (Stmt);
+      Indent := Col;
+      Set_Col (Indent);
+      Cond_Wf := Get_Conditional_Waveform_Chain (Stmt);
+      while Cond_Wf /= Null_Iir loop
+         Disp_Waveform (Get_Waveform_Chain (Cond_Wf));
+         Expr := Get_Condition (Cond_Wf);
+         if Expr /= Null_Iir then
+            Put (" when ");
+            Disp_Expression (Expr);
+            Put_Line (" else");
+            Set_Col (Indent);
+         end if;
+         Cond_Wf := Get_Chain (Cond_Wf);
+      end loop;
+
+      Put_Line (";");
+   end Disp_Concurrent_Conditional_Signal_Assignment;
+
+   procedure Disp_Assertion_Statement (Stmt: Iir) is
+      Start: Count;
+      Expr: Iir;
+   begin
+      Start := Col;
+      if Get_Kind (Stmt) = Iir_Kind_Concurrent_Assertion_Statement then
+         Disp_Label (Get_Label (Stmt));
+      end if;
+      Put ("assert ");
+      Disp_Expression (Get_Assertion_Condition (Stmt));
+      Expr := Get_Report_Expression (Stmt);
+      if Expr /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Put ("report ");
+         Disp_Expression (Expr);
+      end if;
+      Expr := Get_Severity_Expression (Stmt);
+      if Expr /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Put ("severity ");
+         Disp_Expression (Expr);
+      end if;
+      Put_Line (";");
+   end Disp_Assertion_Statement;
+
+   procedure Disp_Report_Statement (Stmt: Iir)
+   is
+      Start: Count;
+      Expr: Iir;
+   begin
+      Start := Col;
+      Put ("report ");
+      Expr := Get_Report_Expression (Stmt);
+      Disp_Expression (Expr);
+      Expr := Get_Severity_Expression (Stmt);
+      if Expr /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Put ("severity ");
+         Disp_Expression (Expr);
+      end if;
+      Put_Line (";");
+   end Disp_Report_Statement;
+
+   procedure Disp_Dyadic_Operator (Expr: Iir) is
+   begin
+      Put ("(");
+      Disp_Expression (Get_Left (Expr));
+      Put (' ' & Name_Table.Image (Iirs_Utils.Get_Operator_Name (Expr)) & ' ');
+      Disp_Expression (Get_Right (Expr));
+      Put (")");
+   end Disp_Dyadic_Operator;
+
+   procedure Disp_Monadic_Operator (Expr: Iir) is
+   begin
+      Put (Name_Table.Image (Iirs_Utils.Get_Operator_Name (Expr)) & " (");
+      Disp_Expression (Get_Operand (Expr));
+      Put (")");
+   end Disp_Monadic_Operator;
+
+   procedure Disp_Case_Statement (Stmt: Iir_Case_Statement)
+   is
+      Indent: Count;
+      Assoc: Iir;
+      Sel_Stmt : Iir;
+   begin
+      Indent := Col;
+      Put ("case ");
+      Disp_Expression (Get_Expression (Stmt));
+      Put_Line (" is");
+      Assoc := Get_Case_Statement_Alternative_Chain (Stmt);
+      while Assoc /= Null_Iir loop
+         Set_Col (Indent + Indentation);
+         Put ("when ");
+         Sel_Stmt := Get_Associated (Assoc);
+         Disp_Choice (Assoc);
+         Put_Line (" =>");
+         Set_Col (Indent + 2 * Indentation);
+         Disp_Sequential_Statements (Sel_Stmt);
+      end loop;
+      Set_Col (Indent);
+      Put_Line ("end case;");
+   end Disp_Case_Statement;
+
+   procedure Disp_Wait_Statement (Stmt: Iir_Wait_Statement) is
+      List: Iir_List;
+      Expr: Iir;
+   begin
+      Put ("wait");
+      List := Get_Sensitivity_List (Stmt);
+      if List /= Null_Iir_List then
+         Put (" on ");
+         Disp_Designator_List (List);
+      end if;
+      Expr := Get_Condition_Clause (Stmt);
+      if Expr /= Null_Iir then
+         Put (" until ");
+         Disp_Expression (Expr);
+      end if;
+      Expr := Get_Timeout_Clause (Stmt);
+      if Expr /= Null_Iir then
+         Put (" for ");
+         Disp_Expression (Expr);
+      end if;
+      Put_Line (";");
+   end Disp_Wait_Statement;
+
+   procedure Disp_If_Statement (Stmt: Iir_If_Statement) is
+      Clause: Iir;
+      Expr: Iir;
+      Start: Count;
+   begin
+      Start := Col;
+      Put ("if ");
+      Clause := Stmt;
+      Disp_Expression (Get_Condition (Clause));
+      Put_Line (" then");
+      while Clause /= Null_Iir loop
+         Set_Col (Start + Indentation);
+         Disp_Sequential_Statements (Get_Sequential_Statement_Chain (Clause));
+         Clause := Get_Else_Clause (Clause);
+         exit when Clause = Null_Iir;
+         Expr := Get_Condition (Clause);
+         Set_Col (Start);
+         if Expr /= Null_Iir then
+            Put ("elsif ");
+            Disp_Expression (Expr);
+            Put_Line (" then");
+         else
+            Put_Line ("else");
+         end if;
+      end loop;
+      Set_Col (Start);
+      Put_Line ("end if;");
+   end Disp_If_Statement;
+
+   procedure Disp_Iterator (Iterator: Iir) is
+   begin
+      Disp_Subtype_Indication (Iterator);
+   end Disp_Iterator;
+
+   procedure Disp_Parameter_Specification
+     (Iterator : Iir_Iterator_Declaration) is
+   begin
+      Disp_Identifier (Iterator);
+      Put (" in ");
+      Disp_Iterator (Get_Type (Iterator));
+   end Disp_Parameter_Specification;
+
+   procedure Disp_Procedure_Call (Call : Iir)
+   is
+      Obj : Iir;
+   begin
+      Obj := Get_Method_Object (Call);
+      if Obj /= Null_Iir then
+         Disp_Name (Obj);
+         Put ('.');
+      end if;
+      Disp_Identifier (Get_Implementation (Call));
+      Put (' ');
+      Disp_Association_Chain (Get_Parameter_Association_Chain (Call));
+      Put_Line (";");
+   end Disp_Procedure_Call;
+
+   procedure Disp_Sequential_Statements (First : Iir)
+   is
+      Stmt: Iir;
+      Start: Count;
+   begin
+      Start := Col;
+      Stmt := First;
+      while Stmt /= Null_Iir loop
+         Set_Col (Start);
+         case Get_Kind (Stmt) is
+            when Iir_Kind_Null_Statement =>
+               Put_Line ("null;");
+            when Iir_Kind_If_Statement =>
+               Disp_If_Statement (Stmt);
+            when Iir_Kind_For_Loop_Statement =>
+               Put ("for ");
+               Disp_Parameter_Specification (Get_Iterator_Scheme (Stmt));
+               Put_Line (" loop");
+               Set_Col (Start + Indentation);
+               Disp_Sequential_Statements
+                 (Get_Sequential_Statement_Chain (Stmt));
+               Set_Col (Start);
+               Put_Line ("end loop;");
+            when Iir_Kind_While_Loop_Statement =>
+               if Get_Condition (Stmt) /= Null_Iir then
+                  Put ("while ");
+                  Disp_Expression (Get_Condition (Stmt));
+                  Put (" ");
+               end if;
+               Put_Line ("loop");
+               Set_Col (Start + Indentation);
+               Disp_Sequential_Statements
+                 (Get_Sequential_Statement_Chain (Stmt));
+               Set_Col (Start);
+               Put_Line ("end loop;");
+            when Iir_Kind_Signal_Assignment_Statement =>
+               Disp_Signal_Assignment (Stmt);
+            when Iir_Kind_Variable_Assignment_Statement =>
+               Disp_Variable_Assignment (Stmt);
+            when Iir_Kind_Assertion_Statement =>
+               Disp_Assertion_Statement (Stmt);
+            when Iir_Kind_Report_Statement =>
+               Disp_Report_Statement (Stmt);
+            when Iir_Kind_Return_Statement =>
+               if Get_Expression (Stmt) /= Null_Iir then
+                  Put ("return ");
+                  Disp_Expression (Get_Expression (Stmt));
+                  Put_Line (";");
+               else
+                  Put_Line ("return;");
+               end if;
+            when Iir_Kind_Case_Statement =>
+               Disp_Case_Statement (Stmt);
+            when Iir_Kind_Wait_Statement =>
+               Disp_Wait_Statement (Stmt);
+            when Iir_Kind_Procedure_Call_Statement =>
+               Disp_Procedure_Call (Get_Procedure_Call (Stmt));
+            when Iir_Kind_Exit_Statement
+              | Iir_Kind_Next_Statement =>
+               if Get_Kind (Stmt) = Iir_Kind_Exit_Statement then
+                  Put ("exit");
+               else
+                  Put ("next");
+               end if;
+               -- FIXME: label.
+               if Get_Condition (Stmt) /= Null_Iir then
+                  Put (" when ");
+                  Disp_Expression (Get_Condition (Stmt));
+               end if;
+               Put_Line (";");
+
+            when others =>
+               Error_Kind ("disp_sequential_statements", Stmt);
+         end case;
+         Stmt := Get_Chain (Stmt);
+      end loop;
+   end Disp_Sequential_Statements;
+
+   procedure Disp_Process_Statement (Process: Iir)
+   is
+      Start: Count;
+   begin
+      Start := Col;
+      Disp_Label (Get_Label (Process));
+
+      Put ("process ");
+      if Get_Kind (Process) = Iir_Kind_Sensitized_Process_Statement then
+         Put ("(");
+         Disp_Designator_List (Get_Sensitivity_List (Process));
+         Put (")");
+      end if;
+      if Vhdl_Std >= Vhdl_93 then
+         Put_Line (" is");
+      else
+         New_Line;
+      end if;
+      Disp_Declaration_Chain (Process, Start + Indentation);
+      Set_Col (Start);
+      Put_Line ("begin");
+      Set_Col (Start + Indentation);
+      Disp_Sequential_Statements (Get_Sequential_Statement_Chain (Process));
+      Set_Col (Start);
+      Put_Line ("end process;");
+   end Disp_Process_Statement;
+
+   procedure Disp_Association_Chain (Chain : Iir)
+   is
+      El: Iir;
+      Formal: Iir;
+      Need_Comma : Boolean;
+      Conv : Iir;
+   begin
+      if Chain = Null_Iir then
+         return;
+      end if;
+      Put ("(");
+      Need_Comma := False;
+
+      El := Chain;
+      while El /= Null_Iir loop
+         if Get_Kind (El) /= Iir_Kind_Association_Element_By_Individual then
+            if Need_Comma then
+               Put (", ");
+            end if;
+            if Get_Kind (El) = Iir_Kind_Association_Element_By_Expression then
+               Conv := Get_Out_Conversion (El);
+               if Conv /= Null_Iir then
+                  Disp_Function_Name (Conv);
+                  Put (" (");
+               end if;
+            else
+               Conv := Null_Iir;
+            end if;
+            Formal := Get_Formal (El);
+            if Formal /= Null_Iir then
+               Disp_Expression (Formal);
+               if Conv /= Null_Iir then
+                  Put (")");
+               end if;
+               Put (" => ");
+            end if;
+            if Get_Kind (El) = Iir_Kind_Association_Element_Open then
+               Put ("open");
+            else
+               Conv := Get_In_Conversion (El);
+               if Conv /= Null_Iir then
+                  Disp_Function_Name (Conv);
+                  Put (" (");
+               end if;
+               Disp_Expression (Get_Actual (El));
+               if Conv /= Null_Iir then
+                  Put (")");
+               end if;
+            end if;
+            Need_Comma := True;
+         end if;
+         El := Get_Chain (El);
+      end loop;
+      Put (")");
+   end Disp_Association_Chain;
+
+   procedure Disp_Generic_Map_Aspect (Parent : Iir) is
+   begin
+      Put ("generic map ");
+      Disp_Association_Chain (Get_Generic_Map_Aspect_Chain (Parent));
+   end Disp_Generic_Map_Aspect;
+
+   procedure Disp_Port_Map_Aspect (Parent : Iir) is
+   begin
+      Put ("port map ");
+      Disp_Association_Chain (Get_Port_Map_Aspect_Chain (Parent));
+   end Disp_Port_Map_Aspect;
+
+   procedure Disp_Entity_Aspect (Aspect : Iir) is
+      Arch : Iir;
+   begin
+      case Get_Kind (Aspect) is
+         when Iir_Kind_Entity_Aspect_Entity =>
+            Put ("entity ");
+            Disp_Name_Of (Get_Entity (Aspect));
+            Arch := Get_Architecture (Aspect);
+            if Arch /= Null_Iir then
+               Put (" (");
+               Disp_Name_Of (Arch);
+               Put (")");
+            end if;
+         when Iir_Kind_Entity_Aspect_Configuration =>
+            Put ("configuration ");
+            Disp_Name_Of (Get_Configuration (Aspect));
+         when Iir_Kind_Entity_Aspect_Open =>
+            Put ("open");
+         when others =>
+            Error_Kind ("disp_entity_aspect", Aspect);
+      end case;
+   end Disp_Entity_Aspect;
+
+   procedure Disp_Component_Instantiation_Statement
+     (Stmt: Iir_Component_Instantiation_Statement)
+   is
+      Component: Iir;
+      Alist: Iir;
+   begin
+      Disp_Label (Get_Label (Stmt));
+      Component := Get_Instantiated_Unit (Stmt);
+      if Get_Kind (Component) = Iir_Kind_Component_Declaration then
+         Disp_Name_Of (Component);
+      else
+         Disp_Entity_Aspect (Component);
+      end if;
+      Alist := Get_Generic_Map_Aspect_Chain (Stmt);
+      if Alist /= Null_Iir then
+         Put (" ");
+         Disp_Generic_Map_Aspect (Stmt);
+      end if;
+      Alist := Get_Port_Map_Aspect_Chain (Stmt);
+      if Alist /= Null_Iir then
+         Put (" ");
+         Disp_Port_Map_Aspect (Stmt);
+      end if;
+      Put (";");
+   end Disp_Component_Instantiation_Statement;
+
+   procedure Disp_Function_Call (Expr: Iir_Function_Call) is
+   begin
+      Disp_Function_Name (Get_Implementation (Expr));
+      Disp_Association_Chain (Get_Parameter_Association_Chain (Expr));
+   end Disp_Function_Call;
+
+   procedure Disp_Indexed_Name (Indexed: Iir)
+   is
+      List : Iir_List;
+      El: Iir;
+   begin
+      Disp_Expression (Get_Prefix (Indexed));
+      Put (" (");
+      List := Get_Index_List (Indexed);
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Expression (El);
+      end loop;
+      Put (")");
+   end Disp_Indexed_Name;
+
+   procedure Disp_Choice (Choice: in out Iir) is
+   begin
+      loop
+         case Get_Kind (Choice) is
+            when Iir_Kind_Choice_By_Others =>
+               Put ("others");
+            when Iir_Kind_Choice_By_None =>
+               null;
+            when Iir_Kind_Choice_By_Expression =>
+               Disp_Expression (Get_Expression (Choice));
+            when Iir_Kind_Choice_By_Range =>
+               Disp_Range (Get_Expression (Choice));
+            when Iir_Kind_Choice_By_Name =>
+               Disp_Name_Of (Get_Name (Choice));
+            when others =>
+               Error_Kind ("disp_choice", Choice);
+         end case;
+         Choice := Get_Chain (Choice);
+         exit when Choice = Null_Iir;
+         exit when Get_Same_Alternative_Flag (Choice) = False;
+         --exit when Choice = Null_Iir;
+         Put (" | ");
+      end loop;
+   end Disp_Choice;
+
+   procedure Disp_Aggregate (Aggr: Iir_Aggregate)
+   is
+      Indent: Count;
+      Assoc: Iir;
+      Expr : Iir;
+   begin
+      Put ("(");
+      Indent := Col;
+      Assoc := Get_Association_Choices_Chain (Aggr);
+      loop
+         Expr := Get_Associated (Assoc);
+         if Get_Kind (Assoc) /= Iir_Kind_Choice_By_None then
+            Disp_Choice (Assoc);
+            Put (" => ");
+         else
+            Assoc := Get_Chain (Assoc);
+         end if;
+         if Get_Kind (Expr) = Iir_Kind_Aggregate
+           or else Get_Kind (Expr) = Iir_Kind_String_Literal then
+            Set_Col (Indent);
+         end if;
+         Disp_Expression (Expr);
+         exit when Assoc = Null_Iir;
+         Put (", ");
+      end loop;
+      Put (")");
+   end Disp_Aggregate;
+
+   procedure Disp_Simple_Aggregate (Aggr: Iir_Simple_Aggregate)
+   is
+      List : Iir_List;
+      El : Iir;
+      First : Boolean := True;
+   begin
+      Put ("(");
+      List := Get_Simple_Aggregate_List (Aggr);
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         if First then
+            First := False;
+         else
+            Put (", ");
+         end if;
+         Disp_Expression (El);
+      end loop;
+      Put (")");
+   end Disp_Simple_Aggregate;
+
+   procedure Disp_Parametered_Attribute (Name : String; Expr : Iir)
+   is
+      Param : Iir;
+      Pfx : Iir;
+   begin
+      Pfx := Get_Prefix (Expr);
+      case Get_Kind (Pfx) is
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Subtype_Declaration =>
+            Disp_Name_Of (Pfx);
+         when others =>
+            Disp_Expression (Pfx);
+      end case;
+      Put ("'");
+      Put (Name);
+      Param := Get_Parameter (Expr);
+      if Param /= Null_Iir then
+         Put (" (");
+         Disp_Expression (Param);
+         Put (")");
+      end if;
+   end Disp_Parametered_Attribute;
+
+   procedure Disp_String_Literal (Str : Iir)
+   is
+      Ptr : String_Fat_Acc;
+      Len : Int32;
+   begin
+      Ptr := Get_String_Fat_Acc (Str);
+      Len := Get_String_Length (Str);
+      Put (String (Ptr (1 .. Len)));
+   end Disp_String_Literal;
+
+   procedure Disp_Expression (Expr: Iir)
+   is
+      Orig : Iir;
+   begin
+      case Get_Kind (Expr) is
+         when Iir_Kind_Integer_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (Orig);
+            else
+               Disp_Int64 (Get_Value (Expr));
+            end if;
+         when Iir_Kind_Floating_Point_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (Orig);
+            else
+               Disp_Fp64 (Get_Fp_Value (Expr));
+            end if;
+         when Iir_Kind_String_Literal =>
+            Put ("""");
+            Disp_String_Literal (Expr);
+            Put ("""");
+            if Disp_String_Literal_Type or Flags.List_Verbose then
+               Put ("[type: ");
+               Disp_Type (Get_Type (Expr));
+               Put ("]");
+            end if;
+         when Iir_Kind_Bit_String_Literal =>
+            if False then
+               case Get_Bit_String_Base (Expr) is
+                  when Base_2 =>
+                     Put ('B');
+                  when Base_8 =>
+                     Put ('O');
+                  when Base_16 =>
+                     Put ('X');
+               end case;
+            end if;
+            Put ("B""");
+            Disp_String_Literal (Expr);
+            Put ("""");
+         when Iir_Kind_Physical_Fp_Literal
+           | Iir_Kind_Physical_Int_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (Orig);
+            else
+               Disp_Physical_Literal (Expr);
+            end if;
+         when Iir_Kind_Unit_Declaration =>
+            Disp_Name_Of (Expr);
+         when Iir_Kind_Enumeration_Literal =>
+            Disp_Name_Of (Expr);
+         when Iir_Kind_Object_Alias_Declaration =>
+            Disp_Name_Of (Expr);
+         when Iir_Kind_Aggregate =>
+            Disp_Aggregate (Expr);
+         when Iir_Kind_Null_Literal =>
+            Put ("null");
+         when Iir_Kind_Simple_Aggregate =>
+            Disp_Simple_Aggregate (Expr);
+
+         when Iir_Kind_Element_Declaration =>
+            Disp_Name_Of (Expr);
+
+         when Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Iterator_Declaration =>
+            Disp_Name_Of (Expr);
+            return;
+
+         when Iir_Kind_Simple_Name =>
+            Disp_Name (Expr);
+
+         when Iir_Kinds_Dyadic_Operator =>
+            Disp_Dyadic_Operator (Expr);
+         when Iir_Kinds_Monadic_Operator =>
+            Disp_Monadic_Operator (Expr);
+         when Iir_Kind_Function_Call =>
+            Disp_Function_Call (Expr);
+         when Iir_Kind_Type_Conversion =>
+            Disp_Type (Get_Type (Expr));
+            Put (" (");
+            Disp_Expression (Get_Expression (Expr));
+            Put (")");
+         when Iir_Kind_Qualified_Expression =>
+            Disp_Type (Get_Type_Mark (Expr));
+            Put ("'(");
+            Disp_Expression (Get_Expression (Expr));
+            Put (")");
+         when Iir_Kind_Allocator_By_Expression =>
+            Put ("new ");
+            Disp_Expression (Get_Expression (Expr));
+         when Iir_Kind_Allocator_By_Subtype =>
+            Put ("new ");
+            Disp_Subtype_Indication (Get_Expression (Expr));
+
+         when Iir_Kind_Indexed_Name =>
+            Disp_Indexed_Name (Expr);
+         when Iir_Kind_Slice_Name =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put (" (");
+            Disp_Range (Get_Suffix (Expr));
+            Put (")");
+         when Iir_Kind_Selected_Element =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put (".");
+            Disp_Name_Of (Get_Selected_Element (Expr));
+         when Iir_Kind_Implicit_Dereference =>
+            Disp_Expression (Get_Prefix (Expr));
+         when Iir_Kind_Dereference =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put (".all");
+
+         when Iir_Kind_Left_Type_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'left");
+         when Iir_Kind_Right_Type_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'right");
+         when Iir_Kind_High_Type_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'high");
+         when Iir_Kind_Low_Type_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'low");
+
+         when Iir_Kind_Stable_Attribute =>
+            Disp_Parametered_Attribute ("stable", Expr);
+         when Iir_Kind_Delayed_Attribute =>
+            Disp_Parametered_Attribute ("delayed", Expr);
+         when Iir_Kind_Transaction_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'transaction");
+         when Iir_Kind_Event_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'event");
+         when Iir_Kind_Active_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'active");
+         when Iir_Kind_Last_Value_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'last_value");
+         when Iir_Kind_Last_Event_Attribute =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("'last_event");
+
+         when Iir_Kind_Pos_Attribute =>
+            Disp_Parametered_Attribute ("pos", Expr);
+         when Iir_Kind_Val_Attribute =>
+            Disp_Parametered_Attribute ("val", Expr);
+         when Iir_Kind_Succ_Attribute =>
+            Disp_Parametered_Attribute ("succ", Expr);
+         when Iir_Kind_Pred_Attribute =>
+            Disp_Parametered_Attribute ("pred", Expr);
+
+         when Iir_Kind_Length_Array_Attribute =>
+            Disp_Parametered_Attribute ("length", Expr);
+         when Iir_Kind_Range_Array_Attribute =>
+            Disp_Parametered_Attribute ("range", Expr);
+         when Iir_Kind_Reverse_Range_Array_Attribute =>
+            Disp_Parametered_Attribute ("reverse_range", Expr);
+         when Iir_Kind_Left_Array_Attribute =>
+            Disp_Parametered_Attribute ("left", Expr);
+         when Iir_Kind_Right_Array_Attribute =>
+            Disp_Parametered_Attribute ("right", Expr);
+         when Iir_Kind_Low_Array_Attribute =>
+            Disp_Parametered_Attribute ("low", Expr);
+         when Iir_Kind_High_Array_Attribute =>
+            Disp_Parametered_Attribute ("high", Expr);
+         when Iir_Kind_Ascending_Array_Attribute =>
+            Disp_Parametered_Attribute ("ascending", Expr);
+
+         when Iir_Kind_Image_Attribute =>
+            Disp_Parametered_Attribute ("image", Expr);
+         when Iir_Kind_Simple_Name_Attribute =>
+            Disp_Name_Of (Get_Prefix (Expr));
+            Put ("'simple_name");
+         when Iir_Kind_Instance_Name_Attribute =>
+            Disp_Name_Of (Get_Prefix (Expr));
+            Put ("'instance_name");
+         when Iir_Kind_Path_Name_Attribute =>
+            Disp_Name_Of (Get_Prefix (Expr));
+            Put ("'path_name");
+
+         when Iir_Kind_Selected_By_All_Name =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("");
+            return;
+         when Iir_Kind_Selected_Name =>
+            Disp_Expression (Get_Named_Entity (Expr));
+
+         when Iir_Kinds_Type_And_Subtype_Definition =>
+            Disp_Type (Expr);
+
+         when Iir_Kind_Proxy =>
+            Disp_Expression (Get_Proxy (Expr));
+
+         when Iir_Kind_Range_Expression =>
+            Disp_Range (Expr);
+         when Iir_Kind_Subtype_Declaration =>
+            Disp_Name_Of (Expr);
+
+         when others =>
+            Error_Kind ("disp_expression", Expr);
+      end case;
+   end Disp_Expression;
+
+   procedure Disp_PSL_HDL_Expr (N : PSL.Nodes.HDL_Node) is
+   begin
+      Disp_Expression (Iir (N));
+   end Disp_PSL_HDL_Expr;
+
+   procedure Disp_Psl_Expression (Expr : PSL_Node) is
+   begin
+      PSL.Prints.HDL_Expr_Printer := Disp_PSL_HDL_Expr'Access;
+      PSL.Prints.Print_Property (Expr);
+   end Disp_Psl_Expression;
+
+   procedure Disp_Block_Header (Header : Iir_Block_Header; Indent: Count)
+   is
+      Chain : Iir;
+   begin
+      if Header = Null_Iir then
+         return;
+      end if;
+      Chain := Get_Generic_Chain (Header);
+      if Chain /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Generics (Header);
+         Chain := Get_Generic_Map_Aspect_Chain (Header);
+         if Chain /= Null_Iir then
+            Set_Col (Indent + Indentation);
+            Disp_Generic_Map_Aspect (Header);
+            Put_Line (";");
+         end if;
+      end if;
+      Chain := Get_Port_Chain (Header);
+      if Chain /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Ports (Header);
+         Chain := Get_Port_Map_Aspect_Chain (Header);
+         if Chain /= Null_Iir then
+            Set_Col (Indent + Indentation);
+            Disp_Port_Map_Aspect (Header);
+            Put_Line (";");
+         end if;
+      end if;
+   end Disp_Block_Header;
+
+   procedure Disp_Block_Statement (Block: Iir_Block_Statement)
+   is
+      Indent: Count;
+      Sensitivity: Iir_List;
+      Guard : Iir_Guard_Signal_Declaration;
+   begin
+      Indent := Col;
+      Disp_Label (Get_Label (Block));
+      Put ("block");
+      Guard := Get_Guard_Decl (Block);
+      if Guard /= Null_Iir then
+         Put (" (");
+         Disp_Expression (Get_Guard_Expression (Guard));
+         Put_Line (")");
+         Sensitivity := Get_Guard_Sensitivity_List (Guard);
+         if Sensitivity /= Null_Iir_List then
+            Set_Col (Indent + Indentation);
+            Put ("-- guard sensitivity list ");
+            Disp_Designator_List (Sensitivity);
+         end if;
+      else
+         New_Line;
+      end if;
+      Disp_Block_Header (Get_Block_Header (Block),
+                         Indent + Indentation);
+      Disp_Declaration_Chain (Block, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (Block, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end;");
+   end Disp_Block_Statement;
+
+   procedure Disp_Generate_Statement (Stmt : Iir_Generate_Statement)
+   is
+      Indent : Count;
+      Scheme : Iir;
+   begin
+      Indent := Col;
+      Disp_Label (Get_Label (Stmt));
+      Scheme := Get_Generation_Scheme (Stmt);
+      case Get_Kind (Scheme) is
+         when Iir_Kind_Iterator_Declaration =>
+            Put ("for ");
+            Disp_Parameter_Specification (Scheme);
+         when others =>
+            Put ("if ");
+            Disp_Expression (Scheme);
+      end case;
+      Put_Line (" generate");
+      Disp_Declaration_Chain (Stmt, Indent);
+      Set_Col (Indent);
+      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (Stmt, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end generate;");
+   end Disp_Generate_Statement;
+
+   procedure Disp_Psl_Default_Clock (Stmt : Iir) is
+   begin
+      Put ("--psl default clock is ");
+      Disp_Psl_Expression (Get_Psl_Boolean (Stmt));
+      Put_Line (";");
+   end Disp_Psl_Default_Clock;
+
+   procedure Disp_Psl_Assert_Statement (Stmt : Iir)
+   is
+      use PSL.NFAs;
+      use PSL.Nodes;
+
+      procedure Disp_State (S : NFA_State) is
+         Str : constant String := Int32'Image (Get_State_Label (S));
+      begin
+         Put (Str (2 .. Str'Last));
+      end Disp_State;
+
+      N : NFA;
+      S : NFA_State;
+      E : NFA_Edge;
+   begin
+      Put ("--psl assert ");
+      Disp_Psl_Expression (Get_Psl_Property (Stmt));
+      Put_Line (";");
+      N := Get_PSL_NFA (Stmt);
+      if True and then N /= No_NFA then
+         S := Get_First_State (N);
+         while S /= No_State loop
+            E := Get_First_Src_Edge (S);
+            while E /= No_Edge loop
+               Put ("-- ");
+               Disp_State (S);
+               Put (" -> ");
+               Disp_State (Get_Edge_Dest (E));
+               Put (": ");
+               Disp_Psl_Expression (Get_Edge_Expr (E));
+               New_Line;
+               E := Get_Next_Src_Edge (E);
+            end loop;
+            S := Get_Next_State (S);
+         end loop;
+      end if;
+   end Disp_Psl_Assert_Statement;
+
+   procedure Disp_Concurrent_Statement (Stmt: Iir) is
+   begin
+      case Get_Kind (Stmt) is
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            Disp_Concurrent_Conditional_Signal_Assignment (Stmt);
+         when Iir_Kind_Concurrent_Selected_Signal_Assignment =>
+            Disp_Concurrent_Selected_Signal_Assignment (Stmt);
+         when Iir_Kind_Sensitized_Process_Statement
+           | Iir_Kind_Process_Statement =>
+            Disp_Process_Statement (Stmt);
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            Disp_Assertion_Statement (Stmt);
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Component_Instantiation_Statement (Stmt);
+         when Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            Disp_Procedure_Call (Get_Procedure_Call (Stmt));
+         when Iir_Kind_Block_Statement =>
+            Disp_Block_Statement (Stmt);
+         when Iir_Kind_Generate_Statement =>
+            Disp_Generate_Statement (Stmt);
+         when Iir_Kind_Psl_Default_Clock =>
+            Disp_Psl_Default_Clock (Stmt);
+         when Iir_Kind_Psl_Assert_Statement =>
+            Disp_Psl_Assert_Statement (Stmt);
+         when others =>
+            Error_Kind ("disp_concurrent_statement", Stmt);
+      end case;
+   end Disp_Concurrent_Statement;
+
+   procedure Disp_Package_Declaration (Decl: Iir_Package_Declaration) is
+   begin
+      Put ("package ");
+      Disp_Identifier (Decl);
+      Put_Line (" is");
+      Disp_Declaration_Chain (Decl, Col + Indentation);
+      Put_Line ("end;");
+   end Disp_Package_Declaration;
+
+   procedure Disp_Package_Body (Decl: Iir)
+   is
+   begin
+      Put ("package body ");
+      Disp_Identifier (Decl);
+      Put_Line (" is");
+      Disp_Declaration_Chain (Decl, Col + Indentation);
+      Put_Line ("end;");
+   end Disp_Package_Body;
+
+   procedure Disp_Binding_Indication (Bind : Iir; Indent : Count)
+   is
+      El : Iir;
+   begin
+      El := Get_Entity_Aspect (Bind);
+      if El /= Null_Iir then
+         Set_Col (Indent);
+         Put ("use ");
+         Disp_Entity_Aspect (El);
+      end if;
+      El := Get_Generic_Map_Aspect_Chain (Bind);
+      if El /= Null_Iir then
+         Set_Col (Indent);
+         Disp_Generic_Map_Aspect (Bind);
+      end if;
+      El := Get_Port_Map_Aspect_Chain (Bind);
+      if El /= Null_Iir then
+         Set_Col (Indent);
+         Disp_Port_Map_Aspect (Bind);
+      end if;
+   end Disp_Binding_Indication;
+
+   procedure Disp_Component_Configuration
+     (Conf : Iir_Component_Configuration; Indent : Count)
+   is
+      Block : Iir_Block_Configuration;
+      Binding : Iir;
+   begin
+      Set_Col (Indent);
+      Put ("for ");
+      Disp_Instantiation_List (Get_Instantiation_List (Conf));
+      Put(" : ");
+      Disp_Name_Of (Get_Component_Name (Conf));
+      New_Line;
+      Binding := Get_Binding_Indication (Conf);
+      if Binding /= Null_Iir then
+         Disp_Binding_Indication (Binding, Indent + Indentation);
+      end if;
+      Block := Get_Block_Configuration (Conf);
+      if Block /= Null_Iir then
+         Disp_Block_Configuration (Block, Indent + Indentation);
+      end if;
+      Set_Col (Indent);
+      Put_Line ("end for;");
+   end Disp_Component_Configuration;
+
+   procedure Disp_Configuration_Items
+     (Conf : Iir_Block_Configuration; Indent : Count)
+   is
+      El : Iir;
+   begin
+      El := Get_Configuration_Item_Chain (Conf);
+      while El /= Null_Iir loop
+         case Get_Kind (El) is
+            when Iir_Kind_Block_Configuration =>
+               Disp_Block_Configuration (El, Indent);
+            when Iir_Kind_Component_Configuration =>
+               Disp_Component_Configuration (El, Indent);
+            when Iir_Kind_Configuration_Specification =>
+               --  This may be created by canon.
+               Set_Col (Indent);
+               Disp_Configuration_Specification (El);
+               Set_Col (Indent);
+               Put_Line ("end for;");
+            when others =>
+               Error_Kind ("disp_configuration_item_list", El);
+         end case;
+         El := Get_Chain (El);
+      end loop;
+   end Disp_Configuration_Items;
+
+   procedure Disp_Block_Configuration
+     (Block: Iir_Block_Configuration; Indent: Count)
+   is
+      Spec : Iir;
+   begin
+      Set_Col (Indent);
+      Put ("for ");
+      Spec := Get_Block_Specification (Block);
+      case Get_Kind (Spec) is
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement
+           | Iir_Kind_Architecture_Declaration =>
+            Disp_Name_Of (Spec);
+         when Iir_Kind_Indexed_Name =>
+            Disp_Name_Of (Get_Prefix (Spec));
+            Put (" (");
+            Disp_Expression (Get_First_Element (Get_Index_List (Spec)));
+            Put (")");
+         when Iir_Kind_Selected_Name =>
+            Disp_Name_Of (Get_Prefix (Spec));
+            Put (" (");
+            Put (Iirs_Utils.Image_Identifier (Spec));
+            Put (")");
+         when Iir_Kind_Slice_Name =>
+            Disp_Name_Of (Get_Prefix (Spec));
+            Put (" (");
+            Disp_Range (Get_Suffix (Spec));
+            Put (")");
+         when others =>
+            Error_Kind ("disp_block_configuration", Spec);
+      end case;
+      New_Line;
+      Disp_Declaration_Chain (Block, Indent + Indentation);
+      Disp_Configuration_Items (Block, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end for;");
+   end Disp_Block_Configuration;
+
+   procedure Disp_Configuration_Declaration
+     (Decl: Iir_Configuration_Declaration)
+   is
+   begin
+      Put ("configuration ");
+      Disp_Name_Of (Decl);
+      Put (" of ");
+      Disp_Name_Of (Get_Entity (Decl));
+      Put_Line (" is");
+      Disp_Declaration_Chain (Decl, Col);
+      Disp_Block_Configuration (Get_Block_Configuration (Decl),
+                                Col + Indentation);
+      Put_Line ("end;");
+   end Disp_Configuration_Declaration;
+
+   procedure Disp_Design_Unit (Unit: Iir_Design_Unit)
+   is
+      Decl: Iir;
+      Indent: Count;
+   begin
+      Indent := Col;
+      Decl := Get_Context_Items (Unit);
+      while Decl /= Null_Iir loop
+         Set_Col (Indent);
+         case Get_Kind (Decl) is
+            when Iir_Kind_Use_Clause =>
+               Disp_Use_Clause (Decl);
+            when Iir_Kind_Library_Clause =>
+               Put ("library ");
+               Disp_Identifier (Decl);
+               Put_Line (";");
+            when others =>
+               Error_Kind ("disp_design_unit1", Decl);
+         end case;
+         Decl := Get_Chain (Decl);
+      end loop;
+
+      Decl := Get_Library_Unit (Unit);
+      Set_Col (Indent);
+      case Get_Kind (Decl) is
+         when Iir_Kind_Entity_Declaration =>
+            Disp_Entity_Declaration (Decl);
+         when Iir_Kind_Architecture_Declaration =>
+            Disp_Architecture_Declaration (Decl);
+         when Iir_Kind_Package_Declaration =>
+            Disp_Package_Declaration (Decl);
+         when Iir_Kind_Package_Body =>
+            Disp_Package_Body (Decl);
+         when Iir_Kind_Configuration_Declaration =>
+            Disp_Configuration_Declaration (Decl);
+         when others =>
+            Error_Kind ("disp_design_unit2", Decl);
+      end case;
+      New_Line (2);
+   end Disp_Design_Unit;
+
+   procedure Disp_Vhdl (An_Iir: Iir) is
+   begin
+      Set_Line_Length (80);
+      -- Put (Count'Image (Line_Length));
+      case Get_Kind (An_Iir) is
+         when Iir_Kind_Design_Unit =>
+            Disp_Design_Unit (An_Iir);
+         when Iir_Kind_Character_Literal =>
+            Disp_Character_Literal (An_Iir);
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Enumeration_Type_Definition (An_Iir);
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            Disp_Enumeration_Subtype_Definition (An_Iir);
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            Disp_Concurrent_Conditional_Signal_Assignment (An_Iir);
+         when Iir_Kinds_Dyadic_Operator =>
+            Disp_Dyadic_Operator (An_Iir);
+         when Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Object_Alias_Declaration =>
+            Disp_Name_Of (An_Iir);
+         when Iir_Kind_Enumeration_Literal =>
+            Disp_Identifier (An_Iir);
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Component_Instantiation_Statement (An_Iir);
+         when Iir_Kind_Integer_Subtype_Definition =>
+            Disp_Integer_Subtype_Definition (An_Iir);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Subtype_Definition (An_Iir);
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Type_Definition (An_Iir);
+         when Iir_Kind_Package_Declaration =>
+            Disp_Package_Declaration (An_Iir);
+         when Iir_Kind_Wait_Statement =>
+            Disp_Wait_Statement (An_Iir);
+         when Iir_Kind_Selected_Name
+           | Iir_Kind_Selected_Element
+           | Iir_Kind_Indexed_Name
+           | Iir_Kind_Slice_Name =>
+            Disp_Expression (An_Iir);
+         when others =>
+            Error_Kind ("disp", An_Iir);
+      end case;
+   end Disp_Vhdl;
+
+   procedure Disp_Int64 (Val: Iir_Int64)
+   is
+      Str: constant String := Iir_Int64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         Put (Str (Str'First + 1 .. Str'Last));
+      else
+         Put (Str);
+      end if;
+   end Disp_Int64;
+
+   procedure Disp_Int32 (Val: Iir_Int32)
+   is
+      Str: constant String := Iir_Int32'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         Put (Str (Str'First + 1 .. Str'Last));
+      else
+         Put (Str);
+      end if;
+   end Disp_Int32;
+
+   procedure Disp_Fp64 (Val: Iir_Fp64)
+   is
+      Str: constant String := Iir_Fp64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         Put (Str (Str'First + 1 .. Str'Last));
+      else
+         Put (Str);
+      end if;
+   end Disp_Fp64;
+end Disp_Vhdl;
+
+
+VHDLEND
--- ghdl-r150-ori/disp_vhdl_template.adb	2013-07-10 13:07:31.000000000 +0200
+++ ghdl-r150/disp_vhdl_template.adb	2013-07-10 13:26:01.000000000 +0200
@@ -0,0 +1,2793 @@
+--  VHDL regeneration from internal nodes.
+--  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GHDL; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+
+
+-- Disp an iir tree.
+-- Try to be as pretty as possible, and to keep line numbers and positions
+-- of the identifiers.
+with Ada.Text_IO; use Ada.Text_IO;
+with Std_Package;
+with Flags; use Flags;
+with Errorout; use Errorout;
+with Iirs_Utils; use Iirs_Utils;
+with Types; use Types;
+with Name_Table;
+with Std_Names;
+with Tokens;
+with PSL.Nodes;
+--with PSL.Prints;
+with PSL.NFAs;
+
+package body disp_xml_vhdl is
+
+   --  Disp the name of DECL.
+   procedure Disp_Name_Of (Decl: Iir);
+
+   Indentation: constant Count := 2;
+
+   -- If set, disp after a string literal the type enclosed into brackets.
+   Disp_String_Literal_Type: constant Boolean := False;
+
+   -- If set, disp position number of associations
+   --Disp_Position_Number: constant Boolean := False;
+
+--    procedure Disp_Tab (Tab: Natural) is
+--       Blanks : String (1 .. Tab) := (others => ' ');
+--    begin
+--       Put (Blanks);
+--    end Disp_Tab;
+
+   procedure Disp_Type (A_Type: Iir);
+
+   procedure Disp_Expression (Expr: Iir);
+   procedure Disp_Concurrent_Statement (Stmt: Iir);
+   procedure Disp_Concurrent_Statement_Chain
+      (Parent: Iir; Indent : Count);
+   procedure Disp_Declaration_Chain
+     (Parent : Iir; Indent: Count);
+   procedure Disp_Process_Statement (Process: Iir);
+   procedure Disp_Sequential_Statements (First : Iir);
+   procedure Disp_Choice (Choice: in out Iir);
+   procedure Disp_Association_Chain (Chain : Iir);
+   procedure Disp_Block_Configuration
+     (Block: Iir_Block_Configuration; Indent: Count);
+   procedure Disp_Subprogram_Declaration (Subprg: Iir);
+   procedure Disp_Binding_Indication
+     (Bind : Iir; Indent : Count);
+   procedure Disp_Subtype_Indication (Def : Iir;
+                                      Full_Decl : Boolean := False);
+   procedure Disp_Int64 (Val: Iir_Int64);
+   --procedure Disp_Int32 (Val: Iir_Int32);
+   procedure Disp_Fp64 (Val: Iir_Fp64);
+
+   procedure ChangeTag (E: X; Tree : in Iir) is
+   begin
+      case Get_Kind (Tree) is
+@typ@
+      end case;
+   end ChangeTag;
+
+   ------------- str -----------
+   procedure SetId (Nxml:X;Node:Iir) is
+      Res : String (1 .. 10);
+      Hex_Digits : constant array (Int32 range 0 .. 15) of Character
+        := "0123456789abcdef";
+      N : Int32 := Int32 (Node);
+      pragma Unreferenced (Res);
+   begin
+      for I in reverse 2 .. 9 loop
+         Res (I) := Hex_Digits (N mod 16);
+         N := N / 16;
+      end loop;
+      Res (1) := '[';
+      Res (10) := ']';
+      AddAttr(Nxml,+"iir",+(Integer'Image(Integer(Node)))); --Res
+      if Node /= 0 then
+         if  Get_Location (Node) /= Location_Nil then
+            AddAttr(Nxml,+"loc",
+            + Errorout.Get_Location_Str (Get_Location (Node)));
+         end if;
+      end if;
+   end SetId;
+
+   function Str_Ident (Id: Name_Id) return U_String is
+   begin
+      return +(Name_Table.Image (Id));
+   end Str_Ident;
+
+   function Str_Identifier (Node : Iir) return U_String is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Identifier (Node);
+      if Ident /= Null_Identifier then
+         return Str_Ident (Ident);
+      else
+         return +("<anonymous>");
+      end if;
+   end Str_Identifier;
+
+   function Str_Label (Node : Iir) return U_String is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Label (Node);
+      if Ident /= Null_Identifier then
+         return Str_Ident (Ident);
+      else
+         return + ("<anonymous>");
+      end if;
+   end Str_Label;
+
+   function Str_Entity_Kind (Tok : Tokens.Token_Type) return U_String is
+   begin
+      return + (Tokens.Image (Tok));
+   end Str_Entity_Kind;
+
+   function Str_Character_Literal(
+             Lit: Iir_Character_Literal) return U_String is
+   begin
+      return + (''' & Name_Table.Get_Character (Get_Identifier (Lit)) & ''');
+   end Str_Character_Literal;
+   pragma Unreferenced (Str_Character_Literal);
+
+   function Str_Function_Name (Func: Iir) return U_String is
+      use Name_Table;
+      use Std_Names;
+      Id: Name_Id;
+   begin
+      Id := Get_Identifier (Func);
+      case Id is
+         when Name_Id_Operators
+           | Name_Word_Operators
+           | Name_Xnor
+           | Name_Shift_Operators =>
+            return +("""" & Image (Id) & """");
+         when others =>
+            return Str_Ident (Id);
+      end case;
+   end Str_Function_Name;
+
+   --  Disp the name of DECL.
+   function Str_Name_Of (Decl: Iir) return U_String is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Component_Declaration
+           | Iir_Kind_Entity_Declaration
+           | Iir_Kind_Architecture_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Configuration_Declaration
+           | Iir_Kind_Type_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_Subtype_Declaration
+           | Iir_Kind_Element_Declaration
+           | Iir_Kind_Record_Element_Constraint
+           | Iir_Kind_Package_Declaration
+           | Iir_Kind_Object_Alias_Declaration
+           | Iir_Kind_Non_Object_Alias_Declaration
+           | Iir_Kind_Iterator_Declaration
+           | Iir_Kind_Library_Declaration
+           | Iir_Kind_Unit_Declaration =>
+            return Str_Identifier (Decl);
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            return ((+'<') & Str_Ident (Get_Identifier (Decl)) & (+'>'));
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            return Str_Function_Name (Decl);
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            return Str_Identifier (Decl);
+         when Iir_Kind_Physical_Subtype_Definition
+           | Iir_Kind_Enumeration_Type_Definition =>
+            return Str_Identifier (Get_Type_Declarator (Decl));
+         when Iir_Kind_Component_Instantiation_Statement =>
+            return Str_Ident (Get_Label (Decl));
+         when Iir_Kind_Design_Unit =>
+            return Str_Name_Of (Get_Library_Unit (Decl));
+         when Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Simple_Name =>
+            return Str_Identifier (Decl);
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement =>
+            return Str_Label (Decl);
+         when others =>
+            Error_Kind ("disp_name_of", Decl);
+            return +("<error>");
+      end case;
+   end Str_Name_Of;
+
+   function Str_Name (Name: Iir) return U_String is
+   begin
+      case Get_Kind (Name) is
+         when Iir_Kind_Selected_By_All_Name =>
+            return (Str_Name (Get_Prefix (Name)) & (+".all"));
+         when Iir_Kind_Dereference =>
+            return (Str_Name (Get_Prefix (Name)) & (+".all")) ;
+         when Iir_Kind_Simple_Name =>
+            return +(Iirs_Utils.Image_Identifier (Name));
+         when Iir_Kind_Selected_Name =>
+            return (Str_Name (Get_Prefix (Name)) & (+".")
+            & Str_Ident (Get_Suffix_Identifier (Name)));
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Implicit_Function_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Function_Declaration
+           | Iir_Kind_Procedure_Declaration =>
+            return Str_Name_Of (Name);
+         when others =>
+            Error_Kind ("disp_name", Name);
+            return +("<error>");
+      end case;
+   end Str_Name;
+
+   function Str_Mode (Mode: Iir_Mode) return U_String is
+   begin
+      case Mode is
+         when Iir_In_Mode =>
+            return +("in ");
+         when Iir_Out_Mode =>
+            return +("out ");
+         when Iir_Inout_Mode =>
+            return +("inout ");
+         when Iir_Buffer_Mode =>
+            return +("buffer ");
+         when Iir_Linkage_Mode =>
+            return +("linkage ");
+         when Iir_Unknown_Mode =>
+            return +("<unknown> ");
+      end case;
+   end Str_Mode;
+
+   function Str_Signal_Kind (Kind: Iir_Signal_Kind) return U_String is
+   begin
+      case Kind is
+         when Iir_No_Signal_Kind =>
+            return +("");
+         when Iir_Register_Kind =>
+            return +(" register");
+         when Iir_Bus_Kind =>
+            return +(" bus");
+      end case;
+   end Str_Signal_Kind;
+
+   function Str_String_Literal (Str : Iir) return U_String is
+      Ptr : String_Fat_Acc;
+      Len : Int32;
+   begin
+      Ptr := Get_String_Fat_Acc (Str);
+      Len := Get_String_Length (Str);
+      return + (String (Ptr (1 .. Len)));
+   end Str_String_Literal;
+
+   function Str_Int64 (Val: Iir_Int64) return U_String is
+      Str: constant String := Iir_Int64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         return + (Str (Str'First + 1 .. Str'Last));
+      else
+         return + (Str);
+      end if;
+   end Str_Int64;
+
+   function Str_Fp64 (Val: Iir_Fp64) return U_String is
+      Str: constant String := Iir_Fp64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         return + (Str (Str'First + 1 .. Str'Last));
+      else
+         return + (Str);
+      end if;
+   end Str_Fp64;
+
+   -- pragma Unreferenced (Str_Signal_Kind);
+   ------------- /str -----------
+
+
+   procedure Disp_Ident (Id: Name_Id) is
+   begin
+      Put (Name_Table.Image (Id) );
+   end Disp_Ident;
+
+   procedure Disp_Identifier (Node : Iir) is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Identifier (Node);
+      if Ident /= Null_Identifier then
+         Disp_Ident (Ident);
+      else
+         Put ("<anonymous>");
+      end if;
+   end Disp_Identifier;
+
+   procedure Disp_Label (Node : Iir) is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Label (Node);
+      if Ident /= Null_Identifier then
+         Disp_Ident (Ident);
+      else
+         Put ("<anonymous>");
+      end if;
+   end Disp_Label;
+
+   procedure Disp_Character_Literal (Lit: Iir_Character_Literal) is
+   begin
+      Put (''' & Name_Table.Get_Character (Get_Identifier (Lit)) & ''');
+   end Disp_Character_Literal;
+
+   procedure Disp_Function_Name (Func: Iir)
+   is
+      use Name_Table;
+      use Std_Names;
+      Id: Name_Id;
+   begin
+      Id := Get_Identifier (Func);
+      case Id is
+         when Name_Id_Operators
+           | Name_Word_Operators
+           | Name_Xnor
+           | Name_Shift_Operators =>
+            Put ("""");
+            Put (Image (Id));
+            Put ("""");
+         when others =>
+            Disp_Ident (Id);
+      end case;
+   end Disp_Function_Name;
+
+   --  Disp the name of DECL.
+   procedure Disp_Name_Of (Decl: Iir) is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Component_Declaration
+           | Iir_Kind_Entity_Declaration
+           | Iir_Kind_Architecture_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Configuration_Declaration
+           | Iir_Kind_Type_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_Subtype_Declaration
+           | Iir_Kind_Element_Declaration
+           | Iir_Kind_Record_Element_Constraint
+           | Iir_Kind_Package_Declaration
+           | Iir_Kind_Object_Alias_Declaration
+           | Iir_Kind_Non_Object_Alias_Declaration
+           | Iir_Kind_Iterator_Declaration
+           | Iir_Kind_Library_Declaration
+           | Iir_Kind_Unit_Declaration =>
+            Disp_Identifier (Decl);
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            Put ('<');
+            Disp_Ident (Get_Identifier (Decl));
+            Put ('>');
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            Disp_Function_Name (Decl);
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            Disp_Identifier (Decl);
+         when Iir_Kind_Physical_Subtype_Definition
+           | Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Identifier (Get_Type_Declarator (Decl));
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Ident (Get_Label (Decl));
+         when Iir_Kind_Design_Unit =>
+            Disp_Name_Of (Get_Library_Unit (Decl));
+         when Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Simple_Name =>
+            Disp_Identifier (Decl);
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement =>
+            Disp_Label (Decl);
+         when others =>
+            Error_Kind ("disp_name_of", Decl);
+      end case;
+   end Disp_Name_Of;
+
+
+   procedure Disp_Range (Decl: Iir) is
+   begin
+      if Get_Kind (Decl) = Iir_Kind_Range_Expression then
+         Disp_Expression (Get_Left_Limit (Decl)); -- p:l
+         if Get_Direction (Decl) = Iir_To then
+            Put (" to "); -- f:dir
+         else
+            Put (" downto "); -- f:dir
+         end if;
+         Disp_Expression (Get_Right_Limit (Decl)); -- p:r
+      else
+         if (Get_Kind(Decl) = Iir_Kind_Range_Array_Attribute) then
+            Disp_Expression(Get_Prefix(Decl)); -- p:prefix
+            Put ("'range "); -- f:typ
+         else
+            Disp_Subtype_Indication (Decl); -- reent:1
+         end if;
+         -- Disp_Subtype_Indication (Decl);
+         --  Disp_Name_Of (Get_Type_Declarator (Decl));
+      end if;
+   end Disp_Range;
+
+   procedure Disp_Name (Name: Iir) is
+   begin
+      case Get_Kind (Name) is
+         when Iir_Kind_Selected_By_All_Name =>
+            Disp_Name (Get_Prefix (Name));
+            Put (".all");
+         when Iir_Kind_Dereference =>
+            Disp_Name (Get_Prefix (Name));
+            Put (".all");
+         when Iir_Kind_Simple_Name =>
+            Put (Iirs_Utils.Image_Identifier (Name));
+         when Iir_Kind_Selected_Name =>
+            Disp_Name (Get_Prefix (Name));
+            Put (".");
+            Disp_Ident (Get_Suffix_Identifier (Name));
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Implicit_Function_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Function_Declaration
+           | Iir_Kind_Procedure_Declaration =>
+            Disp_Name_Of (Name);
+         when others =>
+            Error_Kind ("disp_name", Name);
+      end case;
+   end Disp_Name;
+
+   procedure Disp_Use_Clause (Clause: Iir_Use_Clause) is
+   begin
+      Put ("use ");
+      Disp_Name (Get_Selected_Name (Clause)); -- f:n
+      Put_Line (";");
+   end Disp_Use_Clause;
+
+   -- Disp the resolution function (if any) of type definition DEF.
+   procedure Disp_Resolution_Function (Subtype_Def: Iir)
+   is
+      procedure Inner (P:X;Pos:U_String;Def : Iir)
+      is
+         Decl: Iir;
+         N: constant X := X(Create_Xml_Node_Pretty(P,Pos));
+      begin
+         if Get_Kind (Def) in Iir_Kinds_Subtype_Definition then
+            Decl := Get_Resolution_Function (Def);
+            if Decl /= Null_Iir then
+               Disp_Name (Decl); -- f:n
+            else
+               case Get_Kind (Def) is
+                  when Iir_Kind_Array_Subtype_Definition =>
+                     Put ('(');
+                     Inner (N,+"inner",Get_Element_Subtype (Def));
+                     Put (')');
+                  when others =>
+                     Error_Kind ("disp_resolution_function", Def);
+               end case;
+            end if;
+         end if;
+      end Inner;
+
+   begin
+      if Get_Resolved_Flag (Subtype_Def) then
+         Inner (N,+"inner",Subtype_Def);
+         Put (' ');
+      end if;
+   end Disp_Resolution_Function;
+
+   procedure Disp_Integer_Subtype_Definition
+     (Def: Iir_Integer_Subtype_Definition)
+   is
+      Base_Type: Iir_Integer_Type_Definition;
+      Decl: Iir;
+   begin
+      if Def /= Std_Package.Universal_Integer_Subtype_Definition then
+         Base_Type := Get_Base_Type (Def);
+         Decl := Get_Type_Declarator (Base_Type);
+         if Base_Type /= Std_Package.Universal_Integer_Subtype_Definition
+           and then Def /= Decl
+         then
+            Disp_Name_Of (Decl); -- f:n
+            Put (" ");
+         end if;
+      end if;
+      Disp_Resolution_Function (Def);
+      Put ("range ");
+      Disp_Expression (Get_Range_Constraint (Def));
+      Put (";");
+   end Disp_Integer_Subtype_Definition;
+
+   procedure Disp_Floating_Subtype_Definition
+     (Def: Iir_Floating_Subtype_Definition)
+   is
+      Base_Type: Iir_Floating_Type_Definition;
+      Decl: Iir;
+   begin
+      if Def /= Std_Package.Universal_Real_Subtype_Definition then
+         Base_Type := Get_Base_Type (Def);
+         Decl := Get_Type_Declarator (Base_Type);
+         if Base_Type /= Std_Package.Universal_Real_Subtype_Definition
+           and then Def /= Decl
+         then
+            Disp_Name_Of (Decl); -- f:n
+            Put (" ");
+         end if;
+      end if;
+      Disp_Resolution_Function (Def); --p:res
+      Put ("range ");
+      Disp_Expression (Get_Range_Constraint (Def)); --p:range
+      Put (";");
+   end Disp_Floating_Subtype_Definition;
+
+   procedure Disp_Element_Constraint
+     (Def : Iir; Type_Mark : Iir);
+
+   procedure Disp_Array_Element_Constraint (Def : Iir; Type_Mark : Iir)
+   is
+      Index : Iir;
+      Def_El : Iir;
+      Tm_El : Iir;
+      Has_Index : Boolean;
+      Has_Own_Element_Subtype : Boolean;
+      Ec : X;
+   begin
+      Has_Index := Get_Index_Constraint_Flag (Def);
+      Def_El := Get_Element_Subtype (Def);
+      Tm_El := Get_Element_Subtype (Type_Mark);
+      Has_Own_Element_Subtype := Def_El /= Tm_El;
+
+      if not Has_Index and not Has_Own_Element_Subtype then
+         return;
+      end if;
+
+      Put (" (");
+      if Has_Index then
+         for I in Natural loop  -- chain:[v=Ec|n=arrrange]
+            Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+            exit when Index = Null_Iir; --exitchain:Ec
+            if I /= 0 then
+               Put (", ");
+            end if;
+            Disp_Range (Index); -- p:range
+         end loop;
+      else
+         Put ("open");
+      end if;
+      Put (")");
+
+      if Has_Own_Element_Subtype
+        and then Get_Kind (Def_El) in Iir_Kinds_Composite_Type_Definition
+      then
+         Put ("ownsubtype"); --f:ownsubtype
+         Disp_Element_Constraint (Def_El, Tm_El); --reent:1
+      end if;
+   end Disp_Array_Element_Constraint;
+
+   procedure Disp_Record_Element_Constraint (Def : Iir)
+   is
+      El_List : constant Iir_List := Get_Elements_Declaration_List (Def);
+      El : Iir;
+      Has_El : Boolean := False;
+      Ec : X;
+   begin
+      for I in Natural loop -- chain:[v=Ec|n=Enumeration]
+         El := Get_Nth_Element (El_List, I);
+         exit when El = Null_Iir; --exitchain:Ec
+         if Get_Kind (El) = Iir_Kind_Record_Element_Constraint
+           and then Get_Parent (El) = Def
+         then
+            if Has_El then
+               Put (", ");
+            else
+               Put ("(");
+               Has_El := True;
+            end if;
+            Disp_Name_Of (El); -- f:n
+            Disp_Element_Constraint (Get_Type (El),
+                                     Get_Base_Type (Get_Type (El)));
+         end if;
+      end loop;
+      if Has_El then
+         Put (")");
+      end if;
+   end Disp_Record_Element_Constraint;
+
+   procedure Disp_Element_Constraint (Def : Iir; Type_Mark : Iir) is
+   begin
+      case Get_Kind (Def) is
+         when Iir_Kind_Record_Subtype_Definition =>
+            Disp_Record_Element_Constraint (Def); --reent:1
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Element_Constraint (Def, Type_Mark); --reent:1
+         when others =>
+            Error_Kind ("disp_element_constraint", Def);
+      end case;
+   end Disp_Element_Constraint;
+
+   procedure Disp_Subtype_Indication (Def : Iir; Full_Decl : Boolean := False)
+   is
+      Type_Mark : Iir;
+      Base_Type : Iir;
+      Decl : Iir;
+   begin
+      Decl := Get_Type_Declarator (Def);
+      if not Full_Decl and then Decl /= Null_Iir then
+         Disp_Name_Of (Decl); -- f:n
+         return;
+      end if;
+
+      -- Resolution function name.
+      Disp_Resolution_Function (Def); -- p:res
+
+      -- type mark.
+      Type_Mark := Get_Type_Mark (Def);
+      if Type_Mark /= Null_Iir then
+         Decl := Get_Type_Declarator (Type_Mark);
+         Disp_Name_Of (Decl); -- f:typmark
+      end if;
+
+      Base_Type := Get_Base_Type (Def);
+      case Get_Kind (Base_Type) is
+         when Iir_Kind_Integer_Type_Definition
+           | Iir_Kind_Enumeration_Type_Definition
+           | Iir_Kind_Floating_Type_Definition
+           | Iir_Kind_Physical_Type_Definition =>
+            if Type_Mark = Null_Iir
+              or else Get_Range_Constraint (Def)
+              /= Get_Range_Constraint (Type_Mark)
+            then
+               if Type_Mark /= Null_Iir then
+                  Put (" range ");
+               end if;
+               Disp_Expression (Get_Range_Constraint (Def));
+            end if;
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Element_Constraint (Def, Type_Mark); -- p:array
+         when Iir_Kind_Record_Type_Definition =>
+            Disp_Record_Element_Constraint (Def); -- p:record
+         when others =>
+            Error_Kind ("disp_subtype_indication", Base_Type);
+      end case;
+   end Disp_Subtype_Indication;
+
+   procedure Disp_Enumeration_Type_Definition
+     (Def: Iir_Enumeration_Type_Definition)
+   is
+      Len : Count;
+      Start_Col: Count;
+      Decl: Name_Id;
+      A_Lit: Iir; --Enumeration_Literal_Acc;
+      pragma Unreferenced (Start_Col);
+      Ec : X;
+   begin
+      for I in Natural loop -- chain:[v=Ec|n=Enumeration]
+         A_Lit := Get_Nth_Element (Get_Enumeration_Literal_List (Def), I);
+         exit when A_Lit = Null_Iir; --exitchain:Ec
+         if I = Natural'first then
+            Put ("(");
+            Start_Col := Col;
+         else
+            Put (", ");
+         end if;
+         Decl := Get_Identifier (A_Lit);
+         if Name_Table.Is_Character (Decl) then
+            Len := 3;
+         else
+            Len := Count (Name_Table.Get_Name_Length (Decl));
+         end if;
+         if Col + Len + 2 > Line_Length then
+            New_Line;
+            Set_Col (Start_Col);
+         end if;
+         Disp_Name_Of (A_Lit); -- f:n
+      end loop;
+      Put (");");
+   end Disp_Enumeration_Type_Definition;
+
+   procedure Disp_Enumeration_Subtype_Definition
+     (Def: Iir_Enumeration_Subtype_Definition)
+   is
+   begin
+      Disp_Resolution_Function (Def);
+      Put ("range ");
+      Disp_Range (Def);
+      Put (";");
+   end Disp_Enumeration_Subtype_Definition;
+
+   procedure Disp_Array_Subtype_Definition
+     (Def: Iir_Array_Subtype_Definition)
+   is
+      Index: Iir;
+      Ec : X;
+   begin
+      Disp_Resolution_Function (Def);
+
+      Put ("array (");
+      for I in Natural loop -- chain:[v=Ec|n=arrrange]
+         Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+         exit when Index = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Subtype_Indication (Index); --p:range
+      end loop;
+      Put (") of ");
+      Disp_Subtype_Indication (Get_Element_Subtype (Def)); --p:typ
+   end Disp_Array_Subtype_Definition;
+
+   procedure Disp_Array_Type_Definition (Def: Iir_Array_Type_Definition) is
+      Index: Iir;
+      Ec : X;
+   begin
+      Put ("array (");
+      for I in Natural loop -- chain:[v=Ec|n=arrrange]
+         Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+         exit when Index = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Subtype_Indication (Index); --p:range
+         Put (" range <>");
+      end loop;
+      Put (") of ");
+      Disp_Type (Get_Element_Subtype (Def)); --p:typ
+      Put (";");
+   end Disp_Array_Type_Definition;
+
+   procedure Disp_Physical_Literal (Lit: Iir) is
+   begin
+      case Get_Kind (Lit) is
+         when Iir_Kind_Physical_Int_Literal =>
+            Disp_Int64 (Get_Value (Lit)); -- f:v
+         when Iir_Kind_Physical_Fp_Literal =>
+            Disp_Fp64 (Get_Fp_Value (Lit)); -- f:v
+         when others =>
+            Error_Kind ("disp_physical_literal", Lit);
+      end case;
+      Put (' ');
+      Disp_Identifier (Get_Unit_Name (Lit)); -- f:unit
+   end Disp_Physical_Literal;
+
+   procedure Disp_Physical_Subtype_Definition
+     (Def: Iir_Physical_Subtype_Definition; Indent: Count)
+   is
+      Base_Type: Iir;
+      Unit: Iir_Unit_Declaration;
+      Ec : X;
+      pragma Unreferenced (Indent);
+   begin
+      Disp_Resolution_Function (Def);
+      Put ("range ");
+      Disp_Expression (Get_Range_Constraint (Def));
+      Base_Type := Get_Base_Type (Def);
+      if Get_Type_Declarator (Base_Type) = Get_Type_Declarator (Def) then
+         Put_Line (" units");
+         Set_Col (Indent + Indentation);
+         Unit := Get_Unit_Chain (Base_Type);
+         Disp_Identifier (Unit); -- f:nunit
+         Put_Line (";");
+         Unit := Get_Chain (Unit);
+         while Unit /= Null_Iir loop -- chain:[v=Ec|n=unit]
+            Set_Col (Indent + Indentation);
+            Disp_Identifier (Unit); -- f:n
+            Put (" = ");
+            Disp_Physical_Literal (Get_Physical_Literal (Unit));
+            Put_Line (";");
+            Unit := Get_Chain (Unit);
+         end loop;
+         Set_Col (Indent);
+         Put ("end units;");
+      end if;
+   end Disp_Physical_Subtype_Definition;
+
+   procedure Disp_Record_Type_Definition
+     (Def: Iir_Record_Type_Definition; Indent: Count)
+   is
+      List : Iir_List;
+      El: Iir_Element_Declaration;
+      pragma Unreferenced (Indent);
+      Ec : X;
+   begin
+      Put_Line ("record");
+      Set_Col (Indent);
+      Put_Line ("begin");
+      List := Get_Elements_Declaration_List (Def);
+      for I in Natural loop -- chain:[v=Ec|n=entry]
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir; --exitchain:Ec
+         Set_Col (Indent + Indentation);
+         Disp_Identifier (El); -- f:n
+         Put (" : ");
+         Disp_Subtype_Indication (Get_Type (El));
+         Put_Line (";");
+      end loop;
+      Set_Col (Indent);
+      Put ("end record;");
+   end Disp_Record_Type_Definition;
+
+   procedure Disp_Designator_List (List: Iir_List) is
+      El: Iir;
+   begin
+      if List = Null_Iir_List then
+         return;
+      end if;
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         if I > 0 then
+            Put (", ");
+         end if;
+         Disp_Expression (El);
+         --Disp_Text_Literal (El);
+      end loop;
+   end Disp_Designator_List;
+
+   -- Display the full definition of a type, ie the sequence that can create
+   -- such a type.
+   procedure Disp_Type_Definition (Decl: in Iir; Indent: Count) is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Enumeration_Type_Definition (Decl);
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            Disp_Enumeration_Subtype_Definition (Decl);
+         when Iir_Kind_Integer_Subtype_Definition =>
+            Disp_Integer_Subtype_Definition (Decl);
+         when Iir_Kind_Floating_Subtype_Definition =>
+            Disp_Floating_Subtype_Definition (Decl);
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Type_Definition (Decl);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Subtype_Definition (Decl);
+         when Iir_Kind_Physical_Subtype_Definition =>
+            Disp_Physical_Subtype_Definition (Decl, Indent);
+         when Iir_Kind_Record_Type_Definition =>
+            Disp_Record_Type_Definition (Decl, Indent);
+         when Iir_Kind_Access_Type_Definition =>
+            Put ("access"); --f:typ
+            Disp_Subtype_Indication (Get_Designated_Type (Decl));
+            Put (';');
+         when Iir_Kind_File_Type_Definition =>
+            Put ("file of ");
+            Disp_Subtype_Indication (Get_Type_Mark (Decl));
+            Put (';');
+         when Iir_Kind_Protected_Type_Declaration =>
+            Put_Line ("protected");
+            Disp_Declaration_Chain (Decl, Indent + Indentation);
+            Set_Col (Indent);
+            Put ("end protected;");
+         when Iir_Kind_Integer_Type_Definition =>
+            Put ("<integer base type>");
+         when Iir_Kind_Floating_Type_Definition =>
+            Put ("<floating base type>");
+         when Iir_Kind_Physical_Type_Definition =>
+            Put ("<physical base type>");
+         when others =>
+            Error_Kind ("disp_type_definition", Decl);
+      end case;
+   end Disp_Type_Definition;
+
+   procedure Disp_Type_Declaration (Decl: Iir_Type_Declaration)
+   is
+      Indent: Count;
+      Def : Iir;
+   begin
+      Indent := Col;
+      Put ("type ");
+      Disp_Name_Of (Decl); -- f:n
+      Def := Get_Type (Decl);
+      if Def = Null_Iir
+        or else Get_Kind (Def) = Iir_Kind_Incomplete_Type_Definition
+      then
+         Put_Line (";");
+      else
+         Put (" is ");
+         Disp_Type_Definition (Def, Indent);
+         New_Line;
+      end if;
+   end Disp_Type_Declaration;
+
+   procedure Disp_Anonymous_Type_Declaration
+     (Decl: Iir_Anonymous_Type_Declaration)
+   is
+      Indent: Count;
+      Def : Iir;
+      Ec : X;
+   begin
+      Indent := Col;
+      Put ("-- type ");
+      Disp_Name_Of (Decl); -- f:n
+      Put (" is ");
+      Def := Get_Type (Decl);
+      Disp_Type_Definition (Def, Indent);
+      if Get_Kind (Def) = Iir_Kind_Physical_Type_Definition then
+         declare
+            Unit : Iir_Unit_Declaration;
+         begin
+            Put_Line (" units");
+            Set_Col (Indent);
+            Put ("--   ");
+            Unit := Get_Unit_Chain (Def);
+            Disp_Identifier (Unit); -- f:nunit
+            Put_Line (";");
+            Unit := Get_Chain (Unit);
+            while Unit /= Null_Iir loop -- chain:[v=Ec|n=unit]
+               Set_Col (Indent);
+               Put ("--   ");
+               Disp_Identifier (Unit); -- f:n
+               Put (" = ");
+               Disp_Physical_Literal (Get_Physical_Literal (Unit));
+               Put_Line (";");
+               Unit := Get_Chain (Unit);
+            end loop;
+            Set_Col (Indent);
+            Put ("-- end units;");
+         end;
+      end if;
+      New_Line;
+   end Disp_Anonymous_Type_Declaration;
+
+   procedure Disp_Subtype_Declaration (Decl: in Iir_Subtype_Declaration) is
+   begin
+      Put ("subtype ");
+      Disp_Name_Of (Decl); --f:n
+      Put (" is ");
+      Disp_Subtype_Indication (Get_Type (Decl), True);
+      Put_Line (";");
+   end Disp_Subtype_Declaration;
+
+   procedure Disp_Type (A_Type: Iir)
+   is
+      Decl: Iir;
+   begin
+      Decl := Get_Type_Declarator (A_Type);
+      if Decl /= Null_Iir then
+         Disp_Name_Of (Decl); -- f:n
+      else
+         case Get_Kind (A_Type) is
+            when Iir_Kind_Enumeration_Type_Definition
+              | Iir_Kind_Integer_Type_Definition =>
+               raise Program_Error;
+            when Iir_Kind_Integer_Subtype_Definition
+              | Iir_Kind_Enumeration_Subtype_Definition =>
+               Disp_Subtype_Indication (A_Type);
+            when Iir_Kind_Array_Subtype_Definition =>
+               Disp_Subtype_Indication (A_Type);
+            when others =>
+               Error_Kind ("disp_type", A_Type);
+         end case;
+      end if;
+   end Disp_Type;
+
+   procedure Disp_Mode (Mode: Iir_Mode) is
+   begin
+      case Mode is
+         when Iir_In_Mode =>
+            Put ("in ");
+         when Iir_Out_Mode =>
+            Put ("out ");
+         when Iir_Inout_Mode =>
+            Put ("inout ");
+         when Iir_Buffer_Mode =>
+            Put ("buffer ");
+         when Iir_Linkage_Mode =>
+            Put ("linkage ");
+         when Iir_Unknown_Mode =>
+            Put ("<unknown> ");
+      end case;
+   end Disp_Mode;
+   pragma Unreferenced (Disp_Mode);
+
+   procedure Disp_Signal_Kind (Kind: Iir_Signal_Kind) is
+   begin
+      case Kind is
+         when Iir_No_Signal_Kind =>
+            null;
+         when Iir_Register_Kind =>
+            Put (" register");
+         when Iir_Bus_Kind =>
+            Put (" bus");
+      end case;
+   end Disp_Signal_Kind;
+   pragma Unreferenced (Disp_Signal_Kind);
+
+   procedure Disp_Interface_Declaration (Inter: Iir)
+   is
+      Default: Iir;
+   begin
+      case Get_Kind (Inter) is
+         when Iir_Kind_Signal_Interface_Declaration =>
+            Put ("signal ");
+         when Iir_Kind_Variable_Interface_Declaration =>
+            Put ("variable ");
+         when Iir_Kind_Constant_Interface_Declaration =>
+            Put ("constant ");
+         when Iir_Kind_File_Interface_Declaration =>
+            Put ("file ");
+         when others =>
+            Error_Kind ("disp_interface_declaration", Inter);
+      end case;
+      Disp_Name_Of (Inter); -- f:n
+      Put (": ");
+      Disp_Mode (Get_Mode (Inter)); --f:mode
+      Disp_Type (Get_Type (Inter));
+      if Get_Kind (Inter) = Iir_Kind_Signal_Interface_Declaration then
+         Disp_Signal_Kind (Get_Signal_Kind (Inter)); -- f:sigkind
+      end if;
+      Default := Get_Default_Value (Inter);
+      if Default /= Null_Iir then
+         Put (" := ");
+         Disp_Expression (Default);
+      end if;
+   end Disp_Interface_Declaration;
+
+   procedure Disp_Interface_Chain (Chain: Iir; Str: String)
+   is
+      Inter: Iir;
+      Start: Count;
+      pragma Unreferenced (Start);
+      pragma Unreferenced (Str);
+   begin
+      if Chain = Null_Iir then
+         return;
+      end if;
+      Put (" (");
+      Start := Col;
+      Inter := Chain;
+      while Inter /= Null_Iir loop
+         Set_Col (Start);
+         Disp_Interface_Declaration (Inter);
+         if Get_Chain (Inter) /= Null_Iir then
+            Put ("; ");
+         else
+            Put (')');
+            Put (Str); -- nop:1
+         end if;
+         Inter := Get_Chain (Inter);
+      end loop;
+   end Disp_Interface_Chain;
+
+   procedure Disp_Ports (Parent : Iir) is
+   begin
+      Put ("port");
+      Disp_Interface_Chain (Get_Port_Chain (Parent), ";");
+   end Disp_Ports;
+
+   procedure Disp_Generics (Parent : Iir) is
+   begin
+      Put ("generic");
+      Disp_Interface_Chain (Get_Generic_Chain (Parent), ";");
+   end Disp_Generics;
+
+   procedure Disp_Entity_Declaration (Decl: Iir_Entity_Declaration) is
+      Start: Count;
+   begin
+      Start := Col;
+      Put ("entity ");
+      Disp_Name_Of (Decl); --f:n
+      Put_Line (" is");
+      if Get_Generic_Chain (Decl) /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Disp_Generics (Decl);
+      end if;
+      if Get_Port_Chain (Decl) /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Disp_Ports (Decl);
+      end if;
+      Disp_Declaration_Chain (Decl, Start + Indentation);
+      if Get_Concurrent_Statement_Chain (Decl) /= Null_Iir then
+         Set_Col (Start);
+         Put_Line ("begin");
+         Disp_Concurrent_Statement_Chain (Decl, Start + Indentation);
+      end if;
+      Set_Col (Start);
+      Put_Line ("end entity;");
+   end Disp_Entity_Declaration;
+
+   procedure Disp_Component_Declaration (Decl: Iir_Component_Declaration)
+   is
+      Indent: Count;
+      pragma Unreferenced (Indent);
+   begin
+      Indent := Col;
+      Put ("component ");
+      Disp_Name_Of (Decl); -- f:n
+      if Get_Generic_Chain (Decl) /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Generics (Decl);
+      end if;
+      if Get_Port_Chain (Decl) /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Ports (Decl);
+      end if;
+      Set_Col (Indent);
+      Put ("end component;");
+   end Disp_Component_Declaration;
+
+   procedure Disp_Concurrent_Statement_Chain (Parent : Iir; Indent : Count)
+   is
+      El: Iir;
+      pragma Unreferenced (Indent);
+   begin
+      El := Get_Concurrent_Statement_Chain (Parent);
+      while El /= Null_Iir loop
+         Set_Col (Indent);
+         Disp_Concurrent_Statement (El);
+         El := Get_Chain (El);
+      end loop;
+   end Disp_Concurrent_Statement_Chain;
+
+   procedure Disp_Architecture_Declaration (Arch: Iir_Architecture_Declaration)
+   is
+      Start: Count;
+   begin
+      Start := Col;
+      Put ("architecture ");
+      Disp_Name_Of (Arch); -- f:n
+      Put (" of ");
+      Disp_Name_Of (Get_Entity (Arch)); -- f:of
+      Put_Line (" is");
+      Disp_Declaration_Chain (Arch, Start + Indentation);
+      Set_Col (Start);
+      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (Arch, Start + Indentation);
+      Set_Col (Start);
+      Put_Line ("end;");
+   end Disp_Architecture_Declaration;
+
+   procedure Disp_Object_Alias_Declaration (Decl: Iir_Object_Alias_Declaration)
+   is
+   begin
+      Put ("alias ");
+      Disp_Name_Of (Decl); -- f:n
+      Put (": ");
+      Disp_Type (Get_Type (Decl));
+      Put (" is ");
+      Disp_Expression (Get_Name (Decl));
+      Put_Line (";");
+   end Disp_Object_Alias_Declaration;
+
+   procedure Disp_Non_Object_Alias_Declaration
+     (Decl: Iir_Non_Object_Alias_Declaration)
+   is
+   begin
+      Put ("alias ");
+      Disp_Function_Name (Decl); -- f:n
+      Put (" is ");
+      Disp_Name (Get_Name (Decl)); -- f:alias
+      Put_Line (";");
+   end Disp_Non_Object_Alias_Declaration;
+
+   procedure Disp_File_Declaration (Decl: Iir_File_Declaration) is
+      Expr: Iir;
+   begin
+      Put ("file ");
+      Disp_Name_Of (Decl); -- f:n
+      Put (": ");
+      Disp_Type (Get_Type (Decl));
+      if Vhdl_Std = Vhdl_87 then
+         Put (" is ");
+         Disp_Mode (Get_Mode (Decl)); --f:mode
+         Disp_Expression (Get_File_Logical_Name (Decl));
+      else
+         Expr := Get_File_Open_Kind (Decl);
+         if Expr /= Null_Iir then
+            Put (" open ");
+            Disp_Expression (Expr);
+         end if;
+         Expr := Get_File_Logical_Name (Decl);
+         if Expr /= Null_Iir then
+            Put (" is ");
+            Disp_Expression (Expr);
+         end if;
+      end if;
+      Put (';');
+   end Disp_File_Declaration;
+
+   procedure Disp_Object_Declaration (Decl: Iir) is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Variable_Declaration =>
+            if Get_Shared_Flag (Decl) then
+               Put ("shared ");
+            end if;
+            Put ("variable "); --f:typ
+         when Iir_Kind_Constant_Declaration =>
+            Put ("constant "); --f:typ
+         when Iir_Kind_Signal_Declaration =>
+            Put ("signal "); --f:typ
+         when Iir_Kind_Object_Alias_Declaration =>
+            Disp_Object_Alias_Declaration (Decl); --s:[typ=alias]
+            return;
+         when Iir_Kind_File_Declaration =>
+            Disp_File_Declaration (Decl); --s:[typ=file]
+            return;
+         when others =>
+            raise Internal_Error;
+      end case;
+      Disp_Name_Of (Decl); -- f:n
+      Put (": ");
+      Disp_Type (Get_Type (Decl));
+      if Get_Kind (Decl) = Iir_Kind_Signal_Declaration then
+         Disp_Signal_Kind (Get_Signal_Kind (Decl));  -- f:sigkind
+      end if;
+
+      if Get_Default_Value (Decl) /= Null_Iir then
+         Put (" := ");
+         Disp_Expression (Get_Default_Value (Decl));
+      end if;
+      Put_Line (";");
+   end Disp_Object_Declaration;
+
+   procedure Disp_Subprogram_Declaration (Subprg: Iir) is
+   begin
+      case Get_Kind (Subprg) is
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            Put ("function "); --f:typ
+            Disp_Function_Name (Subprg);  -- f:n
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            Put ("procedure "); --f:typ
+            Disp_Identifier (Subprg);  -- f:n
+         when others =>
+            raise Internal_Error;
+      end case;
+
+      Disp_Interface_Chain (Get_Interface_Declaration_Chain (Subprg), "");
+
+      case Get_Kind (Subprg) is
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            Put (" return ");
+            Disp_Type (Get_Return_Type (Subprg)); --p:rtyp
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            null;
+         when others =>
+            raise Internal_Error;
+      end case;
+   end Disp_Subprogram_Declaration;
+
+   procedure Disp_Subprogram_Body (Subprg : Iir)
+   is
+      Decl : Iir;
+      Indent : Count;
+   begin
+      Decl := Get_Subprogram_Specification (Subprg);
+      Indent := Col;
+      if Get_Chain (Decl) /= Subprg then
+         Disp_Subprogram_Declaration (Decl);
+      end if;
+      Put_Line ("is");
+      Set_Col (Indent);
+      Disp_Declaration_Chain (Subprg, Indent + Indentation); -- p:decl
+      Set_Col (Indent);
+      Put_Line ("begin");
+      Set_Col (Indent + Indentation);
+      Disp_Sequential_Statements (Get_Sequential_Statement_Chain (Subprg)); -- p:b
+      Set_Col (Indent);
+      Put_Line ("end;");
+      New_Line;
+   end Disp_Subprogram_Body;
+
+   procedure Disp_Instantiation_List (Insts: Iir_List) is
+      El : Iir;
+      Ec : X;
+   begin
+      if Insts = Iir_List_All then
+         Put ("all"); --f:typ
+      elsif Insts = Iir_List_Others then
+         Put ("others"); --f:typ
+      else
+         for I in Natural loop -- chain:[v=Ec|n=instantiation]
+            El := Get_Nth_Element (Insts, I);
+            exit when El = Null_Iir; --exitchain:Ec
+            if I /= Natural'First then
+               Put (", ");
+            end if;
+            Disp_Name_Of (El); --f:n
+         end loop;
+      end if;
+   end Disp_Instantiation_List;
+
+   procedure Disp_Configuration_Specification
+     (Spec : Iir_Configuration_Specification)
+   is
+      Indent : Count;
+   begin
+      Indent := Col;
+      Put ("for ");
+      Disp_Instantiation_List (Get_Instantiation_List (Spec));
+      Put (": ");
+      Disp_Name_Of (Get_Component_Name (Spec)); -- f:n
+      New_Line;
+      Disp_Binding_Indication (Get_Binding_Indication (Spec),
+                               Indent + Indentation);
+      Put_Line (";");
+   end Disp_Configuration_Specification;
+
+   procedure Disp_Disconnection_Specification
+     (Dis : Iir_Disconnection_Specification)
+   is
+   begin
+      Put ("disconnect ");
+      Disp_Instantiation_List (Get_Signal_List (Dis));
+      Put (": ");
+      Disp_Subtype_Indication (Get_Type (Dis));
+      Put (" after ");
+      Disp_Expression (Get_Expression (Dis));
+      Put_Line (";");
+   end Disp_Disconnection_Specification;
+
+   procedure Disp_Attribute_Declaration (Attr : Iir_Attribute_Declaration)
+   is
+   begin
+      Put ("attribute ");
+      Disp_Identifier (Attr); -- f:n
+      Put (": ");
+      Disp_Type (Get_Type (Attr));
+      Put_Line (";");
+   end Disp_Attribute_Declaration;
+
+   procedure Disp_Entity_Kind (Tok : Tokens.Token_Type) is
+   begin
+      Put (Tokens.Image (Tok));
+   end Disp_Entity_Kind;
+   pragma Unreferenced (Disp_Entity_Kind);
+   procedure Disp_Entity_Name_List (List : Iir_List)
+   is
+      El : Iir;
+      Ec : X;
+   begin
+      for I in Natural loop -- chain:[v=Ec|n=Name]
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Name_Of (El); -- f:n
+      end loop;
+   end Disp_Entity_Name_List;
+
+   procedure Disp_Attribute_Specification (Attr : Iir_Attribute_Specification)
+   is
+   begin
+      Put ("attribute ");
+      Disp_Identifier (Get_Attribute_Designator (Attr)); -- f:n
+      Put (" of ");
+      Disp_Entity_Name_List (Get_Entity_Name_List (Attr));
+      Put (": ");
+      Disp_Entity_Kind (Get_Entity_Class (Attr)); --f:kind
+      Put (" is ");
+      Disp_Expression (Get_Expression (Attr));
+      Put_Line (";");
+   end Disp_Attribute_Specification;
+
+   procedure Disp_Protected_Type_Body
+     (Bod : Iir_Protected_Type_Body; Indent : Count)
+   is
+   begin
+      Put ("type ");
+      Disp_Identifier (Bod); -- f:n
+      Put (" is protected body");
+      New_Line;
+      Disp_Declaration_Chain (Bod, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end protected body;");
+   end Disp_Protected_Type_Body;
+
+   procedure Disp_Declaration_Chain (Parent : Iir; Indent: Count)
+   is
+      Decl: Iir;
+   begin
+      Decl := Get_Declaration_Chain (Parent);
+      while Decl /= Null_Iir loop
+         Set_Col (Indent);
+         case Get_Kind (Decl) is
+            when Iir_Kind_Type_Declaration =>
+               Disp_Type_Declaration (Decl);
+            when Iir_Kind_Anonymous_Type_Declaration =>
+               Disp_Anonymous_Type_Declaration (Decl);
+            when Iir_Kind_Subtype_Declaration =>
+               Disp_Subtype_Declaration (Decl);
+            when Iir_Kind_Use_Clause =>
+               Disp_Use_Clause (Decl);
+            when Iir_Kind_Component_Declaration =>
+               Disp_Component_Declaration (Decl);
+            when Iir_Kinds_Object_Declaration =>
+               Disp_Object_Declaration (Decl);
+            when Iir_Kind_Non_Object_Alias_Declaration =>
+               Disp_Non_Object_Alias_Declaration (Decl);
+            when Iir_Kind_Implicit_Function_Declaration
+              | Iir_Kind_Implicit_Procedure_Declaration =>
+               Disp_Subprogram_Declaration (Decl);
+               Put_Line (";");
+            when Iir_Kind_Function_Declaration
+              | Iir_Kind_Procedure_Declaration =>
+               Disp_Subprogram_Declaration (Decl);
+               if Get_Subprogram_Body (Decl) = Null_Iir
+                 or else Get_Subprogram_Body (Decl) /= Get_Chain (Decl)
+               then
+                  Put_Line (";");
+               end if;
+            when Iir_Kind_Function_Body
+              | Iir_Kind_Procedure_Body =>
+               Disp_Subprogram_Body (Decl);
+            when Iir_Kind_Protected_Type_Body =>
+               Disp_Protected_Type_Body (Decl, Indent);
+            when Iir_Kind_Configuration_Specification =>
+               Disp_Configuration_Specification (Decl);
+            when Iir_Kind_Disconnection_Specification =>
+               Disp_Disconnection_Specification (Decl);
+            when Iir_Kind_Attribute_Declaration =>
+               Disp_Attribute_Declaration (Decl);
+            when Iir_Kind_Attribute_Specification =>
+               Disp_Attribute_Specification (Decl);
+            when Iir_Kinds_Signal_Attribute =>
+               null;
+            when others =>
+               Error_Kind ("disp_declaration_chain", Decl);
+         end case;
+         Decl := Get_Chain (Decl);
+      end loop;
+   end Disp_Declaration_Chain;
+
+   procedure Disp_Waveform (Chain : Iir_Waveform_Element)
+   is
+      We: Iir_Waveform_Element;
+      Val : Iir;
+      Ec : X;
+   begin
+      if Chain = Null_Iir then
+         Put ("null after {disconnection_time}");
+         return;
+      end if;
+      We := Chain;
+      while We /= Null_Iir loop -- chain:[v=Ec|n=waveelem]
+         if We /= Chain then
+            Put (", ");
+         end if;
+         Val := Get_We_Value (We);
+         Disp_Expression (Val);
+         if Get_Time (We) /= Null_Iir then
+            Put (" after ");
+            Disp_Expression (Get_Time (We));
+         end if;
+         We := Get_Chain (We);
+      end loop;
+   end Disp_Waveform;
+
+   procedure Disp_Delay_Mechanism (Stmt: Iir) is
+      Expr: Iir;
+   begin
+      case Get_Delay_Mechanism (Stmt) is
+         when Iir_Transport_Delay =>
+            Put ("transport ");
+         when Iir_Inertial_Delay =>
+            Expr := Get_Reject_Time_Expression (Stmt);
+            if Expr /= Null_Iir then
+               Put ("reject ");
+               Disp_Expression (Expr);
+               Put (" inertial ");
+            end if;
+      end case;
+   end Disp_Delay_Mechanism;
+
+   procedure Disp_Signal_Assignment (Stmt: Iir) is
+   begin
+      Disp_Expression (Get_Target (Stmt));
+      Put (" <= ");
+      Disp_Delay_Mechanism (Stmt);
+      Disp_Waveform (Get_Waveform_Chain (Stmt));
+      Put_Line (";");
+   end Disp_Signal_Assignment;
+
+   procedure Disp_Variable_Assignment (Stmt: Iir) is
+   begin
+      Disp_Expression (Get_Target (Stmt));
+      Put (" := ");
+      Disp_Expression (Get_Expression (Stmt));
+      Put_Line (";");
+   end Disp_Variable_Assignment;
+
+   --  procedure Disp_Label (Label: Name_Id) is
+   --  begin
+   --     if Label /= Null_Identifier then
+   --        Disp_Ident (Label);
+   --        Put (": ");
+   --     end if;
+   --  end Disp_Label;
+
+   procedure Disp_Concurrent_Selected_Signal_Assignment (Stmt: Iir)
+   is
+      Indent: Count;
+      Assoc: Iir;
+      Assoc_Chain : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      Indent := Col;
+      Set_Col (Indent);
+      Disp_Label ( (Stmt)); -- f:lab
+      Put ("with ");
+      Disp_Expression (Get_Expression (Stmt));
+      Put (" select ");
+      Disp_Expression (Get_Target (Stmt));
+      Put (" <= ");
+      if Get_Guard (Stmt) /= Null_Iir then
+         Put ("guarded ");
+      end if;
+      Disp_Delay_Mechanism (Stmt);
+      Assoc_Chain := Get_Selected_Waveform_Chain (Stmt);
+      Assoc := Assoc_Chain;
+      while Assoc /= Null_Iir loop
+         if Assoc /= Assoc_Chain then
+            Put_Line (",");
+         end if;
+         Set_Col (Indent + Indentation);
+         Disp_Waveform (Get_Associated (Assoc));
+         Put (" when ");
+         Disp_Choice (Assoc);
+      end loop;
+      Put_Line (";");
+   end Disp_Concurrent_Selected_Signal_Assignment;
+
+   procedure Disp_Concurrent_Conditional_Signal_Assignment (Stmt: Iir)
+   is
+      Indent: Count;
+      Cond_Wf : Iir_Conditional_Waveform;
+      Expr : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      Disp_Label ( (Stmt)); -- f:lab
+      Disp_Expression (Get_Target (Stmt));
+      Put (" <= ");
+      if Get_Guard (Stmt) /= Null_Iir then
+         Put ("guarded ");
+      end if;
+      Disp_Delay_Mechanism (Stmt);
+      Indent := Col;
+      Set_Col (Indent);
+      Cond_Wf := Get_Conditional_Waveform_Chain (Stmt);
+      while Cond_Wf /= Null_Iir loop
+         Disp_Waveform (Get_Waveform_Chain (Cond_Wf));
+         Expr := Get_Condition (Cond_Wf);
+         if Expr /= Null_Iir then
+            Put (" when ");
+            Disp_Expression (Expr);
+            Put_Line (" else");
+            Set_Col (Indent);
+         end if;
+         Cond_Wf := Get_Chain (Cond_Wf);
+      end loop;
+
+      Put_Line (";");
+   end Disp_Concurrent_Conditional_Signal_Assignment;
+
+   procedure Disp_Assertion_Statement (Stmt: Iir) is
+      Start: Count;
+      Expr: Iir;
+      pragma Unreferenced (Start);
+   begin
+      Start := Col;
+      if Get_Kind (Stmt) = Iir_Kind_Concurrent_Assertion_Statement then
+         Disp_Label ( (Stmt)); -- f:lab
+      end if;
+      Put ("assert ");
+      Disp_Expression (Get_Assertion_Condition (Stmt));
+      Expr := Get_Report_Expression (Stmt);
+      if Expr /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Put ("report ");
+         Disp_Expression (Expr);
+      end if;
+      Expr := Get_Severity_Expression (Stmt);
+      if Expr /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Put ("severity ");
+         Disp_Expression (Expr);
+      end if;
+      Put_Line (";");
+   end Disp_Assertion_Statement;
+
+   procedure Disp_Report_Statement (Stmt: Iir)
+   is
+      Start: Count;
+      Expr: Iir;
+      pragma Unreferenced (Start);
+   begin
+      Start := Col;
+      Put ("report ");
+      Expr := Get_Report_Expression (Stmt);
+      Disp_Expression (Expr);
+      Expr := Get_Severity_Expression (Stmt);
+      if Expr /= Null_Iir then
+         Set_Col (Start + Indentation);
+         Put ("severity ");
+         Disp_Expression (Expr);
+      end if;
+      Put_Line (";");
+   end Disp_Report_Statement;
+
+   procedure Disp_Dyadic_Operator (Expr: Iir) is
+   begin
+      Put ("(");
+      Disp_Expression (Get_Left (Expr));  -- p:l
+      Put (' ' & Name_Table.Image (Iirs_Utils.Get_Operator_Name (Expr)) & ' '); -- f:op
+      Disp_Expression (Get_Right (Expr)); -- p:r
+      Put (")");
+   end Disp_Dyadic_Operator;
+
+   procedure Disp_Monadic_Operator (Expr: Iir) is
+   begin
+      Put (Name_Table.Image (Iirs_Utils.Get_Operator_Name (Expr))); -- f:op
+      Put (" (");
+      Disp_Expression (Get_Operand (Expr)); -- p:u
+      Put (")");
+   end Disp_Monadic_Operator;
+
+   procedure Disp_Case_Statement (Stmt: Iir_Case_Statement)
+   is
+      Indent: Count;
+      Assoc: Iir;
+      Sel_Stmt : Iir;
+      Ec : X;
+      pragma Unreferenced (Indent);
+   begin
+      Indent := Col;
+      Put ("case ");
+      Disp_Expression (Get_Expression (Stmt)); -- p:e
+      Put_Line (" is");
+      Assoc := Get_Case_Statement_Alternative_Chain (Stmt);
+      while Assoc /= Null_Iir loop -- chain:[v=Ec|n=Choice]
+         Set_Col (Indent + Indentation);
+         Put ("when ");
+         Sel_Stmt := Get_Associated (Assoc);
+         Disp_Choice (Assoc); -- p:v
+         Put_Line (" =>");
+         Set_Col (Indent + 2 * Indentation);
+         Disp_Sequential_Statements (Sel_Stmt); -- p:b
+      end loop;
+      Set_Col (Indent);
+      Put_Line ("end case;");
+   end Disp_Case_Statement;
+
+   procedure Disp_Wait_Statement (Stmt: Iir_Wait_Statement) is
+      List: Iir_List;
+      Expr: Iir;
+   begin
+      Put ("wait");
+      List := Get_Sensitivity_List (Stmt);
+      if List /= Null_Iir_List then
+         Put (" on ");
+         Disp_Designator_List (List);
+      end if;
+      Expr := Get_Condition_Clause (Stmt);
+      if Expr /= Null_Iir then
+         Put (" until ");
+         Disp_Expression (Expr);
+      end if;
+      Expr := Get_Timeout_Clause (Stmt);
+      if Expr /= Null_Iir then
+         Put (" for ");
+         Disp_Expression (Expr);
+      end if;
+      Put_Line (";");
+   end Disp_Wait_Statement;
+
+   procedure Disp_If_Statement (Stmt: Iir_If_Statement) is
+      Clause: Iir;
+      Expr: Iir;
+      Start: Count;
+      Ec : X;
+      pragma Unreferenced (Start);
+   begin
+      Start := Col; -- open:[v=Ec|n=clause]
+      Put ("if "); -- f:ctyp
+      Clause := Stmt;
+      Disp_Expression (Get_Condition (Clause)); -- p:e
+      Put_Line (" then");
+      while Clause /= Null_Iir loop -- none
+         Set_Col (Start + Indentation);
+         Disp_Sequential_Statements (Get_Sequential_Statement_Chain (Clause)); -- p:b
+         Clause := Get_Else_Clause (Clause);
+         exit when Clause = Null_Iir;
+         Expr := Get_Condition (Clause); -- reopen:[v=Ec|n=clause]
+         Set_Col (Start);
+         if Expr /= Null_Iir then
+            Put ("elsif "); -- f:ctyp
+            Disp_Expression (Expr); -- p:e
+            Put_Line (" then");
+         else
+            Put_Line ("else"); -- f:ctyp
+         end if;
+      end loop;
+      Set_Col (Start); --close:clause
+      Put_Line ("end if;");
+   end Disp_If_Statement;
+
+   procedure Disp_Iterator (Iterator: Iir) is
+   begin
+      Disp_Subtype_Indication (Iterator);
+   end Disp_Iterator;
+
+   procedure Disp_Parameter_Specification
+     (Iterator : Iir_Iterator_Declaration) is
+   begin
+      Disp_Identifier (Iterator); -- f:n
+      Put (" in ");
+      Disp_Iterator (Get_Type (Iterator));
+   end Disp_Parameter_Specification;
+
+   procedure Disp_Procedure_Call (Call : Iir)
+   is
+      Obj : Iir;
+   begin
+      Obj := Get_Method_Object (Call);
+      if Obj /= Null_Iir then
+         Disp_Name (Obj); -- f:obj
+         Put ('.');
+      end if;
+      Disp_Identifier (Get_Implementation (Call)); -- f:n
+      Put (' ');
+      Disp_Association_Chain (Get_Parameter_Association_Chain (Call));
+      Put_Line (";");
+   end Disp_Procedure_Call;
+
+   procedure Disp_Sequential_Statements (First : Iir)
+   is
+      Stmt: Iir;
+      Start: Count;
+      Ec : X;
+      pragma Unreferenced (Start);
+   begin
+      Start := Col;
+      Stmt := First;
+      while Stmt /= Null_Iir loop
+         Set_Col (Start);
+         case Get_Kind (Stmt) is
+            when Iir_Kind_Null_Statement =>
+               Put_Line ("null;");
+            when Iir_Kind_If_Statement =>
+               Disp_If_Statement (Stmt);
+            when Iir_Kind_For_Loop_Statement =>
+               Put ("for "); -- open:[v=Ec|n=loop],f:typ
+               Disp_Parameter_Specification(Get_Iterator_Scheme(Stmt));--p:param
+               Put_Line (" loop");
+               Set_Col (Start + Indentation);
+               Disp_Sequential_Statements(Get_Sequential_Statement_Chain (Stmt));
+               Set_Col (Start);
+               Put_Line ("end loop;"); --close:loop
+            when Iir_Kind_While_Loop_Statement =>
+               Put ("while"); -- open:[v=Ec|n=while],f:typ
+               if Get_Condition (Stmt) /= Null_Iir then
+                  Put ("while ");
+                  Disp_Expression (Get_Condition (Stmt)); -- p:param
+                  Put (" ");
+               end if;
+               Put_Line ("loop");
+               Set_Col (Start + Indentation);
+               Disp_Sequential_Statements(Get_Sequential_Statement_Chain (Stmt));
+               Set_Col (Start);
+               Put_Line ("end loop;"); --close:while
+            when Iir_Kind_Signal_Assignment_Statement =>
+               Disp_Signal_Assignment (Stmt);
+            when Iir_Kind_Variable_Assignment_Statement =>
+               Disp_Variable_Assignment (Stmt);
+            when Iir_Kind_Assertion_Statement =>
+               Disp_Assertion_Statement (Stmt);
+            when Iir_Kind_Report_Statement =>
+               Disp_Report_Statement (Stmt);
+            when Iir_Kind_Return_Statement =>
+               if Get_Expression (Stmt) /= Null_Iir then-- open:[v=Ec|n=return]
+                  Put ("return ");
+                  Disp_Expression (Get_Expression (Stmt));
+                  Put_Line (";");
+               else
+                  Put_Line ("return;");
+               end if; --close:loop
+            when Iir_Kind_Case_Statement =>
+               Disp_Case_Statement (Stmt);
+            when Iir_Kind_Wait_Statement =>
+               Disp_Wait_Statement (Stmt);
+            when Iir_Kind_Procedure_Call_Statement =>
+               Disp_Procedure_Call (Get_Procedure_Call (Stmt));
+            when Iir_Kind_Exit_Statement
+              | Iir_Kind_Next_Statement =>
+               if Get_Kind (Stmt) = Iir_Kind_Exit_Statement then
+                  Put ("exit"); -- open:[v=Ec|n=break],f:typ
+               else
+                  Put ("next"); -- open:[v=Ec|n=break],f:typ
+               end if;
+               -- FIXME: label.
+               if Get_Condition (Stmt) /= Null_Iir then
+                  Put (" when ");
+                  Disp_Expression (Get_Condition (Stmt));
+               end if;
+               Put_Line (";"); --close:loop
+
+            when others =>
+               Error_Kind ("disp_sequential_statements", Stmt);
+         end case;
+         Stmt := Get_Chain (Stmt);
+      end loop;
+   end Disp_Sequential_Statements;
+
+   procedure Disp_Process_Statement (Process: Iir)
+   is
+      Start: Count;
+   begin
+      Start := Col;
+      Disp_Label ( (Process)); -- f:lab
+
+      Put ("process ");
+      if Get_Kind (Process) = Iir_Kind_Sensitized_Process_Statement then
+         Put ("(");
+         Disp_Designator_List (Get_Sensitivity_List (Process));
+         Put (")");
+      end if;
+      if Vhdl_Std >= Vhdl_93 then
+         Put_Line (" is");
+      else
+         New_Line;
+      end if;
+      Disp_Declaration_Chain (Process, Start + Indentation);
+      Set_Col (Start);
+      Put_Line ("begin");
+      Set_Col (Start + Indentation);
+      Disp_Sequential_Statements (Get_Sequential_Statement_Chain (Process));
+      Set_Col (Start);
+      Put_Line ("end process;");
+   end Disp_Process_Statement;
+
+   procedure Disp_Association_Chain (Chain : Iir)
+   is
+      El: Iir;
+      Formal: Iir;
+      Need_Comma : Boolean;
+      Conv : Iir;
+      Ec : X;
+   begin
+      if Chain = Null_Iir then
+         return;
+      end if;
+      Put ("(");
+      Need_Comma := False;
+
+      El := Chain;
+      while El /= Null_Iir loop -- chain:[v=Ec|n=Association]
+         if Get_Kind (El) /= Iir_Kind_Association_Element_By_Individual then
+            if Need_Comma then
+               Put (", ");
+            end if;
+            if Get_Kind (El) = Iir_Kind_Association_Element_By_Expression then
+               Conv := Get_Out_Conversion (El);
+               if Conv /= Null_Iir then
+                  Disp_Function_Name (Conv); -- f:from
+                  Put (" (");
+               end if;
+            else
+               Conv := Null_Iir;
+            end if;
+            Formal := Get_Formal (El);
+            if Formal /= Null_Iir then
+               Disp_Expression (Formal);
+               if Conv /= Null_Iir then
+                  Put (")");
+               end if;
+               Put (" => ");
+            end if;
+            if Get_Kind (El) = Iir_Kind_Association_Element_Open then
+               Put ("open");
+            else
+               Conv := Get_In_Conversion (El);
+               if Conv /= Null_Iir then
+                  Disp_Function_Name (Conv); -- f:to
+                  Put (" (");
+               end if;
+               Disp_Expression (Get_Actual (El));
+               if Conv /= Null_Iir then
+                  Put (")");
+               end if;
+            end if;
+            Need_Comma := True;
+         end if;
+         El := Get_Chain (El);
+      end loop;
+      Put (")");
+   end Disp_Association_Chain;
+
+   procedure Disp_Generic_Map_Aspect (Parent : Iir) is
+   begin
+      Put ("generic map ");
+      Disp_Association_Chain (Get_Generic_Map_Aspect_Chain (Parent));
+   end Disp_Generic_Map_Aspect;
+
+   procedure Disp_Port_Map_Aspect (Parent : Iir) is
+   begin
+      Put ("port map ");
+      Disp_Association_Chain (Get_Port_Map_Aspect_Chain (Parent));
+   end Disp_Port_Map_Aspect;
+
+   procedure Disp_Entity_Aspect (Aspect : Iir) is
+      Arch : Iir;
+   begin
+      case Get_Kind (Aspect) is -- rename:Aspect,flags:[typ=aspect]
+         when Iir_Kind_Entity_Aspect_Entity =>
+            Put ("entity ");
+            Disp_Name_Of (Get_Entity (Aspect)); -- f:n
+            Arch := Get_Architecture (Aspect);
+            if Arch /= Null_Iir then
+               Put (" (");
+               Disp_Name_Of (Arch); -- f:arch
+               Put (")");
+            end if;
+         when Iir_Kind_Entity_Aspect_Configuration =>
+            Put ("configuration ");
+            Disp_Name_Of (Get_Configuration (Aspect)); -- f:n
+         when Iir_Kind_Entity_Aspect_Open =>
+            Put ("open");
+         when others =>
+            Error_Kind ("disp_entity_aspect", Aspect);
+      end case;
+   end Disp_Entity_Aspect;
+
+   procedure Disp_Component_Instantiation_Statement
+     (Stmt: Iir_Component_Instantiation_Statement)
+   is
+      Component: Iir;
+      Alist: Iir;
+   begin
+      Disp_Label ( (Stmt)); -- f:lab
+      Component := Get_Instantiated_Unit (Stmt);
+      if Get_Kind (Component) = Iir_Kind_Component_Declaration then
+         Disp_Name_Of (Component); -- f:n
+      else
+         Disp_Entity_Aspect (Component);
+      end if;
+      Alist := Get_Generic_Map_Aspect_Chain (Stmt);
+      if Alist /= Null_Iir then
+         Put (" ");
+         Disp_Generic_Map_Aspect (Stmt);
+      end if;
+      Alist := Get_Port_Map_Aspect_Chain (Stmt);
+      if Alist /= Null_Iir then
+         Put (" ");
+         Disp_Port_Map_Aspect (Stmt);
+      end if;
+      Put (";");
+   end Disp_Component_Instantiation_Statement;
+
+   procedure Disp_Function_Call (Expr: Iir_Function_Call) is
+   begin
+      Disp_Function_Name (Get_Implementation (Expr)); -- f:n
+      Disp_Association_Chain (Get_Parameter_Association_Chain (Expr));
+   end Disp_Function_Call;
+
+   procedure Disp_Indexed_Name (Indexed: Iir)
+   is
+      List : Iir_List;
+      El: Iir;
+      Ec : X;
+   begin
+      Disp_Expression (Get_Prefix (Indexed));
+      Put (" (");
+      List := Get_Index_List (Indexed);
+      for I in Natural loop -- chain:[v=Ec|n=Name]
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            Put (", ");
+         end if;
+         Disp_Expression (El);
+      end loop;
+      Put (")");
+   end Disp_Indexed_Name;
+
+   procedure Disp_Choice (Choice: in out Iir) is
+      Ec : X;
+   begin
+      loop -- chain:[v=Ec|n=Choice]
+         case Get_Kind (Choice) is
+            when Iir_Kind_Choice_By_Others =>
+               Put ("others"); -- f:val
+            when Iir_Kind_Choice_By_None =>
+               null;
+            when Iir_Kind_Choice_By_Expression =>
+               Disp_Expression (Get_Expression (Choice));
+            when Iir_Kind_Choice_By_Range =>
+               Disp_Range (Get_Expression (Choice));
+            when Iir_Kind_Choice_By_Name =>
+               Disp_Name_Of (Get_Name (Choice)); -- f:val
+            when others =>
+               Error_Kind ("disp_choice", Choice);
+         end case;
+         Choice := Get_Chain (Choice);
+         exit when Choice = Null_Iir;
+         exit when Get_Same_Alternative_Flag (Choice) = False;
+         --exit when Choice = Null_Iir;
+         Put (" | ");
+      end loop;
+   end Disp_Choice;
+
+   procedure Disp_Aggregate (Aggr: Iir_Aggregate)
+   is
+      Indent: Count;
+      Assoc: Iir;
+      Expr : Iir;
+      Ec : X;
+      pragma Unreferenced (Indent);
+   begin
+      Put ("(");
+      Indent := Col;
+      Assoc := Get_Association_Choices_Chain (Aggr);
+      loop -- chain:[v=Ec|n=AggE]
+         Expr := Get_Associated (Assoc);
+         if Get_Kind (Assoc) /= Iir_Kind_Choice_By_None then
+            Disp_Choice (Assoc);
+            Put (" => ");
+         else
+            Assoc := Get_Chain (Assoc);
+         end if;
+         if Get_Kind (Expr) = Iir_Kind_Aggregate
+           or else Get_Kind (Expr) = Iir_Kind_String_Literal then
+            Set_Col (Indent);
+         end if;
+         Disp_Expression (Expr);
+         exit when Assoc = Null_Iir;
+         Put (", ");
+      end loop;
+      Put (")");
+   end Disp_Aggregate;
+
+   procedure Disp_Simple_Aggregate (Aggr: Iir_Simple_Aggregate)
+   is
+      List : Iir_List;
+      El : Iir;
+      First : Boolean := True;
+      Ec : X;
+   begin
+      Put ("(");
+      List := Get_Simple_Aggregate_List (Aggr);
+      for I in Natural loop -- chain:[v=Ec|n=AggE]
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir; --exitchain:Ec
+         if First then
+            First := False;
+         else
+            Put (", ");
+         end if;
+         Disp_Expression (El);
+      end loop;
+      Put (")");
+   end Disp_Simple_Aggregate;
+
+   procedure Disp_Parametered_Attribute (Name : String; Expr : Iir)
+   is
+      Param : Iir;
+      Pfx : Iir;
+   begin
+      Pfx := Get_Prefix (Expr);
+      case Get_Kind (Pfx) is
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Subtype_Declaration =>
+            Disp_Name_Of (Pfx); -- f:n
+         when others =>
+            Disp_Expression (Pfx);
+      end case;
+      Put ("'");
+      Put (Name); -- f:attribute
+      Param := Get_Parameter (Expr);
+      if Param /= Null_Iir then
+         Put (" (");
+         Disp_Expression (Param);
+         Put (")");
+      end if;
+   end Disp_Parametered_Attribute;
+
+   procedure Disp_String_Literal (Str : Iir)
+   is
+      Ptr : String_Fat_Acc;
+      Len : Int32;
+   begin
+      Ptr := Get_String_Fat_Acc (Str);
+      Len := Get_String_Length (Str);
+      Put (String (Ptr (1 .. Len)));
+   end Disp_String_Literal;
+   pragma Unreferenced (Disp_String_Literal);
+
+   procedure Disp_Expression (Expr: Iir)
+   is
+      Orig : Iir;
+   begin
+      case Get_Kind (Expr) is -- rename:Expr,flags:[typ=expr]
+         when Iir_Kind_Integer_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (Orig); --reent:1
+            else
+               Disp_Int64 (Get_Value (Expr)); -- f:val
+            end if;
+         when Iir_Kind_Floating_Point_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (Orig); --reent:1
+            else
+               Disp_Fp64 (Get_Fp_Value (Expr)); -- f:val
+            end if;
+         when Iir_Kind_String_Literal =>
+            Put (""""); -- nop:1
+            Disp_String_Literal (Expr); -- f:val
+            Put (""""); -- nop:1
+            if Disp_String_Literal_Type or Flags.List_Verbose then
+               Put ("[type: ");
+               Disp_Type (Get_Type (Expr));
+               Put ("]");
+            end if;
+         when Iir_Kind_Bit_String_Literal =>
+            if False then
+               case Get_Bit_String_Base (Expr) is
+                  when Base_2 =>
+                     Put ('B');
+                  when Base_8 =>
+                     Put ('O');
+                  when Base_16 =>
+                     Put ('X');
+               end case;
+            end if;
+            Put ("B"""); -- nop:1
+            Disp_String_Literal (Expr); -- f:val
+            Put (""""); -- nop:1
+         when Iir_Kind_Physical_Fp_Literal
+           | Iir_Kind_Physical_Int_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (Orig);
+            else
+               Disp_Physical_Literal (Expr); -- f:val
+            end if;
+         when Iir_Kind_Unit_Declaration =>
+            Disp_Name_Of (Expr); -- f:val
+         when Iir_Kind_Enumeration_Literal =>
+            Disp_Name_Of (Expr); -- f:val
+         when Iir_Kind_Object_Alias_Declaration =>
+            Disp_Name_Of (Expr); -- f:val
+         when Iir_Kind_Aggregate =>
+            Disp_Aggregate (Expr); --reent:1
+         when Iir_Kind_Null_Literal =>
+            Put ("null");
+         when Iir_Kind_Simple_Aggregate =>
+            Disp_Simple_Aggregate (Expr); --reent:1
+
+         when Iir_Kind_Element_Declaration =>
+            Disp_Name_Of (Expr); -- f:val
+
+         when Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Iterator_Declaration =>
+            Disp_Name_Of (Expr); -- f:val
+            return;
+
+         when Iir_Kind_Simple_Name =>
+            Disp_Name (Expr); -- f:val
+
+         when Iir_Kinds_Dyadic_Operator =>
+            Disp_Dyadic_Operator (Expr); --reent:1
+         when Iir_Kinds_Monadic_Operator =>
+            Disp_Monadic_Operator (Expr); --reent:1
+         when Iir_Kind_Function_Call =>
+            Disp_Function_Call (Expr); --reent:1
+         when Iir_Kind_Type_Conversion =>
+            Disp_Type (Get_Type (Expr));
+            Put (" (");
+            Disp_Expression (Get_Expression (Expr));
+            Put (")");
+         when Iir_Kind_Qualified_Expression =>
+            Disp_Type (Get_Type_Mark (Expr));
+            Put ("'(");
+            Disp_Expression (Get_Expression (Expr));
+            Put (")");
+         when Iir_Kind_Allocator_By_Expression =>
+            Put ("new ");
+            Disp_Expression (Get_Expression (Expr));
+         when Iir_Kind_Allocator_By_Subtype =>
+            Put ("new ");
+            Disp_Subtype_Indication (Get_Expression (Expr));
+
+         when Iir_Kind_Indexed_Name =>
+            Disp_Indexed_Name (Expr); --reent:1
+         when Iir_Kind_Slice_Name =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put (" (");
+            Disp_Range (Get_Suffix (Expr));
+            Put (")");
+         when Iir_Kind_Selected_Element =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put (".");
+            Disp_Name_Of (Get_Selected_Element (Expr)); -- f:elem
+         when Iir_Kind_Implicit_Dereference =>
+            Disp_Expression (Get_Prefix (Expr));
+         when Iir_Kind_Dereference =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put (".all");
+
+         when Iir_Kind_Left_Type_Attribute =>
+            Put ("'left");-- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Right_Type_Attribute =>
+            Put ("'right");-- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_High_Type_Attribute =>
+            Put ("'high");-- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Low_Type_Attribute =>
+            Put ("'low");-- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+
+         when Iir_Kind_Stable_Attribute =>
+            Disp_Parametered_Attribute ("stable", Expr); --reent:1
+         when Iir_Kind_Delayed_Attribute =>
+            Disp_Parametered_Attribute ("delayed", Expr); --reent:1
+         when Iir_Kind_Transaction_Attribute =>
+            Put ("'transaction"); -- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Event_Attribute =>
+            Put ("'event"); -- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Active_Attribute =>
+            Put ("'active"); -- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Last_Value_Attribute =>
+            Put ("'last_value"); -- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Last_Event_Attribute =>
+            Put ("'last_event"); -- f:attribute
+            Disp_Expression (Get_Prefix (Expr)); --reent:1
+
+         when Iir_Kind_Pos_Attribute =>
+            Disp_Parametered_Attribute ("pos", Expr); --reent:1
+         when Iir_Kind_Val_Attribute =>
+            Disp_Parametered_Attribute ("val", Expr); --reent:1
+         when Iir_Kind_Succ_Attribute =>
+            Disp_Parametered_Attribute ("succ", Expr); --reent:1
+         when Iir_Kind_Pred_Attribute =>
+            Disp_Parametered_Attribute ("pred", Expr); --reent:1
+
+         when Iir_Kind_Length_Array_Attribute =>
+            Disp_Parametered_Attribute ("length", Expr); --reent:1
+         when Iir_Kind_Range_Array_Attribute =>
+            Disp_Parametered_Attribute ("range", Expr); --reent:1
+         when Iir_Kind_Reverse_Range_Array_Attribute =>
+            Disp_Parametered_Attribute ("reverse_range", Expr); --reent:1
+         when Iir_Kind_Left_Array_Attribute =>
+            Disp_Parametered_Attribute ("left", Expr); --reent:1
+         when Iir_Kind_Right_Array_Attribute =>
+            Disp_Parametered_Attribute ("right", Expr); --reent:1
+         when Iir_Kind_Low_Array_Attribute =>
+            Disp_Parametered_Attribute ("low", Expr); --reent:1
+         when Iir_Kind_High_Array_Attribute =>
+            Disp_Parametered_Attribute ("high", Expr); --reent:1
+         when Iir_Kind_Ascending_Array_Attribute =>
+            Disp_Parametered_Attribute ("ascending", Expr); --reent:1
+
+         when Iir_Kind_Image_Attribute =>
+            Disp_Parametered_Attribute ("image", Expr); --reent:1
+         when Iir_Kind_Simple_Name_Attribute =>
+            Disp_Name_Of (Get_Prefix (Expr)); -- f:n
+            Put ("'simple_name"); -- f:attribute
+         when Iir_Kind_Instance_Name_Attribute =>
+            Disp_Name_Of (Get_Prefix (Expr)); -- f:n
+            Put ("'instance_name"); -- f:attribute
+         when Iir_Kind_Path_Name_Attribute =>
+            Disp_Name_Of (Get_Prefix (Expr)); -- f:n
+            Put ("'path_name"); -- f:attribute
+
+         when Iir_Kind_Selected_By_All_Name =>
+            Disp_Expression (Get_Prefix (Expr));
+            Put ("");
+            return;
+         when Iir_Kind_Selected_Name =>
+            Disp_Expression (Get_Named_Entity (Expr)); --reent:1
+
+         when Iir_Kinds_Type_And_Subtype_Definition =>
+            Disp_Type (Expr); --reent:1
+
+         when Iir_Kind_Proxy =>
+            Disp_Expression (Get_Proxy (Expr));
+
+         when Iir_Kind_Range_Expression =>
+            Disp_Range (Expr); --reent:1
+         when Iir_Kind_Subtype_Declaration =>
+            Disp_Name_Of (Expr); -- f:n
+
+         when others =>
+            Error_Kind ("disp_expression", Expr);
+      end case;
+   end Disp_Expression;
+
+   --  procedure Disp_PSL_HDL_Expr
+   -- (NPSL : PSL.Nodes.HDL_Node) is
+   --  begin
+   --     Disp_Expression (Iir (NPSL));
+   --  end Disp_PSL_HDL_Expr;
+
+   procedure Disp_Psl_Expression (Expr : PSL_Node) is
+      pragma Unreferenced (Expr);
+   begin
+      Put_Line("Error Psl not supported\n");
+      --PSL.Prints.HDL_Expr_Printer := Disp_PSL_HDL_Expr'Access;
+      --PSL.Prints.Print_Property (Expr);
+   end Disp_Psl_Expression;
+
+   procedure Disp_Block_Header (Header : Iir_Block_Header; Indent: Count)
+   is
+      Chain : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      if Header = Null_Iir then
+         return;
+      end if;
+      Chain := Get_Generic_Chain (Header);
+      if Chain /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Generics (Header);
+         Chain := Get_Generic_Map_Aspect_Chain (Header);
+         if Chain /= Null_Iir then
+            Set_Col (Indent + Indentation);
+            Disp_Generic_Map_Aspect (Header);
+            Put_Line (";");
+         end if;
+      end if;
+      Chain := Get_Port_Chain (Header);
+      if Chain /= Null_Iir then
+         Set_Col (Indent + Indentation);
+         Disp_Ports (Header);
+         Chain := Get_Port_Map_Aspect_Chain (Header);
+         if Chain /= Null_Iir then
+            Set_Col (Indent + Indentation);
+            Disp_Port_Map_Aspect (Header);
+            Put_Line (";");
+         end if;
+      end if;
+   end Disp_Block_Header;
+
+   procedure Disp_Block_Statement (Block: Iir_Block_Statement)
+   is
+      Indent: Count;
+      Sensitivity: Iir_List;
+      Guard : Iir_Guard_Signal_Declaration;
+   begin
+      Indent := Col;
+      Disp_Label ( (Block)); -- f:lab
+      Put ("block");
+      Guard := Get_Guard_Decl (Block);
+      if Guard /= Null_Iir then
+         Put (" (");
+         Disp_Expression (Get_Guard_Expression (Guard));
+         Put_Line (")");
+         Sensitivity := Get_Guard_Sensitivity_List (Guard);
+         if Sensitivity /= Null_Iir_List then
+            Set_Col (Indent + Indentation);
+            Put ("-- guard sensitivity list ");
+            Disp_Designator_List (Sensitivity);
+         end if;
+      else
+         New_Line;
+      end if;
+      Disp_Block_Header (Get_Block_Header (Block),
+                         Indent + Indentation);
+      Disp_Declaration_Chain (Block, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (Block, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end;");
+   end Disp_Block_Statement;
+
+   procedure Disp_Generate_Statement (Stmt : Iir_Generate_Statement)
+   is
+      Indent : Count;
+      Scheme : Iir;
+   begin
+      Indent := Col;
+      Disp_Label ( (Stmt)); -- f:lab
+      Scheme := Get_Generation_Scheme (Stmt);
+      case Get_Kind (Scheme) is
+         when Iir_Kind_Iterator_Declaration =>
+            Put ("for ");
+            Disp_Parameter_Specification (Scheme);
+         when others =>
+            Put ("if ");
+            Disp_Expression (Scheme);
+      end case;
+      Put_Line (" generate");
+      Disp_Declaration_Chain (Stmt, Indent);
+      Set_Col (Indent);
+      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (Stmt, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end generate;");
+   end Disp_Generate_Statement;
+
+   procedure Disp_Psl_Default_Clock (Stmt : Iir) is
+   begin
+      Put ("--psl default clock is ");
+      Disp_Psl_Expression (Get_Psl_Boolean (Stmt));
+      Put_Line (";");
+   end Disp_Psl_Default_Clock;
+
+   procedure Disp_Psl_Assert_Statement (Stmt : Iir)
+   is
+      use PSL.NFAs;
+      use PSL.Nodes;
+
+      procedure Disp_State (S : NFA_State) is
+         Str : constant String := Int32'Image (Get_State_Label (S));
+      begin
+         Put (Str (2 .. Str'Last));
+      end Disp_State;
+
+      NPSL : NFA;
+      S : NFA_State;
+      E : NFA_Edge;
+   begin
+      Put ("--psl assert ");
+      Disp_Psl_Expression (Get_Psl_Property (Stmt));
+      Put_Line (";");
+      NPSL := Get_PSL_NFA (Stmt);
+      if True and then NPSL /= No_NFA then
+         S := Get_First_State (NPSL);
+         while S /= No_State loop
+            E := Get_First_Src_Edge (S);
+            while E /= No_Edge loop
+               Put ("-- ");
+               Disp_State (S);
+               Put (" -> ");
+               Disp_State (Get_Edge_Dest (E));
+               Put (": ");
+               Disp_Psl_Expression (Get_Edge_Expr (E));
+               New_Line;
+               E := Get_Next_Src_Edge (E);
+            end loop;
+            S := Get_Next_State (S);
+         end loop;
+      end if;
+   end Disp_Psl_Assert_Statement;
+
+   procedure Disp_Concurrent_Statement (Stmt: Iir) is
+   begin
+      case Get_Kind (Stmt) is -- rename:Stmt,flags:[typ=concur]
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            Disp_Concurrent_Conditional_Signal_Assignment (Stmt);-- reent:1
+         when Iir_Kind_Concurrent_Selected_Signal_Assignment =>
+            Disp_Concurrent_Selected_Signal_Assignment (Stmt);-- reent:1
+         when Iir_Kind_Sensitized_Process_Statement
+           | Iir_Kind_Process_Statement =>
+            Disp_Process_Statement (Stmt);
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            Disp_Assertion_Statement (Stmt);
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Component_Instantiation_Statement (Stmt);
+         when Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            Disp_Procedure_Call (Get_Procedure_Call (Stmt));
+         when Iir_Kind_Block_Statement =>
+            Disp_Block_Statement (Stmt);
+         when Iir_Kind_Generate_Statement =>
+            Disp_Generate_Statement (Stmt);
+         when Iir_Kind_Psl_Default_Clock =>
+            Disp_Psl_Default_Clock (Stmt);
+         when Iir_Kind_Psl_Assert_Statement =>
+            Disp_Psl_Assert_Statement (Stmt);
+         when others =>
+            Error_Kind ("disp_concurrent_statement", Stmt);
+      end case;
+   end Disp_Concurrent_Statement;
+
+   procedure Disp_Package_Declaration (Decl: Iir_Package_Declaration) is
+   begin
+      Put ("package ");
+      Disp_Identifier (Decl); -- f:n
+      Put_Line (" is");
+      Disp_Declaration_Chain (Decl, Col + Indentation);
+      Put_Line ("end;");
+   end Disp_Package_Declaration;
+
+   procedure Disp_Package_Body (Decl: Iir)
+   is
+   begin
+      Put ("package body ");
+      Disp_Identifier (Decl); -- f:n
+      Put_Line (" is");
+      Disp_Declaration_Chain (Decl, Col + Indentation);
+      Put_Line ("end;");
+   end Disp_Package_Body;
+
+   procedure Disp_Binding_Indication (Bind : Iir; Indent : Count)
+   is
+      El : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      El := Get_Entity_Aspect (Bind);
+      if El /= Null_Iir then
+         Set_Col (Indent);
+         Put ("use ");
+         Disp_Entity_Aspect (El);
+      end if;
+      El := Get_Generic_Map_Aspect_Chain (Bind);
+      if El /= Null_Iir then
+         Set_Col (Indent);
+         Disp_Generic_Map_Aspect (Bind);
+      end if;
+      El := Get_Port_Map_Aspect_Chain (Bind);
+      if El /= Null_Iir then
+         Set_Col (Indent);
+         Disp_Port_Map_Aspect (Bind);
+      end if;
+   end Disp_Binding_Indication;
+
+   procedure Disp_Component_Configuration
+     (Conf : Iir_Component_Configuration; Indent : Count)
+   is
+      Block : Iir_Block_Configuration;
+      Binding : Iir;
+   begin
+      Set_Col (Indent);
+      Put ("for ");
+      Disp_Instantiation_List (Get_Instantiation_List (Conf));
+      Put(" : ");
+      Disp_Name_Of (Get_Component_Name (Conf)); -- f:n
+      New_Line;
+      Binding := Get_Binding_Indication (Conf);
+      if Binding /= Null_Iir then
+         Disp_Binding_Indication (Binding, Indent + Indentation);
+      end if;
+      Block := Get_Block_Configuration (Conf);
+      if Block /= Null_Iir then
+         Disp_Block_Configuration (Block, Indent + Indentation);
+      end if;
+      Set_Col (Indent);
+      Put_Line ("end for;");
+   end Disp_Component_Configuration;
+
+   procedure Disp_Configuration_Items
+     (Conf : Iir_Block_Configuration; Indent : Count)
+   is
+      El : Iir;
+   begin
+      El := Get_Configuration_Item_Chain (Conf);
+      while El /= Null_Iir loop
+         case Get_Kind (El) is
+            when Iir_Kind_Block_Configuration =>
+               Disp_Block_Configuration (El, Indent);
+            when Iir_Kind_Component_Configuration =>
+               Disp_Component_Configuration (El, Indent);
+            when Iir_Kind_Configuration_Specification =>
+               --  This may be created by canon.
+               Set_Col (Indent);
+               Disp_Configuration_Specification (El);
+               Set_Col (Indent);
+               Put_Line ("end for;");
+            when others =>
+               Error_Kind ("disp_configuration_item_list", El);
+         end case;
+         El := Get_Chain (El);
+      end loop;
+   end Disp_Configuration_Items;
+
+   procedure Disp_Block_Configuration
+     (Block: Iir_Block_Configuration; Indent: Count)
+   is
+      Spec : Iir;
+   begin
+      Set_Col (Indent);
+      Put ("for ");
+      Spec := Get_Block_Specification (Block);
+      case Get_Kind (Spec) is
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement
+           | Iir_Kind_Architecture_Declaration =>
+            Disp_Name_Of (Spec); -- f:n
+         when Iir_Kind_Indexed_Name =>
+            Disp_Name_Of (Get_Prefix (Spec)); -- f:prefix
+            Put (" (");
+            Disp_Expression (Get_First_Element (Get_Index_List (Spec)));
+            Put (")");
+         when Iir_Kind_Selected_Name =>
+            Disp_Name_Of (Get_Prefix (Spec)); -- f:prefix
+            Put (" (");
+            Put (Iirs_Utils.Image_Identifier (Spec)); -- f:n
+            Put (")");
+         when Iir_Kind_Slice_Name =>
+            Disp_Name_Of (Get_Prefix (Spec)); -- f:prefix
+            Put (" (");
+            Disp_Range (Get_Suffix (Spec));
+            Put (")");
+         when others =>
+            Error_Kind ("disp_block_configuration", Spec);
+      end case;
+      New_Line;
+      Disp_Declaration_Chain (Block, Indent + Indentation);
+      Disp_Configuration_Items (Block, Indent + Indentation);
+      Set_Col (Indent);
+      Put_Line ("end for;");
+   end Disp_Block_Configuration;
+
+   procedure Disp_Configuration_Declaration
+     (Decl: Iir_Configuration_Declaration)
+   is
+   begin
+      Put ("configuration ");
+      Disp_Name_Of (Decl); -- f:n
+      Put (" of ");
+      Disp_Name_Of (Get_Entity (Decl)); --f:of
+      Put_Line (" is");
+      Disp_Declaration_Chain (Decl, Col);
+      Disp_Block_Configuration (Get_Block_Configuration (Decl),
+                                Col + Indentation);
+      Put_Line ("end;");
+   end Disp_Configuration_Declaration;
+
+   procedure Disp_Design_Unit (Unit: Iir_Design_Unit)
+   is
+      Decl: Iir;
+      Indent: Count;
+      pragma Unreferenced (Indent);
+   begin
+      Indent := Col;
+      Decl := Get_Context_Items (Unit);
+      while Decl /= Null_Iir loop
+         Set_Col (Indent);
+         case Get_Kind (Decl) is
+            when Iir_Kind_Use_Clause =>
+               Disp_Use_Clause (Decl);
+            when Iir_Kind_Library_Clause =>
+               Put ("library ");
+               Disp_Identifier (Decl); -- f:n
+               Put_Line (";");
+            when others =>
+               Error_Kind ("disp_design_unit1", Decl);
+         end case;
+         Decl := Get_Chain (Decl);
+      end loop;
+
+      Decl := Get_Library_Unit (Unit);
+      Set_Col (Indent);
+      case Get_Kind (Decl) is
+         when Iir_Kind_Entity_Declaration =>
+            Disp_Entity_Declaration (Decl);
+         when Iir_Kind_Architecture_Declaration =>
+            Disp_Architecture_Declaration (Decl);
+         when Iir_Kind_Package_Declaration =>
+            Disp_Package_Declaration (Decl);
+         when Iir_Kind_Package_Body =>
+            Disp_Package_Body (Decl);
+         when Iir_Kind_Configuration_Declaration =>
+            Disp_Configuration_Declaration (Decl);
+         when others =>
+            Error_Kind ("disp_design_unit2", Decl);
+      end case;
+      New_Line (2);
+   end Disp_Design_Unit;
+
+   procedure Disp_Xml_Vhdl (An_Iir: Iir) is
+   begin
+      --Set_Line_Length (80);
+      -- Put (Count'Image (Line_Length));
+      case Get_Kind (An_Iir) is
+         when Iir_Kind_Design_Unit =>
+            Disp_Design_Unit (An_Iir);
+         when Iir_Kind_Character_Literal =>
+            Disp_Character_Literal (An_Iir);
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Enumeration_Type_Definition (An_Iir);
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            Disp_Enumeration_Subtype_Definition (An_Iir);
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            Disp_Concurrent_Conditional_Signal_Assignment (An_Iir);
+         when Iir_Kinds_Dyadic_Operator =>
+            Disp_Dyadic_Operator (An_Iir);
+         when Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Object_Alias_Declaration =>
+            Disp_Name_Of (An_Iir); -- f:n
+         when Iir_Kind_Enumeration_Literal =>
+            Disp_Identifier (An_Iir); -- f:n
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Component_Instantiation_Statement (An_Iir);
+         when Iir_Kind_Integer_Subtype_Definition =>
+            Disp_Integer_Subtype_Definition (An_Iir);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Subtype_Definition (An_Iir);
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Type_Definition (An_Iir);
+         when Iir_Kind_Package_Declaration =>
+            Disp_Package_Declaration (An_Iir);
+         when Iir_Kind_Wait_Statement =>
+            Disp_Wait_Statement (An_Iir);
+         when Iir_Kind_Selected_Name
+           | Iir_Kind_Selected_Element
+           | Iir_Kind_Indexed_Name
+           | Iir_Kind_Slice_Name =>
+            Disp_Expression (An_Iir);
+         when others =>
+            Error_Kind ("disp", An_Iir);
+      end case;
+   end Disp_Xml_Vhdl;
+   function NewN(P:X;Pos:U_String) return X is
+      N : X;
+   begin
+      N := X(Create_Xml_Node_Pretty(P,+"undef"));
+      AddAttr(N,+"pos",Pos);
+      return N;
+   end NewN;
+   procedure Disp_Int64 (Val: Iir_Int64)
+   is
+      Str: constant String := Iir_Int64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         Put (Str (Str'First + 1 .. Str'Last));
+      else
+         Put (Str);
+      end if;
+   end Disp_Int64;
+   pragma Unreferenced (Disp_Int64);
+
+   --  procedure Disp_Int32 (Val: Iir_Int32)
+   --  is
+   --     Str: constant String := Iir_Int32'Image (Val);
+   --  begin
+   --     if Str(Str'First) = ' ' then
+   --        Put (Str (Str'First + 1 .. Str'Last));
+   --     else
+   --        Put (Str);
+   --     end if;
+   --  end Disp_Int32;
+
+   procedure Disp_Fp64 (Val: Iir_Fp64)
+   is
+      Str: constant String := Iir_Fp64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         Put (Str (Str'First + 1 .. Str'Last));
+      else
+         Put (Str);
+      end if;
+   end Disp_Fp64;
+   pragma Unreferenced (Disp_Fp64);
+
+end disp_xml_vhdl;
--- ghdl-r150-ori/disp_xml_node.adb	2013-07-10 13:07:40.000000000 +0200
+++ ghdl-r150/disp_xml_node.adb	2013-06-28 15:37:15.000000000 +0200
@@ -0,0 +1,220 @@
+with Ada.Text_IO; use Ada.Text_IO;
+--With Ada.Text_IO.Unbounded_IO; use Ada.Text_IO.Unbounded_IO;
+--with Ada.Command_Line; use Ada.Command_Line;
+with Ada.Containers; use Ada.Containers;
+with GNAT.Regpat;
+with Interfaces; use Interfaces;
+with Ada.Unchecked_Conversion;
+
+package body disp_xml_node is
+   package Pat renames GNAT.Regpat;
+   subtype Byte is Unsigned_8;
+   function Conv_Char_To_U8 is
+      new Ada.Unchecked_Conversion(Source => Character,Target => Byte);
+   function Conv_U8_To_Char is
+      new Ada.Unchecked_Conversion(Source => Byte, Target => Character);
+   procedure Search_For_Pattern(Compiled_Expression: Pat.Pattern_Matcher;
+                                Search_In: String;
+                                First, Last: out Positive;
+                                Found: out Boolean) is
+      Result: Pat.Match_Array (0 .. 1);
+   begin
+      Pat.Match(Compiled_Expression, Search_In, Result);
+      Found := not Pat."="(Result(1), Pat.No_Match);
+      if Found then
+         First := Result(1).First;
+         Last := Result(1).Last;
+      end if;
+   end Search_For_Pattern;
+
+   function Substitute(P: String; S,R : U_String) return U_String is
+      Ret : U_String := +"";
+      Str : U_String := S;
+      PatC : constant Pat.Pattern_Matcher := Pat.Compile(P);
+      First, Last:   Positive;
+      Found:         Boolean;
+   begin
+      loop
+         Search_For_Pattern(PatC, - Str,
+                            First, Last, Found);
+         exit when not Found;
+         Ret := Ret & (+Slice(Str,1,First-1)) & R;
+         Str := (+Slice(Str,Last+1,Length(Str)));
+      end loop;
+      Ret := Ret & Str;
+      return Ret;
+   end Substitute;
+
+   function Encode_Utf8(P: U_String) return U_String is
+      S : U_String := +"";
+      C:Byte;
+      Ch:Character;
+   begin
+      for I in 1 .. Length(P) loop
+         Ch := Ada.Strings.Unbounded.Element(P,I);
+         C := Conv_Char_To_U8(Ch);
+         if (C and 128) /= 0 then
+            Append(S,Conv_U8_To_Char(Shift_Right((C and 16#c0#),6) or 16#c0#));
+            Append(S,Conv_U8_To_Char((C and 16#3f#) or 16#80#));
+         else
+            Append(S,Ch);
+         end if;
+      end loop;
+      return S;
+   end Encode_Utf8;
+
+   function FormatXml(P: U_String) return U_String is
+      S : U_String := P;
+      C: Byte;
+      F: Boolean := False;
+   begin
+      S := Substitute("(&)",S,+"&amp;");
+      S := Substitute("(<)",S,+"&lt;");
+      S := Substitute("(>)",S,+"&gt;");
+      S := Substitute("("&""""&")",S,+"&quot;");
+      for I in 1 .. Length(S) loop
+         C := Conv_Char_To_U8(Ada.Strings.Unbounded.Element(S,I));
+         if (C and 128) /= 0 then
+            F:= True;
+            exit;
+         end if;
+      end loop;
+      if F then
+         S:= Encode_Utf8(S);
+      end if;
+      return S;
+   end FormatXml;
+
+   function "+"(C: Character) return U_String is
+      Str   : String (1 .. 1);
+   begin
+      Str(1) := C;
+      return + Str;
+   end "+";
+
+   function Create_NodeAttr(N: U_String; V:U_String) return Xml_NodeAttr_Acc is
+      A : Xml_NodeAttr_Acc;
+   begin
+      A := new Xml_NodeAttr;
+      A.N := N; A.V := V;
+      return A;
+   end Create_NodeAttr;
+
+   procedure Process (N : in Xml_Node_Acc) is
+   begin
+      AddAttr(N, + "id", + "001");
+      Print(N.all,0);
+   end Process;
+
+   procedure AddAttr (Node : in Xml_Node_Acc; N,V: U_String ) is
+      Found : Boolean := False;
+      procedure ItFindA (A : Xml_NodeAttr_Cursor) is
+         E : constant Xml_NodeAttr_Acc := Element (A);
+      begin
+         if (E.N = N) then
+            E.V := V; Found := True;
+         end if;
+      end ItFindA;
+   begin
+      Node.Attrs.Iterate (ItFindA'Access);
+      if (Found = False) then
+         Node.Attrs.Append(Create_NodeAttr(N, V));
+      end if;
+   end AddAttr;
+
+   procedure Disp_Tab (Tab: Natural) is
+      Blanks : constant String (1 .. Tab) := (others => ' ');
+   begin
+      Put (Blanks);
+   end Disp_Tab;
+
+   procedure Print (N : in Xml_Node_Type; Tab: Natural) is
+      pragma Unreferenced (N);
+   begin
+      Disp_Tab(Tab); Put_Line("Base-Print");
+   end Print;
+
+   procedure SetTag (N :  in out Xml_Node_Type; Tag: U_String) is
+   begin
+      null;
+   end SetTag;
+
+   -- Pretty Node ------------------------------------
+
+   procedure Print (N :  in Xml_Node_Pretty; Tab: Natural) is
+      NTab: constant Natural := Tab + 1;
+      procedure ItPrint (A : Xml_Node_Cursor) is
+         E : constant Xml_Node_Acc := Element (A);
+      begin
+         Print(E.all,NTab);
+      end ItPrint;
+      procedure ItPrintA (A : Xml_NodeAttr_Cursor) is
+         E : constant Xml_NodeAttr_Acc := Element (A);
+      begin
+         Put((-E.N) & "=""" & (-FormatXml(E.V)) & """ ");
+      end ItPrintA;
+   begin
+      Disp_Tab(Tab); Put( "<" & (- N.Extra) & " ");
+      N.Attrs.Iterate (ItPrintA'Access);
+      if (Length(N.Childs) = 0) then
+         Put_Line("/>");
+      else
+         Put_Line(">");
+         N.Childs.Iterate (ItPrint'Access);
+         Disp_Tab(Tab); Put_Line( "</" & (- N.Extra) & ">");
+      end if;
+   end Print;
+   procedure RemFrom(P:Xml_Node_Acc; C:Xml_Node_Acc) is
+   begin
+      for I in 1 .. Length (P.Childs) loop
+         if P.Childs.Element(Integer(I)) = C then
+            P.Childs.Delete(Integer(I), 1);
+            exit;
+         end if;
+      end loop;
+   end RemFrom;
+
+   procedure SetTag (N :  in out Xml_Node_Pretty; Tag: U_String) is
+   begin
+      N.Extra := Tag;
+   end SetTag;
+
+   function Create_Xml_Node_Pretty(P:Xml_Node_Acc; E: U_String)
+                                   return Xml_Node_Pretty_Acc is
+      Node : Xml_Node_Pretty_Acc ;
+   begin
+      Node := new Xml_Node_Pretty;
+      Node.Extra := E;
+      Node.Parent := P;
+      if P /= null then
+         P.Childs.Append(Xml_Node_Acc(Node));
+      end if;
+      return Node;
+   end Create_Xml_Node_Pretty;
+
+   -- Short Node ------------------------------------
+   procedure Print (N : in Xml_Node_Short; Tab: Natural) is
+   begin
+      --Disp_Tab(Tab); Print(Xml_Node_Type(N));
+      Disp_Tab(Tab); Put_Line(- N.Short);
+   end Print;
+
+   procedure SetTag (N :  in out Xml_Node_Short; Tag: U_String) is
+   begin
+      null;
+   end SetTag;
+
+   function Create_Xml_Node_Short(P:Xml_Node_Acc;E: U_String)
+                                  return Xml_Node_Short_Acc is
+      Node : Xml_Node_Short_Acc ;
+   begin
+      Node := new Xml_Node_Short;
+      Node.Short := E;
+      Node.Parent := P;
+      if P /= null then
+         P.Childs.Append(Xml_Node_Acc(Node));
+      end if;
+      return Node;
+   end Create_Xml_Node_Short;
+
+end disp_xml_node;
--- ghdl-r150-ori/disp_xml_node.ads	2013-07-10 13:07:41.000000000 +0200
+++ ghdl-r150/disp_xml_node.ads	2013-06-28 15:37:15.000000000 +0200
@@ -0,0 +1,86 @@
+with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
+with Ada.Containers.Vectors;
+
+package disp_xml_node is
+
+   subtype U_String is Ada.Strings.Unbounded.Unbounded_String;
+   --use type U_String;
+   function "+"(S: String) return U_String
+     renames Ada.Strings.Unbounded.To_Unbounded_String;
+   function "-"(U: U_String) return String
+     renames Ada.Strings.Unbounded.To_String;
+   function "&" (Left, Right : U_String) return U_String
+     renames Ada.Strings.Unbounded."&";
+   function "=" (Left, Right : U_String) return Boolean
+     renames Ada.Strings.Unbounded."=";
+   function Slice (Source : in U_String;
+                   Low    : in Positive;
+                   High   : in Natural) return String
+     renames Ada.Strings.Unbounded.Slice;
+   function Length (Source : in U_String) return Natural
+     renames Ada.Strings.Unbounded.Length;
+   function "+"(C: Character) return U_String;
+
+   -- Attr ------------------------------------
+   type Xml_NodeAttr_A;
+   type Xml_NodeAttr_Acc is access all Xml_NodeAttr_A'Class;
+   type Xml_NodeAttr_A is abstract tagged record
+      N, V : U_String;
+   end record;
+   package Xml_NodeAttr_Vectors is new Ada.Containers.Vectors (Natural,
+     Xml_NodeAttr_Acc);
+   use Xml_NodeAttr_Vectors;
+   subtype Xml_NodeAttr_Cursor is Xml_NodeAttr_Vectors.Cursor;
+   subtype Xml_NodeAttrs is Xml_NodeAttr_Vectors.Vector;
+   type Xml_NodeAttr is new Xml_NodeAttr_A with null record;
+   function Create_NodeAttr(N: U_String; V:U_String) return Xml_NodeAttr_Acc;
+
+   -- Base Node ------------------------------------
+   type Xml_Node_Type;
+   type Xml_Node_Acc is access all Xml_Node_Type'Class;
+   package Xml_Node_Vectors is new Ada.Containers.Vectors (Natural,
+     Xml_Node_Acc);
+   use Xml_Node_Vectors;
+   subtype Xml_Nodes is Xml_Node_Vectors.Vector;
+   subtype Xml_Node_Cursor is Xml_Node_Vectors.Cursor;
+
+   type Xml_Node_Type is abstract tagged record
+      Next    : Xml_Node_Acc;
+      Childs  : Xml_Nodes;
+      Parent  : Xml_Node_Acc;
+      Attrs   : Xml_NodeAttrs;
+   end record;
+
+   procedure Print (N : in Xml_Node_Type; Tab: Natural);
+   procedure SetTag (N :  in out Xml_Node_Type; Tag: U_String) ;
+   procedure Process (N : in  Xml_Node_Acc);
+   procedure AddAttr (Node : in Xml_Node_Acc; N,V: U_String ) ;
+   procedure RemFrom(P:Xml_Node_Acc; C:Xml_Node_Acc) ;
+
+   -- Pretty Node ------------------------------------
+   type Xml_Node_Pretty;
+   type Xml_Node_Pretty_Acc is access all Xml_Node_Pretty;
+   type Xml_Node_Pretty is new Xml_Node_Type with record
+      Extra: U_String;
+   end record;
+
+   procedure Print (N : in  Xml_Node_Pretty; Tab: Natural) ;
+   procedure SetTag (N :  in out Xml_Node_Pretty; Tag: U_String) ;
+   function Create_Xml_Node_Pretty(P:Xml_Node_Acc; E: U_String)
+                                   return Xml_Node_Pretty_Acc;
+
+   -- Short Node ------------------------------------
+   type Xml_Node_Short;
+   type Xml_Node_Short_Acc is access all Xml_Node_Short;
+   type Xml_Node_Short is new Xml_Node_Type with record
+      Short: U_String;
+   end record;
+
+   procedure Print (N : in  Xml_Node_Short; Tab: Natural) ;
+   procedure SetTag (N :  in out Xml_Node_Short; Tag: U_String) ;
+   function Create_Xml_Node_Short(P:Xml_Node_Acc;E: U_String)
+                                  return Xml_Node_Short_Acc;
+
+end disp_xml_node;
+
+
--- ghdl-r150-ori/disp_xml_vhdl.adb	2013-07-10 13:07:46.000000000 +0200
+++ ghdl-r150/disp_xml_vhdl.adb	2013-07-10 14:11:42.000000000 +0200
@@ -0,0 +1,3389 @@
+--  VHDL regeneration from internal nodes.
+--  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--
+--  GHDL is free software; you can redistribute it and/or modify it under
+--  the terms of the GNU General Public License as published by the Free
+--  Software Foundation; either version 2, or (at your option) any later
+--  version.
+--
+--  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+--  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+--  for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with GHDL; see the file COPYING.  If not, write to the Free
+--  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+--  02111-1307, USA.
+
+
+-- Disp an iir tree.
+-- Try to be as pretty as possible, and to keep line numbers and positions
+-- of the identifiers.
+with Ada.Text_IO; use Ada.Text_IO;
+with Std_Package;
+with Flags; use Flags;
+with Errorout; use Errorout;
+with Iirs_Utils; use Iirs_Utils;
+with Types; use Types;
+with Name_Table;
+with Std_Names;
+with Tokens;
+with PSL.Nodes;
+--with PSL.Prints;
+with PSL.NFAs;
+
+package body disp_xml_vhdl is
+
+   --  Disp the name of DECL.
+   procedure Disp_Name_Of (P,N:X;Decl: Iir);
+
+   Indentation: constant Count := 2;
+
+   -- If set, disp after a string literal the type enclosed into brackets.
+   Disp_String_Literal_Type: constant Boolean := False;
+
+   -- If set, disp position number of associations
+   --Disp_Position_Number: constant Boolean := False;
+
+--    procedure Disp_Tab (N,NewN(N,+"-"),Tab: Natural) is
+--       Blanks : String (1 .. Tab) := (others => ' ');
+--    begin
+--       Put (Blanks);
+--    end Disp_Tab;
+
+   procedure Disp_Type (P,N:X;A_Type: Iir);
+
+   procedure Disp_Expression (P,N:X;Expr: Iir);
+   procedure Disp_Concurrent_Statement (P,N:X;Stmt: Iir);
+   procedure Disp_Concurrent_Statement_Chain
+      (P,N:X;Parent: Iir; Indent : Count);
+   procedure Disp_Declaration_Chain
+     (P,N:X;Parent : Iir; Indent: Count);
+   procedure Disp_Process_Statement (P,N:X;Process: Iir);
+   procedure Disp_Sequential_Statements (P,N:X;First : Iir);
+   procedure Disp_Choice (P,N:X;Choice: in out Iir);
+   procedure Disp_Association_Chain (P,N:X;Chain : Iir);
+   procedure Disp_Block_Configuration
+     (P,N:X;Block: Iir_Block_Configuration; Indent: Count);
+   procedure Disp_Subprogram_Declaration (P,N:X;Subprg: Iir);
+   procedure Disp_Binding_Indication
+     (P,N:X;Bind : Iir; Indent : Count);
+   procedure Disp_Subtype_Indication (P,N:X;Def : Iir;
+                                      Full_Decl : Boolean := False);
+   procedure Disp_Int64 (P,N:X;Val: Iir_Int64);
+   --procedure Disp_Int32 (N,NewN(N,+"-"),Val: Iir_Int32);
+   procedure Disp_Fp64 (P,N:X;Val: Iir_Fp64);
+
+   procedure ChangeTag (E: X; Tree : in Iir) is
+   begin
+      case Get_Kind (Tree) is
+         when Iir_Kind_Design_File =>
+            SetTag(E.all,+"design_file");
+         when Iir_Kind_Design_Unit =>
+            SetTag(E.all, +"design_unit");
+         when Iir_Kind_Use_Clause =>
+            SetTag(E.all,+"use_clause");
+         when Iir_Kind_Slice_Name =>
+            SetTag(E.all,+"slice_name");
+         when Iir_Kind_Library_Clause =>
+            SetTag(E.all, +"library_clause");
+         when Iir_Kind_Library_Declaration =>
+            SetTag(E.all, +"library_declaration");
+         when Iir_Kind_Proxy =>
+            SetTag(E.all,+"proxy");
+         when Iir_Kind_Allocator_By_Expression =>
+            SetTag(E.all,+"allocator_by_expression");
+         when Iir_Kind_Selected_Name =>
+            SetTag(E.all,+"selected_name");
+         when Iir_Kind_Implicit_Dereference =>
+            SetTag(E.all,+"implicit_dereference");
+         when Iir_Kind_Selected_Element =>
+            SetTag(E.all,+"selected_element");
+         when Iir_Kind_Waveform_Element =>
+            SetTag(E.all,+"waveform_element");
+         when Iir_Kind_Type_Conversion =>
+            SetTag(E.all,+"type_conversion");
+         when Iir_Kind_Qualified_Expression =>
+            SetTag(E.all,+"qualified_expression");
+         when Iir_Kind_Package_Declaration =>
+            SetTag(E.all, +"package_declaration");
+         when Iir_Kind_Package_Body =>
+            SetTag(E.all, +"package_body");
+         when Iir_Kind_Entity_Declaration =>
+            SetTag(E.all, +"entity_declaration");
+         when Iir_Kind_Architecture_Declaration =>
+            SetTag(E.all, +"architecture_declaration");
+         when Iir_Kind_Configuration_Declaration =>
+            SetTag(E.all, +"configuration_declaration");
+         when Iir_Kind_Function_Declaration =>
+            SetTag(E.all, +"function_declaration");
+         when Iir_Kind_Function_Body =>
+            SetTag(E.all,+"function_body");
+         when Iir_Kind_Procedure_Declaration =>
+            SetTag(E.all, +"procedure_declaration");
+         when Iir_Kind_Procedure_Body =>
+            SetTag(E.all,+"procedure_body");
+         when Iir_Kind_Object_Alias_Declaration =>
+            SetTag(E.all, +"object_alias_declaration");
+         when Iir_Kind_Non_Object_Alias_Declaration =>
+            SetTag(E.all, +"non_object_alias_declaration");
+         when Iir_Kind_Signal_Interface_Declaration =>
+            SetTag(E.all, +"signal_interface_declaration");
+         when Iir_Kind_Signal_Declaration =>
+            SetTag(E.all, +"signal_declaration");
+         when Iir_Kind_Variable_Interface_Declaration =>
+            SetTag(E.all, +"variable_interface_declaration");
+         when Iir_Kind_Variable_Declaration =>
+            SetTag(E.all,+"variable_declaration");
+         when Iir_Kind_Constant_Interface_Declaration =>
+            SetTag(E.all, +"constant_interface_declaration");
+         when Iir_Kind_Constant_Declaration =>
+            SetTag(E.all, +"constant_declaration");
+         when Iir_Kind_Iterator_Declaration =>
+            SetTag(E.all, +"iterator_declaration");
+         when Iir_Kind_File_Interface_Declaration =>
+            SetTag(E.all, +"file_interface_declaration");
+         when Iir_Kind_File_Declaration =>
+            SetTag(E.all, +"file_declaration");
+         when Iir_Kind_Type_Declaration =>
+            SetTag(E.all, +"type_declaration");
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            SetTag(E.all, +"anonymous_type_declaration");
+         when Iir_Kind_Subtype_Declaration =>
+            SetTag(E.all, +"subtype_declaration");
+         when Iir_Kind_Component_Declaration =>
+            SetTag(E.all, +"component_declaration");
+         when Iir_Kind_Element_Declaration =>
+            SetTag(E.all, +"element_declaration");
+         when Iir_Kind_Record_Element_Constraint =>
+            SetTag(E.all, +"record_element_constraint");
+         when Iir_Kind_Attribute_Declaration =>
+            SetTag(E.all, +"attribute_declaration");
+         when Iir_Kind_Group_Template_Declaration =>
+            SetTag(E.all, +"group_template_declaration");
+         when Iir_Kind_Group_Declaration =>
+            SetTag(E.all, +"group_declaration");
+         when Iir_Kind_Psl_Declaration =>
+            SetTag(E.all, +"psl_declaration");
+         when Iir_Kind_Psl_Expression =>
+            SetTag(E.all,+"psl_expression");
+         when Iir_Kind_Enumeration_Type_Definition =>
+            SetTag(E.all, +"enumeration_type_definition");
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            SetTag(E.all, +"enumeration_subtype_definition");
+         when Iir_Kind_Integer_Subtype_Definition =>
+            SetTag(E.all, +"integer_subtype_definition");
+         when Iir_Kind_Integer_Type_Definition =>
+            SetTag(E.all, +"integer_type_definition");
+         when Iir_Kind_Floating_Subtype_Definition =>
+            SetTag(E.all, +"floating_subtype_definition");
+         when Iir_Kind_Floating_Type_Definition =>
+            SetTag(E.all, +"floating_type_definition");
+         when Iir_Kind_Array_Subtype_Definition =>
+            SetTag(E.all, +"array_subtype_definition");
+         when Iir_Kind_Array_Type_Definition =>
+            SetTag(E.all, +"array_type_definition");
+         when Iir_Kind_Record_Type_Definition =>
+            SetTag(E.all, +"record_type_definition");
+         when Iir_Kind_Access_Type_Definition =>
+            SetTag(E.all, +"access_type_definition");
+         when Iir_Kind_File_Type_Definition =>
+            SetTag(E.all, +"file_type_definition");
+         when Iir_Kind_Subtype_Definition =>
+            SetTag(E.all,+"subtype_definition");
+         when Iir_Kind_Physical_Type_Definition =>
+            SetTag(E.all, +"physical_type_definition");
+         when Iir_Kind_Physical_Subtype_Definition =>
+            SetTag(E.all,+"physical_subtype_definition");
+         when Iir_Kind_Simple_Name =>
+            SetTag(E.all, +"simple_name");
+         when Iir_Kind_Operator_Symbol =>
+            SetTag(E.all,+"operator_symbol");
+         when Iir_Kind_Null_Literal =>
+            SetTag(E.all,+"null_literal");
+         when Iir_Kind_Physical_Int_Literal =>
+            SetTag(E.all,+"physical_int_literal");
+         when Iir_Kind_Bit_String_Literal =>
+            SetTag(E.all,+"bitstring_literal");
+         when Iir_Kind_Physical_Fp_Literal =>
+            SetTag(E.all,+"physical_fp_literal");
+         when Iir_Kind_Component_Instantiation_Statement =>
+            SetTag(E.all, +"component_instantiation_statement");
+         when Iir_Kind_Block_Statement =>
+            SetTag(E.all, +"block_statement");
+         when Iir_Kind_Sensitized_Process_Statement =>
+            SetTag(E.all, +"sensitized_process_statement");
+         when Iir_Kind_Process_Statement =>
+            SetTag(E.all, +"process_statement");
+         when Iir_Kind_Case_Statement =>
+            SetTag(E.all,+"case_statement");
+         when Iir_Kind_If_Statement =>
+            SetTag(E.all,+"if_statement");
+         when Iir_Kind_Elsif =>
+            SetTag(E.all,+"elsif");
+         when Iir_Kind_For_Loop_Statement =>
+            SetTag(E.all,+"for_loop_statement");
+         when Iir_Kind_While_Loop_Statement =>
+            SetTag(E.all,+"while_loop_statement");
+         when Iir_Kind_Exit_Statement =>
+            SetTag(E.all,+"exit_statement");
+         when Iir_Kind_Next_Statement =>
+            SetTag(E.all,+"next_statement");
+         when Iir_Kind_Wait_Statement =>
+            SetTag(E.all,+"wait_statement");
+         when Iir_Kind_Assertion_Statement =>
+            SetTag(E.all,+"assertion_statement");
+         when Iir_Kind_Variable_Assignment_Statement =>
+            SetTag(E.all,+"variable_assignment_statement");
+         when Iir_Kind_Signal_Assignment_Statement =>
+            SetTag(E.all,+"signal_assignment_statement");
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            SetTag(E.all,+"concurrent_assertion_statement");
+         when Iir_Kind_Procedure_Call_Statement =>
+            SetTag(E.all,+"procedure_call_statement");
+         when Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            SetTag(E.all,+"concurrent_procedure_call_statement");
+         when Iir_Kind_Return_Statement =>
+            SetTag(E.all,+"return_statement");
+         when Iir_Kind_Null_Statement =>
+            SetTag(E.all,+"null_statement");
+         when Iir_Kind_Enumeration_Literal =>
+            SetTag(E.all, +"enumeration_literal");
+         when Iir_Kind_Character_Literal =>
+            SetTag(E.all,+"character_literal");
+         when Iir_Kind_Integer_Literal =>
+            SetTag(E.all,+"integer_literal");
+            AddAttr(E,+"val",+ Iir_Int64'Image (Get_Value (Tree)));
+         when Iir_Kind_Floating_Point_Literal =>
+            SetTag(E.all,+"floating_point_literal");
+            AddAttr(E,+"val",+ Iir_Fp64'Image (Get_Fp_Value (Tree)));
+         when Iir_Kind_String_Literal =>
+            SetTag(E.all,+"string_literal");
+            AddAttr(E,+"val",+ Image_String_Lit (Tree));
+         when Iir_Kind_Unit_Declaration =>
+            SetTag(E.all, +"physical_unit");
+         when Iir_Kind_Entity_Class =>
+            SetTag(E.all,+"entity_class");
+            AddAttr(E,+"val",+ Tokens.Image (Get_Entity_Class (Tree)) );
+         when Iir_Kind_Attribute_Name =>
+            SetTag(E.all, +"attribute_name");
+         when Iir_Kind_Implicit_Function_Declaration =>
+            SetTag(E.all, +"implicit_function_declaration");
+         when Iir_Kind_Implicit_Procedure_Declaration =>
+            SetTag(E.all, +"implicit_procedure_declaration");
+         when others =>
+            SetTag(E.all,+Iir_Kind'Image (Get_Kind (Tree)));
+
+      end case;
+   end ChangeTag;
+
+   ------------- str -----------
+   procedure SetId (Nxml:X;Node:Iir) is
+      Res : String (1 .. 10);
+      Hex_Digits : constant array (Int32 range 0 .. 15) of Character
+        := "0123456789abcdef";
+      N : Int32 := Int32 (Node);
+      pragma Unreferenced (Res);
+   begin
+      for I in reverse 2 .. 9 loop
+         Res (I) := Hex_Digits (N mod 16);
+         N := N / 16;
+      end loop;
+      Res (1) := '[';
+      Res (10) := ']';
+      AddAttr(Nxml,+"iir",+(Integer'Image(Integer(Node)))); --Res
+      if Node /= 0 then
+         if  Get_Location (Node) /= Location_Nil then
+            AddAttr(Nxml,+"loc",
+            + Errorout.Get_Location_Str (Get_Location (Node)));
+         end if;
+      end if;
+   end SetId;
+
+   function Str_Ident (Id: Name_Id) return U_String is
+   begin
+      return +(Name_Table.Image (Id));
+   end Str_Ident;
+
+   function Str_Identifier (Node : Iir) return U_String is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Identifier (Node);
+      if Ident /= Null_Identifier then
+         return Str_Ident (Ident);
+      else
+         return +("<anonymous>");
+      end if;
+   end Str_Identifier;
+
+   function Str_Label (Node : Iir) return U_String is
+      Ident : Name_Id;
+   begin
+      Ident := Get_Label (Node);
+      if Ident /= Null_Identifier then
+         return Str_Ident (Ident);
+      else
+         return + ("<anonymous>");
+      end if;
+   end Str_Label;
+
+   function Str_Entity_Kind (Tok : Tokens.Token_Type) return U_String is
+   begin
+      return + (Tokens.Image (Tok));
+   end Str_Entity_Kind;
+
+   function Str_Character_Literal(
+             Lit: Iir_Character_Literal) return U_String is
+   begin
+      return + (''' & Name_Table.Get_Character (Get_Identifier (Lit)) & ''')
+;
+   end Str_Character_Literal;
+   pragma Unreferenced (Str_Character_Literal);
+
+   function Str_Function_Name (Func: Iir) return U_String is
+      use Name_Table;
+      use Std_Names;
+      Id: Name_Id;
+   begin
+      Id := Get_Identifier (Func);
+      case Id is
+         when Name_Id_Operators
+           | Name_Word_Operators
+           | Name_Xnor
+           | Name_Shift_Operators =>
+            return +("""" & Image (Id) & """");
+         when others =>
+            return Str_Ident (Id);
+      end case;
+   end Str_Function_Name;
+
+   --  Disp the name of DECL.
+   function Str_Name_Of (Decl: Iir) return U_String is
+   begin
+      case Get_Kind (Decl) is
+         when Iir_Kind_Component_Declaration
+           | Iir_Kind_Entity_Declaration
+           | Iir_Kind_Architecture_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Configuration_Declaration
+           | Iir_Kind_Type_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_Subtype_Declaration
+           | Iir_Kind_Element_Declaration
+           | Iir_Kind_Record_Element_Constraint
+           | Iir_Kind_Package_Declaration
+           | Iir_Kind_Object_Alias_Declaration
+           | Iir_Kind_Non_Object_Alias_Declaration
+           | Iir_Kind_Iterator_Declaration
+           | Iir_Kind_Library_Declaration
+           | Iir_Kind_Unit_Declaration =>
+            return Str_Identifier (Decl);
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            return ((+'<') & Str_Ident (Get_Identifier (Decl)) & (+'>'));
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            return Str_Function_Name (Decl);
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            return Str_Identifier (Decl);
+         when Iir_Kind_Physical_Subtype_Definition
+           | Iir_Kind_Enumeration_Type_Definition =>
+            return Str_Identifier (Get_Type_Declarator (Decl));
+         when Iir_Kind_Component_Instantiation_Statement =>
+            return Str_Ident (Get_Label (Decl));
+         when Iir_Kind_Design_Unit =>
+            return Str_Name_Of (Get_Library_Unit (Decl));
+         when Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Simple_Name =>
+            return Str_Identifier (Decl);
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement =>
+            return Str_Label (Decl);
+         when others =>
+            Error_Kind ("disp_name_of", Decl);
+            return +("<error>");
+      end case;
+   end Str_Name_Of;
+
+   function Str_Name (Name: Iir) return U_String is
+   begin
+      case Get_Kind (Name) is
+         when Iir_Kind_Selected_By_All_Name =>
+            return (Str_Name (Get_Prefix (Name)) & (+".all"));
+         when Iir_Kind_Dereference =>
+            return (Str_Name (Get_Prefix (Name)) & (+".all")) ;
+         when Iir_Kind_Simple_Name =>
+            return +(Iirs_Utils.Image_Identifier (Name));
+         when Iir_Kind_Selected_Name =>
+            return (Str_Name (Get_Prefix (Name)) & (+".")
+            & Str_Ident (Get_Suffix_Identifier (Name)));
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Implicit_Function_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Function_Declaration
+           | Iir_Kind_Procedure_Declaration =>
+            return Str_Name_Of (Name);
+         when others =>
+            Error_Kind ("disp_name", Name);
+            return +("<error>");
+      end case;
+   end Str_Name;
+
+   function Str_Mode (Mode: Iir_Mode) return U_String is
+   begin
+      case Mode is
+         when Iir_In_Mode =>
+            return +("in ");
+         when Iir_Out_Mode =>
+            return +("out ");
+         when Iir_Inout_Mode =>
+            return +("inout ");
+         when Iir_Buffer_Mode =>
+            return +("buffer ");
+         when Iir_Linkage_Mode =>
+            return +("linkage ");
+         when Iir_Unknown_Mode =>
+            return +("<unknown> ");
+      end case;
+   end Str_Mode;
+
+   function Str_Signal_Kind (Kind: Iir_Signal_Kind) return U_String is
+   begin
+      case Kind is
+         when Iir_No_Signal_Kind =>
+            return +("");
+         when Iir_Register_Kind =>
+            return +(" register");
+         when Iir_Bus_Kind =>
+            return +(" bus");
+      end case;
+   end Str_Signal_Kind;
+
+   function Str_String_Literal (Str : Iir) return U_String is
+      Ptr : String_Fat_Acc;
+      Len : Int32;
+   begin
+      Ptr := Get_String_Fat_Acc (Str);
+      Len := Get_String_Length (Str);
+      return + (String (Ptr (1 .. Len)));
+   end Str_String_Literal;
+
+   function Str_Int64 (Val: Iir_Int64) return U_String is
+      Str: constant String := Iir_Int64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         return + (Str (Str'First + 1 .. Str'Last));
+      else
+         return + (Str);
+      end if;
+   end Str_Int64;
+
+   function Str_Fp64 (Val: Iir_Fp64) return U_String is
+      Str: constant String := Iir_Fp64'Image (Val);
+   begin
+      if Str(Str'First) = ' ' then
+         return + (Str (Str'First + 1 .. Str'Last));
+      else
+         return + (Str);
+      end if;
+   end Str_Fp64;
+
+   -- pragma Unreferenced (Str_Signal_Kind);
+   ------------- /str -----------
+
+
+   procedure Disp_Ident (P,N:X;Id: Name_Id) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"ident");
+      Put (Name_Table.Image (Id) );
+   end Disp_Ident;
+
+   procedure Disp_Identifier (P,N:X;Node : Iir) is
+      pragma Unreferenced (P);
+      Ident : Name_Id;
+   begin
+      SetId(N,Node);
+      SetTag(N.all,+"identifier");
+      Ident := Get_Identifier (Node);
+      if Ident /= Null_Identifier then
+         Disp_Ident (N,NewN(N,+"-"),Ident);
+      else
+         null;--         Put ("<anonymous>");
+      end if;
+   end Disp_Identifier;
+
+   procedure Disp_Label (P,N:X;Node : Iir) is
+      pragma Unreferenced (P);
+      Ident : Name_Id;
+   begin
+      SetId(N,Node);
+      SetTag(N.all,+"label");
+      Ident := Get_Label (Node);
+      if Ident /= Null_Identifier then
+         Disp_Ident (N,NewN(N,+"-"),Ident);
+      else
+         null;--         Put ("<anonymous>");
+      end if;
+   end Disp_Label;
+
+   procedure Disp_Character_Literal (P,N:X;Lit: Iir_Character_Literal) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"character_literal");
+      Put (''' & Name_Table.Get_Character (Get_Identifier (Lit)) & ''');
+   end Disp_Character_Literal;
+
+   procedure Disp_Function_Name (P,N:X;Func: Iir)
+   is
+      pragma Unreferenced (P);
+      use Name_Table;
+      use Std_Names;
+      Id: Name_Id;
+   begin
+      SetId(N,Func);
+      SetTag(N.all,+"function_name");
+      Id := Get_Identifier (Func);
+      case Id is
+         when Name_Id_Operators
+           | Name_Word_Operators
+           | Name_Xnor
+           | Name_Shift_Operators =>
+            Put ("""");
+            Put (Image (Id));
+            Put ("""");
+         when others =>
+            Disp_Ident (N,NewN(N,+"-"),Id);
+      end case;
+   end Disp_Function_Name;
+
+   --  Disp the name of DECL.
+   procedure Disp_Name_Of (P,N:X;Decl: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Decl);
+      SetTag(N.all,+"name_of");
+      case Get_Kind (Decl) is
+         when Iir_Kind_Component_Declaration
+           | Iir_Kind_Entity_Declaration
+           | Iir_Kind_Architecture_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Configuration_Declaration
+           | Iir_Kind_Type_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_Subtype_Declaration
+           | Iir_Kind_Element_Declaration
+           | Iir_Kind_Record_Element_Constraint
+           | Iir_Kind_Package_Declaration
+           | Iir_Kind_Object_Alias_Declaration
+           | Iir_Kind_Non_Object_Alias_Declaration
+           | Iir_Kind_Iterator_Declaration
+           | Iir_Kind_Library_Declaration
+           | Iir_Kind_Unit_Declaration =>
+            Disp_Identifier (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Anonymous_Type_Declaration =>
+            null;--            Put ('<');
+            Disp_Ident (N,NewN(N,+"-"),Get_Identifier (Decl));
+            null;--            Put ('>');
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            Disp_Function_Name (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            Disp_Identifier (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Physical_Subtype_Definition
+           | Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Identifier (N,NewN(N,+"-"),Get_Type_Declarator (Decl));
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Ident (N,NewN(N,+"-"),Get_Label (Decl));
+         when Iir_Kind_Design_Unit =>
+            Disp_Name_Of (N,NewN(N,+"-"),Get_Library_Unit (Decl));
+         when Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Simple_Name =>
+            Disp_Identifier (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement =>
+            Disp_Label (N,NewN(N,+"-"),Decl);
+         when others =>
+            Error_Kind ("disp_name_of", Decl);
+      end case;
+   end Disp_Name_Of;
+
+
+   procedure Disp_Range (P,N:X;Decl: Iir) is
+   begin
+      SetId(N,Decl);
+      SetTag(N.all,+"range");
+      if Get_Kind (Decl) = Iir_Kind_Range_Expression then
+         Disp_Expression (N,NewN(N,+"l"),Get_Left_Limit (Decl)); -- p:l
+         if Get_Direction (Decl) = Iir_To then
+            AddAttr(N,+"dir",+(" to"));
+         else
+            AddAttr(N,+"dir",+(" downto"));
+         end if;
+         Disp_Expression (N,NewN(N,+"r"),Get_Right_Limit (Decl)); -- p:r
+      else
+         if (Get_Kind(Decl) = Iir_Kind_Range_Array_Attribute) then
+            Disp_Expression(N,NewN(N,+"prefix"),Get_Prefix(Decl))
+; -- p:prefix
+            AddAttr(N,+"typ",+("'range"));
+         else
+            Disp_Subtype_Indication (P,N,Decl); -- reent:1
+         end if;
+         -- Disp_Subtype_Indication (N,NewN(N,+"-"),Decl);
+         --  Disp_Name_Of (N,NewN(N,+"-"),Get_Type_Declarator (Decl));
+      end if;
+   end Disp_Range;
+
+   procedure Disp_Name (P,N:X;Name: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Name);
+      SetTag(N.all,+"name");
+      case Get_Kind (Name) is
+         when Iir_Kind_Selected_By_All_Name =>
+            Disp_Name (N,NewN(N,+"-"),Get_Prefix (Name));
+            null;--            Put (".all");
+         when Iir_Kind_Dereference =>
+            Disp_Name (N,NewN(N,+"-"),Get_Prefix (Name));
+            null;--            Put (".all");
+         when Iir_Kind_Simple_Name =>
+            Put (Iirs_Utils.Image_Identifier (Name));
+         when Iir_Kind_Selected_Name =>
+            Disp_Name (N,NewN(N,+"-"),Get_Prefix (Name));
+            null;--            Put (".");
+            Disp_Ident (N,NewN(N,+"-"),Get_Suffix_Identifier (Name));
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Enumeration_Literal
+           | Iir_Kind_Implicit_Function_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Function_Declaration
+           | Iir_Kind_Procedure_Declaration =>
+            Disp_Name_Of (N,NewN(N,+"-"),Name);
+         when others =>
+            Error_Kind ("disp_name", Name);
+      end case;
+   end Disp_Name;
+
+   procedure Disp_Use_Clause (P,N:X;Clause: Iir_Use_Clause) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"use_clause");
+      null;--      Put ("use ");
+      AddAttr(N,+"n",Str_Name(Get_Selected_Name (Clause))); -- f:n
+      null;--      Put_Line (";");
+   end Disp_Use_Clause;
+
+   -- Disp the resolution function (if any) of type definition DEF.
+   procedure Disp_Resolution_Function (P,N:X;Subtype_Def: Iir)
+   is
+      pragma Unreferenced (P);
+      procedure Inner (P:X;Pos:U_String;Def : Iir)
+      is
+         Decl: Iir;
+         N: constant X := X(Create_Xml_Node_Pretty(P,Pos));
+      begin
+         if Get_Kind (Def) in Iir_Kinds_Subtype_Definition then
+            Decl := Get_Resolution_Function (Def);
+            if Decl /= Null_Iir then
+               AddAttr(N,+"n",Str_Name(Decl)); -- f:n
+            else
+               case Get_Kind (Def) is
+                  when Iir_Kind_Array_Subtype_Definition =>
+                     null;--                     Put ('(');
+                     Inner (N,+"inner",Get_Element_Subtype (Def));
+                     null;--                     Put (')');
+                  when others =>
+                     Error_Kind ("disp_resolution_function", Def);
+               end case;
+            end if;
+         end if;
+      end Inner;
+
+   begin
+      SetId(N,Subtype_Def);
+      SetTag(N.all,+"resolution_function");
+      if Get_Resolved_Flag (Subtype_Def) then
+         Inner (N,+"inner",Subtype_Def);
+         null;--         Put (' ');
+      end if;
+   end Disp_Resolution_Function;
+
+   procedure Disp_Integer_Subtype_Definition
+     (P,N:X;Def: Iir_Integer_Subtype_Definition)
+   is
+      pragma Unreferenced (P);
+      Base_Type: Iir_Integer_Type_Definition;
+      Decl: Iir;
+   begin
+      SetTag(N.all,+"integer_subtype_definition");
+      if Def /= Std_Package.Universal_Integer_Subtype_Definition then
+         Base_Type := Get_Base_Type (Def);
+         Decl := Get_Type_Declarator (Base_Type);
+         if Base_Type /= Std_Package.Universal_Integer_Subtype_Definition
+           and then Def /= Decl
+         then
+            AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+            null;--            Put (" ");
+         end if;
+      end if;
+      Disp_Resolution_Function (N,NewN(N,+"-"),Def);
+      null;--      Put ("range ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Range_Constraint (Def));
+      null;--      Put (";");
+   end Disp_Integer_Subtype_Definition;
+
+   procedure Disp_Floating_Subtype_Definition
+     (P,N:X;Def: Iir_Floating_Subtype_Definition)
+   is
+      pragma Unreferenced (P);
+      Base_Type: Iir_Floating_Type_Definition;
+      Decl: Iir;
+   begin
+      SetTag(N.all,+"floating_subtype_definition");
+      if Def /= Std_Package.Universal_Real_Subtype_Definition then
+         Base_Type := Get_Base_Type (Def);
+         Decl := Get_Type_Declarator (Base_Type);
+         if Base_Type /= Std_Package.Universal_Real_Subtype_Definition
+           and then Def /= Decl
+         then
+            AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+            null;--            Put (" ");
+         end if;
+      end if;
+      Disp_Resolution_Function (N,NewN(N,+"res"),Def); --p:res
+      null;--      Put ("range ");
+      Disp_Expression (N,NewN(N,+"range"),Get_Range_Constraint (Def))
+; --p:range
+      null;--      Put (";");
+   end Disp_Floating_Subtype_Definition;
+
+   procedure Disp_Element_Constraint
+     (P,N:X;Def : Iir; Type_Mark : Iir);
+
+   procedure Disp_Array_Element_Constraint (P,N:X;Def : Iir
+; Type_Mark : Iir)
+   is
+      Index : Iir;
+      Def_El : Iir;
+      Tm_El : Iir;
+      Has_Index : Boolean;
+      Has_Own_Element_Subtype : Boolean;
+      Ec : X;
+   begin
+      SetId(N,Def);
+      SetTag(N.all,+"array_element_constraint");
+      Has_Index := Get_Index_Constraint_Flag (Def);
+      Def_El := Get_Element_Subtype (Def);
+      Tm_El := Get_Element_Subtype (Type_Mark);
+      Has_Own_Element_Subtype := Def_El /= Tm_El;
+
+      if not Has_Index and not Has_Own_Element_Subtype then
+         return;
+      end if;
+
+      null;--      Put (" (");
+      if Has_Index then
+         for I in Natural loop  -- chain:[v=Ec|n=arrrange]
+            Ec := NewN(N,+"-");
+            SetTag(Ec.all,+"arrrange");
+            Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+            if Index = Null_Iir then
+               RemFrom(N,Ec);
+            end if;
+            exit when Index = Null_Iir; --exitchain:Ec
+            if I /= 0 then
+               null;--               Put (", ");
+            end if;
+            Disp_Range (Ec,NewN(Ec,+"range"),Index); -- p:range
+         end loop;
+      else
+         null;--         Put ("open");
+      end if;
+      null;--      Put (")");
+
+      if Has_Own_Element_Subtype
+        and then Get_Kind (Def_El) in Iir_Kinds_Composite_Type_Definition
+      then
+         AddAttr(N,+"ownsubtype",+("ownsubtype"));
+         Disp_Element_Constraint (P,N,Def_El, Tm_El); --reent:1
+      end if;
+   end Disp_Array_Element_Constraint;
+
+   procedure Disp_Record_Element_Constraint (P,N:X;Def : Iir)
+   is
+      pragma Unreferenced (P);
+      El_List : constant Iir_List := Get_Elements_Declaration_List (Def);
+      El : Iir;
+      Has_El : Boolean := False;
+      Ec : X;
+   begin
+      SetId(N,Def);
+      SetTag(N.all,+"record_element_constraint");
+      for I in Natural loop -- chain:[v=Ec|n=Enumeration]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"Enumeration");
+         El := Get_Nth_Element (El_List, I);
+         if El = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when El = Null_Iir; --exitchain:Ec
+         if Get_Kind (El) = Iir_Kind_Record_Element_Constraint
+           and then Get_Parent (El) = Def
+         then
+            if Has_El then
+               null;--               Put (", ");
+            else
+               null;--               Put ("(");
+               Has_El := True;
+            end if;
+            AddAttr(Ec,+"n",Str_Name_Of(El)); -- f:n
+            Disp_Element_Constraint (Ec,NewN(Ec,+"-"),Get_Type (El),
+                                     Get_Base_Type (Get_Type (El)));
+         end if;
+      end loop;
+      if Has_El then
+         null;--         Put (")");
+      end if;
+   end Disp_Record_Element_Constraint;
+
+   procedure Disp_Element_Constraint (P,N:X;Def : Iir; Type_Mark : Iir) is
+   begin
+      SetId(N,Def);
+      SetTag(N.all,+"element_constraint");
+      case Get_Kind (Def) is
+         when Iir_Kind_Record_Subtype_Definition =>
+            Disp_Record_Element_Constraint (P,N,Def); --reent:1
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Element_Constraint (P,N,Def, Type_Mark); --reent:1
+         when others =>
+            Error_Kind ("disp_element_constraint", Def);
+      end case;
+   end Disp_Element_Constraint;
+
+   procedure Disp_Subtype_Indication (P,N:X;Def : Iir
+; Full_Decl : Boolean := False)
+   is
+      pragma Unreferenced (P);
+      Type_Mark : Iir;
+      Base_Type : Iir;
+      Decl : Iir;
+   begin
+      SetId(N,Def);
+      SetTag(N.all,+"subtype_indication");
+      Decl := Get_Type_Declarator (Def);
+      if not Full_Decl and then Decl /= Null_Iir then
+         AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+         return;
+      end if;
+
+      -- Resolution function name.
+      Disp_Resolution_Function (N,NewN(N,+"res"),Def); -- p:res
+
+      -- type mark.
+      Type_Mark := Get_Type_Mark (Def);
+      if Type_Mark /= Null_Iir then
+         Decl := Get_Type_Declarator (Type_Mark);
+         AddAttr(N,+"typmark",Str_Name_Of(Decl)); -- f:typmark
+      end if;
+
+      Base_Type := Get_Base_Type (Def);
+      case Get_Kind (Base_Type) is
+         when Iir_Kind_Integer_Type_Definition
+           | Iir_Kind_Enumeration_Type_Definition
+           | Iir_Kind_Floating_Type_Definition
+           | Iir_Kind_Physical_Type_Definition =>
+            if Type_Mark = Null_Iir
+              or else Get_Range_Constraint (Def)
+              /= Get_Range_Constraint (Type_Mark)
+            then
+               if Type_Mark /= Null_Iir then
+                  null;--                  Put (" range ");
+               end if;
+               Disp_Expression (N,NewN(N,+"-"),Get_Range_Constraint (Def));
+            end if;
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Element_Constraint (N,NewN(N,+"array"),Def
+, Type_Mark); -- p:array
+         when Iir_Kind_Record_Type_Definition =>
+            Disp_Record_Element_Constraint (N,NewN(N,+"record"),Def)
+; -- p:record
+         when others =>
+            Error_Kind ("disp_subtype_indication", Base_Type);
+      end case;
+   end Disp_Subtype_Indication;
+
+   procedure Disp_Enumeration_Type_Definition
+     (P,N:X;Def: Iir_Enumeration_Type_Definition)
+   is
+      pragma Unreferenced (P);
+      Len : Count;
+      Start_Col: Count;
+      Decl: Name_Id;
+      A_Lit: Iir; --Enumeration_Literal_Acc;
+      pragma Unreferenced (Start_Col);
+      Ec : X;
+   begin
+      SetTag(N.all,+"enumeration_type_definition");
+      for I in Natural loop -- chain:[v=Ec|n=Enumeration]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"Enumeration");
+         A_Lit := Get_Nth_Element (Get_Enumeration_Literal_List (Def), I);
+         if A_Lit = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when A_Lit = Null_Iir; --exitchain:Ec
+         if I = Natural'first then
+            null;--            Put ("(");
+            Start_Col := Col;
+         else
+            null;--            Put (", ");
+         end if;
+         Decl := Get_Identifier (A_Lit);
+         if Name_Table.Is_Character (Decl) then
+            Len := 3;
+         else
+            Len := Count (Name_Table.Get_Name_Length (Decl));
+         end if;
+         if Col + Len + 2 > Line_Length then
+            null;--            New_Line;
+            null;--            Set_Col (Start_Col);
+         end if;
+         AddAttr(Ec,+"n",Str_Name_Of(A_Lit)); -- f:n
+      end loop;
+      null;--      Put (");");
+   end Disp_Enumeration_Type_Definition;
+
+   procedure Disp_Enumeration_Subtype_Definition
+     (P,N:X;Def: Iir_Enumeration_Subtype_Definition)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"enumeration_subtype_definition");
+      Disp_Resolution_Function (N,NewN(N,+"-"),Def);
+      null;--      Put ("range ");
+      Disp_Range (N,NewN(N,+"-"),Def);
+      null;--      Put (";");
+   end Disp_Enumeration_Subtype_Definition;
+
+   procedure Disp_Array_Subtype_Definition
+     (P,N:X;Def: Iir_Array_Subtype_Definition)
+   is
+      pragma Unreferenced (P);
+      Index: Iir;
+      Ec : X;
+   begin
+      SetTag(N.all,+"array_subtype_definition");
+      Disp_Resolution_Function (N,NewN(N,+"-"),Def);
+
+      null;--      Put ("array (");
+      for I in Natural loop -- chain:[v=Ec|n=arrrange]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"arrrange");
+         Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+         if Index = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when Index = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            null;--            Put (", ");
+         end if;
+         Disp_Subtype_Indication (Ec,NewN(Ec,+"range"),Index); --p:range
+      end loop;
+      null;--      Put (") of ");
+      Disp_Subtype_Indication (N,NewN(N,+"typ"),Get_Element_Subtype (Def))
+; --p:typ
+   end Disp_Array_Subtype_Definition;
+
+   procedure Disp_Array_Type_Definition (P,N:X
+;Def: Iir_Array_Type_Definition) is
+      pragma Unreferenced (P);
+      Index: Iir;
+      Ec : X;
+   begin
+      SetTag(N.all,+"array_type_definition");
+      null;--      Put ("array (");
+      for I in Natural loop -- chain:[v=Ec|n=arrrange]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"arrrange");
+         Index := Get_Nth_Element (Get_Index_Subtype_List (Def), I);
+         if Index = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when Index = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            null;--            Put (", ");
+         end if;
+         Disp_Subtype_Indication (Ec,NewN(Ec,+"range"),Index); --p:range
+         null;--         Put (" range <>");
+      end loop;
+      null;--      Put (") of ");
+      Disp_Type (N,NewN(N,+"typ"),Get_Element_Subtype (Def)); --p:typ
+      null;--      Put (";");
+   end Disp_Array_Type_Definition;
+
+   procedure Disp_Physical_Literal (P,N:X;Lit: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Lit);
+      SetTag(N.all,+"physical_literal");
+      case Get_Kind (Lit) is
+         when Iir_Kind_Physical_Int_Literal =>
+            AddAttr(N,+"v",Str_Int64(Get_Value (Lit))); -- f:v
+         when Iir_Kind_Physical_Fp_Literal =>
+            AddAttr(N,+"v",Str_Fp64(Get_Fp_Value (Lit))); -- f:v
+         when others =>
+            Error_Kind ("disp_physical_literal", Lit);
+      end case;
+      null;--      Put (' ');
+      AddAttr(N,+"unit",Str_Identifier(Get_Unit_Name (Lit))); -- f:unit
+   end Disp_Physical_Literal;
+
+   procedure Disp_Physical_Subtype_Definition
+     (P,N:X;Def: Iir_Physical_Subtype_Definition; Indent: Count)
+   is
+      pragma Unreferenced (P);
+      Base_Type: Iir;
+      Unit: Iir_Unit_Declaration;
+      Ec : X;
+      pragma Unreferenced (Indent);
+   begin
+      SetTag(N.all,+"physical_subtype_definition");
+      Disp_Resolution_Function (N,NewN(N,+"-"),Def);
+      null;--      Put ("range ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Range_Constraint (Def));
+      Base_Type := Get_Base_Type (Def);
+      if Get_Type_Declarator (Base_Type) = Get_Type_Declarator (Def) then
+         null;--         Put_Line (" units");
+         null;--         Set_Col (Indent + Indentation);
+         Unit := Get_Unit_Chain (Base_Type);
+         AddAttr(N,+"nunit",Str_Identifier(Unit)); -- f:nunit
+         null;--         Put_Line (";");
+         Unit := Get_Chain (Unit);
+         while Unit /= Null_Iir loop -- chain:[v=Ec|n=unit]
+            Ec := NewN(N,+"-");
+            SetTag(Ec.all,+"unit");
+            null;--            Set_Col (Indent + Indentation);
+            AddAttr(Ec,+"n",Str_Identifier(Unit)); -- f:n
+            null;--            Put (" = ");
+            Disp_Physical_Literal (Ec,NewN(Ec,+"-")
+,Get_Physical_Literal (Unit));
+            null;--            Put_Line (";");
+            Unit := Get_Chain (Unit);
+         end loop;
+         null;--         Set_Col (Indent);
+         null;--         Put ("end units;");
+      end if;
+   end Disp_Physical_Subtype_Definition;
+
+   procedure Disp_Record_Type_Definition
+     (P,N:X;Def: Iir_Record_Type_Definition; Indent: Count)
+   is
+      pragma Unreferenced (P);
+      List : Iir_List;
+      El: Iir_Element_Declaration;
+      pragma Unreferenced (Indent);
+      Ec : X;
+   begin
+      SetTag(N.all,+"record_type_definition");
+      null;--      Put_Line ("record");
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("begin");
+      List := Get_Elements_Declaration_List (Def);
+      for I in Natural loop -- chain:[v=Ec|n=entry]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"entry");
+         El := Get_Nth_Element (List, I);
+         if El = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when El = Null_Iir; --exitchain:Ec
+         null;--         Set_Col (Indent + Indentation);
+         AddAttr(Ec,+"n",Str_Identifier(El)); -- f:n
+         null;--         Put (" : ");
+         Disp_Subtype_Indication (Ec,NewN(Ec,+"-"),Get_Type (El));
+         null;--         Put_Line (";");
+      end loop;
+      null;--      Set_Col (Indent);
+      null;--      Put ("end record;");
+   end Disp_Record_Type_Definition;
+
+   procedure Disp_Designator_List (P,N:X;List: Iir_List) is
+      pragma Unreferenced (P);
+      El: Iir;
+   begin
+      SetTag(N.all,+"designator_list");
+      if List = Null_Iir_List then
+         return;
+      end if;
+      for I in Natural loop
+         El := Get_Nth_Element (List, I);
+         exit when El = Null_Iir;
+         if I > 0 then
+            null;--            Put (", ");
+         end if;
+         Disp_Expression (N,NewN(N,+"-"),El);
+         --Disp_Text_Literal (N,NewN(N,+"-"),El);
+      end loop;
+   end Disp_Designator_List;
+
+   -- Display the full definition of a type, ie the sequence that can create
+   -- such a type.
+   procedure Disp_Type_Definition (P,N:X;Decl: in Iir; Indent: Count) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"type_definition");
+      case Get_Kind (Decl) is
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Enumeration_Type_Definition (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            Disp_Enumeration_Subtype_Definition (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Integer_Subtype_Definition =>
+            Disp_Integer_Subtype_Definition (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Floating_Subtype_Definition =>
+            Disp_Floating_Subtype_Definition (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Type_Definition (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Subtype_Definition (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Physical_Subtype_Definition =>
+            Disp_Physical_Subtype_Definition (N,NewN(N,+"-"),Decl, Indent);
+         when Iir_Kind_Record_Type_Definition =>
+            Disp_Record_Type_Definition (N,NewN(N,+"-"),Decl, Indent);
+         when Iir_Kind_Access_Type_Definition =>
+            AddAttr(N,+"typ",+("access"));
+            Disp_Subtype_Indication (N,NewN(N,+"-")
+,Get_Designated_Type (Decl));
+            null;--            Put (';');
+         when Iir_Kind_File_Type_Definition =>
+            null;--            Put ("file of ");
+            Disp_Subtype_Indication (N,NewN(N,+"-"),Get_Type_Mark (Decl));
+            null;--            Put (';');
+         when Iir_Kind_Protected_Type_Declaration =>
+            null;--            Put_Line ("protected");
+            Disp_Declaration_Chain (N,NewN(N,+"-"),Decl
+, Indent + Indentation);
+            null;--            Set_Col (Indent);
+            null;--            Put ("end protected;");
+         when Iir_Kind_Integer_Type_Definition =>
+            null;--            Put ("<integer base type>");
+         when Iir_Kind_Floating_Type_Definition =>
+            null;--            Put ("<floating base type>");
+         when Iir_Kind_Physical_Type_Definition =>
+            null;--            Put ("<physical base type>");
+         when others =>
+            Error_Kind ("disp_type_definition", Decl);
+      end case;
+   end Disp_Type_Definition;
+
+   procedure Disp_Type_Declaration (P,N:X;Decl: Iir_Type_Declaration)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      Def : Iir;
+   begin
+      SetTag(N.all,+"type_declaration");
+      Indent := Col;
+      null;--      Put ("type ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      Def := Get_Type (Decl);
+      if Def = Null_Iir
+        or else Get_Kind (Def) = Iir_Kind_Incomplete_Type_Definition
+      then
+         null;--         Put_Line (";");
+      else
+         null;--         Put (" is ");
+         Disp_Type_Definition (N,NewN(N,+"-"),Def, Indent);
+         null;--         New_Line;
+      end if;
+   end Disp_Type_Declaration;
+
+   procedure Disp_Anonymous_Type_Declaration
+     (P,N:X;Decl: Iir_Anonymous_Type_Declaration)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      Def : Iir;
+      Ec : X;
+   begin
+      SetTag(N.all,+"anonymous_type_declaration");
+      Indent := Col;
+      null;--      Put ("-- type ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      null;--      Put (" is ");
+      Def := Get_Type (Decl);
+      Disp_Type_Definition (N,NewN(N,+"-"),Def, Indent);
+      if Get_Kind (Def) = Iir_Kind_Physical_Type_Definition then
+         declare
+            Unit : Iir_Unit_Declaration;
+         begin
+            null;--            Put_Line (" units");
+            null;--            Set_Col (Indent);
+            null;--            Put ("--   ");
+            Unit := Get_Unit_Chain (Def);
+            AddAttr(N,+"nunit",Str_Identifier(Unit)); -- f:nunit
+            null;--            Put_Line (";");
+            Unit := Get_Chain (Unit);
+            while Unit /= Null_Iir loop -- chain:[v=Ec|n=unit]
+               Ec := NewN(N,+"-");
+               SetTag(Ec.all,+"unit");
+               null;--               Set_Col (Indent);
+               null;--               Put ("--   ");
+               AddAttr(Ec,+"n",Str_Identifier(Unit)); -- f:n
+               null;--               Put (" = ");
+               Disp_Physical_Literal (Ec,NewN(Ec,+"-")
+,Get_Physical_Literal (Unit));
+               null;--               Put_Line (";");
+               Unit := Get_Chain (Unit);
+            end loop;
+            null;--            Set_Col (Indent);
+            null;--            Put ("-- end units;");
+         end;
+      end if;
+      null;--      New_Line;
+   end Disp_Anonymous_Type_Declaration;
+
+   procedure Disp_Subtype_Declaration (P,N:X
+;Decl: in Iir_Subtype_Declaration) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"subtype_declaration");
+      null;--      Put ("subtype ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); --f:n
+      null;--      Put (" is ");
+      Disp_Subtype_Indication (N,NewN(N,+"-"),Get_Type (Decl), True);
+      null;--      Put_Line (";");
+   end Disp_Subtype_Declaration;
+
+   procedure Disp_Type (P,N:X;A_Type: Iir)
+   is
+      pragma Unreferenced (P);
+      Decl: Iir;
+   begin
+      SetId(N,A_Type);
+      SetTag(N.all,+"type");
+      Decl := Get_Type_Declarator (A_Type);
+      if Decl /= Null_Iir then
+         AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      else
+         case Get_Kind (A_Type) is
+            when Iir_Kind_Enumeration_Type_Definition
+              | Iir_Kind_Integer_Type_Definition =>
+               raise Program_Error;
+            when Iir_Kind_Integer_Subtype_Definition
+              | Iir_Kind_Enumeration_Subtype_Definition =>
+               Disp_Subtype_Indication (N,NewN(N,+"-"),A_Type);
+            when Iir_Kind_Array_Subtype_Definition =>
+               Disp_Subtype_Indication (N,NewN(N,+"-"),A_Type);
+            when others =>
+               Error_Kind ("disp_type", A_Type);
+         end case;
+      end if;
+   end Disp_Type;
+
+   procedure Disp_Mode (P,N:X;Mode: Iir_Mode) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"mode");
+      case Mode is
+         when Iir_In_Mode =>
+            null;--            Put ("in ");
+         when Iir_Out_Mode =>
+            null;--            Put ("out ");
+         when Iir_Inout_Mode =>
+            null;--            Put ("inout ");
+         when Iir_Buffer_Mode =>
+            null;--            Put ("buffer ");
+         when Iir_Linkage_Mode =>
+            null;--            Put ("linkage ");
+         when Iir_Unknown_Mode =>
+            null;--            Put ("<unknown> ");
+      end case;
+   end Disp_Mode;
+   pragma Unreferenced (Disp_Mode);
+
+   procedure Disp_Signal_Kind (P,N:X;Kind: Iir_Signal_Kind) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"signal_kind");
+      case Kind is
+         when Iir_No_Signal_Kind =>
+            null;
+         when Iir_Register_Kind =>
+            null;--            Put (" register");
+         when Iir_Bus_Kind =>
+            null;--            Put (" bus");
+      end case;
+   end Disp_Signal_Kind;
+   pragma Unreferenced (Disp_Signal_Kind);
+
+   procedure Disp_Interface_Declaration (P,N:X;Inter: Iir)
+   is
+      pragma Unreferenced (P);
+      Default: Iir;
+   begin
+      SetId(N,Inter);
+      SetTag(N.all,+"interface_declaration");
+      case Get_Kind (Inter) is
+         when Iir_Kind_Signal_Interface_Declaration =>
+            null;--            Put ("signal ");
+         when Iir_Kind_Variable_Interface_Declaration =>
+            null;--            Put ("variable ");
+         when Iir_Kind_Constant_Interface_Declaration =>
+            null;--            Put ("constant ");
+         when Iir_Kind_File_Interface_Declaration =>
+            null;--            Put ("file ");
+         when others =>
+            Error_Kind ("disp_interface_declaration", Inter);
+      end case;
+      AddAttr(N,+"n",Str_Name_Of(Inter)); -- f:n
+      null;--      Put (": ");
+      AddAttr(N,+"mode",Str_Mode(Get_Mode (Inter))); --f:mode
+      Disp_Type (N,NewN(N,+"-"),Get_Type (Inter));
+      if Get_Kind (Inter) = Iir_Kind_Signal_Interface_Declaration then
+         AddAttr(N,+"sigkind",Str_Signal_Kind(Get_Signal_Kind (Inter)))
+; -- f:sigkind
+      end if;
+      Default := Get_Default_Value (Inter);
+      if Default /= Null_Iir then
+         null;--         Put (" := ");
+         Disp_Expression (N,NewN(N,+"-"),Default);
+      end if;
+   end Disp_Interface_Declaration;
+
+   procedure Disp_Interface_Chain (P,N:X;Chain: Iir; Str: String)
+   is
+      pragma Unreferenced (P);
+      Inter: Iir;
+      Start: Count;
+      pragma Unreferenced (Start);
+      pragma Unreferenced (Str);
+   begin
+      SetId(N,Chain);
+      SetTag(N.all,+"interface_chain");
+      if Chain = Null_Iir then
+         return;
+      end if;
+      null;--      Put (" (");
+      Start := Col;
+      Inter := Chain;
+      while Inter /= Null_Iir loop
+         null;--         Set_Col (Start);
+         Disp_Interface_Declaration (N,NewN(N,+"-"),Inter);
+         if Get_Chain (Inter) /= Null_Iir then
+            null;--            Put ("; ");
+         else
+            null;--            Put (')');
+            null;--            Put (Str); -- nop:1
+         end if;
+         Inter := Get_Chain (Inter);
+      end loop;
+   end Disp_Interface_Chain;
+
+   procedure Disp_Ports (P,N:X;Parent : Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Parent);
+      SetTag(N.all,+"ports");
+      null;--      Put ("port");
+      Disp_Interface_Chain (N,NewN(N,+"-"),Get_Port_Chain (Parent), ";");
+   end Disp_Ports;
+
+   procedure Disp_Generics (P,N:X;Parent : Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Parent);
+      SetTag(N.all,+"generics");
+      null;--      Put ("generic");
+      Disp_Interface_Chain (N,NewN(N,+"-"),Get_Generic_Chain (Parent), ";");
+   end Disp_Generics;
+
+   procedure Disp_Entity_Declaration (P,N:X;Decl: Iir_Entity_Declaration) is
+      pragma Unreferenced (P);
+      Start: Count;
+   begin
+      SetTag(N.all,+"entity_declaration");
+      Start := Col;
+      null;--      Put ("entity ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); --f:n
+      null;--      Put_Line (" is");
+      if Get_Generic_Chain (Decl) /= Null_Iir then
+         null;--         Set_Col (Start + Indentation);
+         Disp_Generics (N,NewN(N,+"-"),Decl);
+      end if;
+      if Get_Port_Chain (Decl) /= Null_Iir then
+         null;--         Set_Col (Start + Indentation);
+         Disp_Ports (N,NewN(N,+"-"),Decl);
+      end if;
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Decl, Start + Indentation);
+      if Get_Concurrent_Statement_Chain (Decl) /= Null_Iir then
+         null;--         Set_Col (Start);
+         null;--         Put_Line ("begin");
+         Disp_Concurrent_Statement_Chain (N,NewN(N,+"-"),Decl
+, Start + Indentation);
+      end if;
+      null;--      Set_Col (Start);
+      null;--      Put_Line ("end entity;");
+   end Disp_Entity_Declaration;
+
+   procedure Disp_Component_Declaration (P,N:X
+;Decl: Iir_Component_Declaration)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      pragma Unreferenced (Indent);
+   begin
+      SetTag(N.all,+"component_declaration");
+      Indent := Col;
+      null;--      Put ("component ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      if Get_Generic_Chain (Decl) /= Null_Iir then
+         null;--         Set_Col (Indent + Indentation);
+         Disp_Generics (N,NewN(N,+"-"),Decl);
+      end if;
+      if Get_Port_Chain (Decl) /= Null_Iir then
+         null;--         Set_Col (Indent + Indentation);
+         Disp_Ports (N,NewN(N,+"-"),Decl);
+      end if;
+      null;--      Set_Col (Indent);
+      null;--      Put ("end component;");
+   end Disp_Component_Declaration;
+
+   procedure Disp_Concurrent_Statement_Chain (P,N:X;Parent : Iir
+; Indent : Count)
+   is
+      pragma Unreferenced (P);
+      El: Iir;
+      pragma Unreferenced (Indent);
+   begin
+      SetId(N,Parent);
+      SetTag(N.all,+"concurrent_statement_chain");
+      El := Get_Concurrent_Statement_Chain (Parent);
+      while El /= Null_Iir loop
+         null;--         Set_Col (Indent);
+         Disp_Concurrent_Statement (N,NewN(N,+"-"),El);
+         El := Get_Chain (El);
+      end loop;
+   end Disp_Concurrent_Statement_Chain;
+
+   procedure Disp_Architecture_Declaration (P,N:X
+;Arch: Iir_Architecture_Declaration)
+   is
+      pragma Unreferenced (P);
+      Start: Count;
+   begin
+      SetTag(N.all,+"architecture_declaration");
+      Start := Col;
+      null;--      Put ("architecture ");
+      AddAttr(N,+"n",Str_Name_Of(Arch)); -- f:n
+      null;--      Put (" of ");
+      AddAttr(N,+"of",Str_Name_Of(Get_Entity (Arch))); -- f:of
+      null;--      Put_Line (" is");
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Arch, Start + Indentation);
+      null;--      Set_Col (Start);
+      null;--      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (N,NewN(N,+"-"),Arch
+, Start + Indentation);
+      null;--      Set_Col (Start);
+      null;--      Put_Line ("end;");
+   end Disp_Architecture_Declaration;
+
+   procedure Disp_Object_Alias_Declaration (P,N:X
+;Decl: Iir_Object_Alias_Declaration)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"object_alias_declaration");
+      null;--      Put ("alias ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      null;--      Put (": ");
+      Disp_Type (N,NewN(N,+"-"),Get_Type (Decl));
+      null;--      Put (" is ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Name (Decl));
+      null;--      Put_Line (";");
+   end Disp_Object_Alias_Declaration;
+
+   procedure Disp_Non_Object_Alias_Declaration
+     (P,N:X;Decl: Iir_Non_Object_Alias_Declaration)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"non_object_alias_declaration");
+      null;--      Put ("alias ");
+      AddAttr(N,+"n",Str_Function_Name(Decl)); -- f:n
+      null;--      Put (" is ");
+      AddAttr(N,+"alias",Str_Name(Get_Name (Decl))); -- f:alias
+      null;--      Put_Line (";");
+   end Disp_Non_Object_Alias_Declaration;
+
+   procedure Disp_File_Declaration (P,N:X;Decl: Iir_File_Declaration) is
+      pragma Unreferenced (P);
+      Expr: Iir;
+   begin
+      SetTag(N.all,+"file_declaration");
+      null;--      Put ("file ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      null;--      Put (": ");
+      Disp_Type (N,NewN(N,+"-"),Get_Type (Decl));
+      if Vhdl_Std = Vhdl_87 then
+         null;--         Put (" is ");
+         AddAttr(N,+"mode",Str_Mode(Get_Mode (Decl))); --f:mode
+         Disp_Expression (N,NewN(N,+"-"),Get_File_Logical_Name (Decl));
+      else
+         Expr := Get_File_Open_Kind (Decl);
+         if Expr /= Null_Iir then
+            null;--            Put (" open ");
+            Disp_Expression (N,NewN(N,+"-"),Expr);
+         end if;
+         Expr := Get_File_Logical_Name (Decl);
+         if Expr /= Null_Iir then
+            null;--            Put (" is ");
+            Disp_Expression (N,NewN(N,+"-"),Expr);
+         end if;
+      end if;
+      null;--      Put (';');
+   end Disp_File_Declaration;
+
+   procedure Disp_Object_Declaration (P,N:X;Decl: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Decl);
+      SetTag(N.all,+"object_declaration");
+      case Get_Kind (Decl) is
+         when Iir_Kind_Variable_Declaration =>
+            if Get_Shared_Flag (Decl) then
+               null;--               Put ("shared ");
+            end if;
+            AddAttr(N,+"typ",+("variable"));
+         when Iir_Kind_Constant_Declaration =>
+            AddAttr(N,+"typ",+("constant"));
+         when Iir_Kind_Signal_Declaration =>
+            AddAttr(N,+"typ",+("signal"));
+         when Iir_Kind_Object_Alias_Declaration =>
+            AddAttr(N,+"typ",+"alias");
+            Disp_Object_Alias_Declaration (N,NewN(N,+"-"),Decl)
+; --s:[typ=alias]
+
+            return;
+         when Iir_Kind_File_Declaration =>
+            AddAttr(N,+"typ",+"file");
+            Disp_File_Declaration (N,NewN(N,+"-"),Decl); --s:[typ=file]
+
+            return;
+         when others =>
+            raise Internal_Error;
+      end case;
+      AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      null;--      Put (": ");
+      Disp_Type (N,NewN(N,+"-"),Get_Type (Decl));
+      if Get_Kind (Decl) = Iir_Kind_Signal_Declaration then
+         AddAttr(N,+"sigkind",Str_Signal_Kind(Get_Signal_Kind (Decl)))
+;  -- f:sigkind
+      end if;
+
+      if Get_Default_Value (Decl) /= Null_Iir then
+         null;--         Put (" := ");
+         Disp_Expression (N,NewN(N,+"-"),Get_Default_Value (Decl));
+      end if;
+      null;--      Put_Line (";");
+   end Disp_Object_Declaration;
+
+   procedure Disp_Subprogram_Declaration (P,N:X;Subprg: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Subprg);
+      SetTag(N.all,+"subprogram_declaration");
+      case Get_Kind (Subprg) is
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            AddAttr(N,+"typ",+("function"));
+            AddAttr(N,+"n",Str_Function_Name(Subprg));  -- f:n
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            AddAttr(N,+"typ",+("procedure"));
+            AddAttr(N,+"n",Str_Identifier(Subprg));  -- f:n
+         when others =>
+            raise Internal_Error;
+      end case;
+
+      Disp_Interface_Chain (N,NewN(N,+"-")
+,Get_Interface_Declaration_Chain (Subprg), "");
+
+      case Get_Kind (Subprg) is
+         when Iir_Kind_Function_Declaration
+           | Iir_Kind_Implicit_Function_Declaration =>
+            null;--            Put (" return ");
+            Disp_Type (N,NewN(N,+"rtyp"),Get_Return_Type (Subprg))
+; --p:rtyp
+         when Iir_Kind_Procedure_Declaration
+           | Iir_Kind_Implicit_Procedure_Declaration =>
+            null;
+         when others =>
+            raise Internal_Error;
+      end case;
+   end Disp_Subprogram_Declaration;
+
+   procedure Disp_Subprogram_Body (P,N:X;Subprg : Iir)
+   is
+      pragma Unreferenced (P);
+      Decl : Iir;
+      Indent : Count;
+   begin
+      SetId(N,Subprg);
+      SetTag(N.all,+"subprogram_body");
+      Decl := Get_Subprogram_Specification (Subprg);
+      Indent := Col;
+      if Get_Chain (Decl) /= Subprg then
+         Disp_Subprogram_Declaration (N,NewN(N,+"-"),Decl);
+      end if;
+      null;--      Put_Line ("is");
+      null;--      Set_Col (Indent);
+      Disp_Declaration_Chain (N,NewN(N,+"decl"),Subprg
+, Indent + Indentation); -- p:decl
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("begin");
+      null;--      Set_Col (Indent + Indentation);
+      Disp_Sequential_Statements (N,NewN(N,+"b")
+,Get_Sequential_Statement_Chain (Subprg)); -- p:b
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("end;");
+      null;--      New_Line;
+   end Disp_Subprogram_Body;
+
+   procedure Disp_Instantiation_List (P,N:X;Insts: Iir_List) is
+      pragma Unreferenced (P);
+      El : Iir;
+      Ec : X;
+   begin
+      SetTag(N.all,+"instantiation_list");
+      if Insts = Iir_List_All then
+         AddAttr(N,+"typ",+("all"));
+      elsif Insts = Iir_List_Others then
+         AddAttr(N,+"typ",+("others"));
+      else
+         for I in Natural loop -- chain:[v=Ec|n=instantiation]
+            Ec := NewN(N,+"-");
+            SetTag(Ec.all,+"instantiation");
+            El := Get_Nth_Element (Insts, I);
+            if El = Null_Iir then
+               RemFrom(N,Ec);
+            end if;
+            exit when El = Null_Iir; --exitchain:Ec
+            if I /= Natural'First then
+               null;--               Put (", ");
+            end if;
+            AddAttr(Ec,+"n",Str_Name_Of(El)); --f:n
+         end loop;
+      end if;
+   end Disp_Instantiation_List;
+
+   procedure Disp_Configuration_Specification
+     (P,N:X;Spec : Iir_Configuration_Specification)
+   is
+      pragma Unreferenced (P);
+      Indent : Count;
+   begin
+      SetTag(N.all,+"configuration_specification");
+      Indent := Col;
+      null;--      Put ("for ");
+      Disp_Instantiation_List (N,NewN(N,+"-"),Get_Instantiation_List (Spec))
+;
+      null;--      Put (": ");
+      AddAttr(N,+"n",Str_Name_Of(Get_Component_Name (Spec))); -- f:n
+      null;--      New_Line;
+      Disp_Binding_Indication (N,NewN(N,+"-"),Get_Binding_Indication (Spec),
+                               Indent + Indentation);
+      null;--      Put_Line (";");
+   end Disp_Configuration_Specification;
+
+   procedure Disp_Disconnection_Specification
+     (P,N:X;Dis : Iir_Disconnection_Specification)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"disconnection_specification");
+      null;--      Put ("disconnect ");
+      Disp_Instantiation_List (N,NewN(N,+"-"),Get_Signal_List (Dis));
+      null;--      Put (": ");
+      Disp_Subtype_Indication (N,NewN(N,+"-"),Get_Type (Dis));
+      null;--      Put (" after ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Expression (Dis));
+      null;--      Put_Line (";");
+   end Disp_Disconnection_Specification;
+
+   procedure Disp_Attribute_Declaration (P,N:X
+;Attr : Iir_Attribute_Declaration)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"attribute_declaration");
+      null;--      Put ("attribute ");
+      AddAttr(N,+"n",Str_Identifier(Attr)); -- f:n
+      null;--      Put (": ");
+      Disp_Type (N,NewN(N,+"-"),Get_Type (Attr));
+      null;--      Put_Line (";");
+   end Disp_Attribute_Declaration;
+
+   procedure Disp_Entity_Kind (P,N:X;Tok : Tokens.Token_Type) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"entity_kind");
+      Put (Tokens.Image (Tok));
+   end Disp_Entity_Kind;
+   pragma Unreferenced (Disp_Entity_Kind);
+   procedure Disp_Entity_Name_List (P,N:X;List : Iir_List)
+   is
+      pragma Unreferenced (P);
+      El : Iir;
+      Ec : X;
+   begin
+      SetTag(N.all,+"entity_name_list");
+      for I in Natural loop -- chain:[v=Ec|n=Name]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"Name");
+         El := Get_Nth_Element (List, I);
+         if El = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when El = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            null;--            Put (", ");
+         end if;
+         AddAttr(Ec,+"n",Str_Name_Of(El)); -- f:n
+      end loop;
+   end Disp_Entity_Name_List;
+
+   procedure Disp_Attribute_Specification (P,N:X
+;Attr : Iir_Attribute_Specification)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"attribute_specification");
+      null;--      Put ("attribute ");
+      AddAttr(N,+"n",Str_Identifier(Get_Attribute_Designator (Attr)))
+; -- f:n
+      null;--      Put (" of ");
+      Disp_Entity_Name_List (N,NewN(N,+"-"),Get_Entity_Name_List (Attr));
+      null;--      Put (": ");
+      AddAttr(N,+"kind",Str_Entity_Kind(Get_Entity_Class (Attr))); --f:kind
+      null;--      Put (" is ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Expression (Attr));
+      null;--      Put_Line (";");
+   end Disp_Attribute_Specification;
+
+   procedure Disp_Protected_Type_Body
+     (P,N:X;Bod : Iir_Protected_Type_Body; Indent : Count)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"protected_type_body");
+      null;--      Put ("type ");
+      AddAttr(N,+"n",Str_Identifier(Bod)); -- f:n
+      null;--      Put (" is protected body");
+      null;--      New_Line;
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Bod, Indent + Indentation);
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("end protected body;");
+   end Disp_Protected_Type_Body;
+
+   procedure Disp_Declaration_Chain (P,N:X;Parent : Iir; Indent: Count)
+   is
+      pragma Unreferenced (P);
+      Decl: Iir;
+   begin
+      SetId(N,Parent);
+      SetTag(N.all,+"declaration_chain");
+      Decl := Get_Declaration_Chain (Parent);
+      while Decl /= Null_Iir loop
+         null;--         Set_Col (Indent);
+         case Get_Kind (Decl) is
+            when Iir_Kind_Type_Declaration =>
+               Disp_Type_Declaration (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Anonymous_Type_Declaration =>
+               Disp_Anonymous_Type_Declaration (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Subtype_Declaration =>
+               Disp_Subtype_Declaration (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Use_Clause =>
+               Disp_Use_Clause (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Component_Declaration =>
+               Disp_Component_Declaration (N,NewN(N,+"-"),Decl);
+            when Iir_Kinds_Object_Declaration =>
+               Disp_Object_Declaration (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Non_Object_Alias_Declaration =>
+               Disp_Non_Object_Alias_Declaration (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Implicit_Function_Declaration
+              | Iir_Kind_Implicit_Procedure_Declaration =>
+               Disp_Subprogram_Declaration (N,NewN(N,+"-"),Decl);
+               null;--               Put_Line (";");
+            when Iir_Kind_Function_Declaration
+              | Iir_Kind_Procedure_Declaration =>
+               Disp_Subprogram_Declaration (N,NewN(N,+"-"),Decl);
+               if Get_Subprogram_Body (Decl) = Null_Iir
+                 or else Get_Subprogram_Body (Decl) /= Get_Chain (Decl)
+               then
+                  null;--                  Put_Line (";");
+               end if;
+            when Iir_Kind_Function_Body
+              | Iir_Kind_Procedure_Body =>
+               Disp_Subprogram_Body (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Protected_Type_Body =>
+               Disp_Protected_Type_Body (N,NewN(N,+"-"),Decl, Indent);
+            when Iir_Kind_Configuration_Specification =>
+               Disp_Configuration_Specification (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Disconnection_Specification =>
+               Disp_Disconnection_Specification (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Attribute_Declaration =>
+               Disp_Attribute_Declaration (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Attribute_Specification =>
+               Disp_Attribute_Specification (N,NewN(N,+"-"),Decl);
+            when Iir_Kinds_Signal_Attribute =>
+               null;
+            when others =>
+               Error_Kind ("disp_declaration_chain", Decl);
+         end case;
+         Decl := Get_Chain (Decl);
+      end loop;
+   end Disp_Declaration_Chain;
+
+   procedure Disp_Waveform (P,N:X;Chain : Iir_Waveform_Element)
+   is
+      pragma Unreferenced (P);
+      We: Iir_Waveform_Element;
+      Val : Iir;
+      Ec : X;
+   begin
+      SetTag(N.all,+"waveform");
+      if Chain = Null_Iir then
+         null;--         Put ("null after {disconnection_time}");
+         return;
+      end if;
+      We := Chain;
+      while We /= Null_Iir loop -- chain:[v=Ec|n=waveelem]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"waveelem");
+         if We /= Chain then
+            null;--            Put (", ");
+         end if;
+         Val := Get_We_Value (We);
+         Disp_Expression (Ec,NewN(Ec,+"-"),Val);
+         if Get_Time (We) /= Null_Iir then
+            null;--            Put (" after ");
+            Disp_Expression (Ec,NewN(Ec,+"-"),Get_Time (We));
+         end if;
+         We := Get_Chain (We);
+      end loop;
+   end Disp_Waveform;
+
+   procedure Disp_Delay_Mechanism (P,N:X;Stmt: Iir) is
+      pragma Unreferenced (P);
+      Expr: Iir;
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"delay_mechanism");
+      case Get_Delay_Mechanism (Stmt) is
+         when Iir_Transport_Delay =>
+            null;--            Put ("transport ");
+         when Iir_Inertial_Delay =>
+            Expr := Get_Reject_Time_Expression (Stmt);
+            if Expr /= Null_Iir then
+               null;--               Put ("reject ");
+               Disp_Expression (N,NewN(N,+"-"),Expr);
+               null;--               Put (" inertial ");
+            end if;
+      end case;
+   end Disp_Delay_Mechanism;
+
+   procedure Disp_Signal_Assignment (P,N:X;Stmt: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"signal_assignment");
+      Disp_Expression (N,NewN(N,+"-"),Get_Target (Stmt));
+      null;--      Put (" <= ");
+      Disp_Delay_Mechanism (N,NewN(N,+"-"),Stmt);
+      Disp_Waveform (N,NewN(N,+"-"),Get_Waveform_Chain (Stmt));
+      null;--      Put_Line (";");
+   end Disp_Signal_Assignment;
+
+   procedure Disp_Variable_Assignment (P,N:X;Stmt: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"variable_assignment");
+      Disp_Expression (N,NewN(N,+"-"),Get_Target (Stmt));
+      null;--      Put (" := ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Expression (Stmt));
+      null;--      Put_Line (";");
+   end Disp_Variable_Assignment;
+
+   --  procedure Disp_Label (N,NewN(N,+"-"),Label: Name_Id) is
+   --  begin
+   --     if Label /= Null_Identifier then
+   --        Disp_Ident (N,NewN(N,+"-"),Label);
+   --        Put (": ");
+   --     end if;
+   --  end Disp_Label;
+
+   procedure Disp_Concurrent_Selected_Signal_Assignment (P,N:X;Stmt: Iir)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      Assoc: Iir;
+      Assoc_Chain : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"concurrent_selected_signal_assignment");
+      Indent := Col;
+      null;--      Set_Col (Indent);
+      AddAttr(N,+"lab",Str_Label( (Stmt))); -- f:lab
+      null;--      Put ("with ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Expression (Stmt));
+      null;--      Put (" select ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Target (Stmt));
+      null;--      Put (" <= ");
+      if Get_Guard (Stmt) /= Null_Iir then
+         null;--         Put ("guarded ");
+      end if;
+      Disp_Delay_Mechanism (N,NewN(N,+"-"),Stmt);
+      Assoc_Chain := Get_Selected_Waveform_Chain (Stmt);
+      Assoc := Assoc_Chain;
+      while Assoc /= Null_Iir loop
+         if Assoc /= Assoc_Chain then
+            null;--            Put_Line (",");
+         end if;
+         null;--         Set_Col (Indent + Indentation);
+         Disp_Waveform (N,NewN(N,+"-"),Get_Associated (Assoc));
+         null;--         Put (" when ");
+         Disp_Choice (N,NewN(N,+"-"),Assoc);
+      end loop;
+      null;--      Put_Line (";");
+   end Disp_Concurrent_Selected_Signal_Assignment;
+
+   procedure Disp_Concurrent_Conditional_Signal_Assignment (P,N:X;Stmt: Iir)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      Cond_Wf : Iir_Conditional_Waveform;
+      Expr : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"concurrent_conditional_signal_assignment");
+      AddAttr(N,+"lab",Str_Label( (Stmt))); -- f:lab
+      Disp_Expression (N,NewN(N,+"-"),Get_Target (Stmt));
+      null;--      Put (" <= ");
+      if Get_Guard (Stmt) /= Null_Iir then
+         null;--         Put ("guarded ");
+      end if;
+      Disp_Delay_Mechanism (N,NewN(N,+"-"),Stmt);
+      Indent := Col;
+      null;--      Set_Col (Indent);
+      Cond_Wf := Get_Conditional_Waveform_Chain (Stmt);
+      while Cond_Wf /= Null_Iir loop
+         Disp_Waveform (N,NewN(N,+"-"),Get_Waveform_Chain (Cond_Wf));
+         Expr := Get_Condition (Cond_Wf);
+         if Expr /= Null_Iir then
+            null;--            Put (" when ");
+            Disp_Expression (N,NewN(N,+"-"),Expr);
+            null;--            Put_Line (" else");
+            null;--            Set_Col (Indent);
+         end if;
+         Cond_Wf := Get_Chain (Cond_Wf);
+      end loop;
+
+      null;--      Put_Line (";");
+   end Disp_Concurrent_Conditional_Signal_Assignment;
+
+   procedure Disp_Assertion_Statement (P,N:X;Stmt: Iir) is
+      pragma Unreferenced (P);
+      Start: Count;
+      Expr: Iir;
+      pragma Unreferenced (Start);
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"assertion_statement");
+      Start := Col;
+      if Get_Kind (Stmt) = Iir_Kind_Concurrent_Assertion_Statement then
+         AddAttr(N,+"lab",Str_Label( (Stmt))); -- f:lab
+      end if;
+      null;--      Put ("assert ");
+      Disp_Expression (N,NewN(N,+"-"),Get_Assertion_Condition (Stmt));
+      Expr := Get_Report_Expression (Stmt);
+      if Expr /= Null_Iir then
+         null;--         Set_Col (Start + Indentation);
+         null;--         Put ("report ");
+         Disp_Expression (N,NewN(N,+"-"),Expr);
+      end if;
+      Expr := Get_Severity_Expression (Stmt);
+      if Expr /= Null_Iir then
+         null;--         Set_Col (Start + Indentation);
+         null;--         Put ("severity ");
+         Disp_Expression (N,NewN(N,+"-"),Expr);
+      end if;
+      null;--      Put_Line (";");
+   end Disp_Assertion_Statement;
+
+   procedure Disp_Report_Statement (P,N:X;Stmt: Iir)
+   is
+      pragma Unreferenced (P);
+      Start: Count;
+      Expr: Iir;
+      pragma Unreferenced (Start);
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"report_statement");
+      Start := Col;
+      null;--      Put ("report ");
+      Expr := Get_Report_Expression (Stmt);
+      Disp_Expression (N,NewN(N,+"-"),Expr);
+      Expr := Get_Severity_Expression (Stmt);
+      if Expr /= Null_Iir then
+         null;--         Set_Col (Start + Indentation);
+         null;--         Put ("severity ");
+         Disp_Expression (N,NewN(N,+"-"),Expr);
+      end if;
+      null;--      Put_Line (";");
+   end Disp_Report_Statement;
+
+   procedure Disp_Dyadic_Operator (P,N:X;Expr: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Expr);
+      SetTag(N.all,+"dyadic_operator");
+      null;--      Put ("(");
+      Disp_Expression (N,NewN(N,+"l"),Get_Left (Expr));  -- p:l
+      AddAttr(N,+"op"
+,+( Name_Table.Image (Iirs_Utils.Get_Operator_Name (Expr)) ));
+      Disp_Expression (N,NewN(N,+"r"),Get_Right (Expr)); -- p:r
+      null;--      Put (")");
+   end Disp_Dyadic_Operator;
+
+   procedure Disp_Monadic_Operator (P,N:X;Expr: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Expr);
+      SetTag(N.all,+"monadic_operator");
+      AddAttr(N,+"op"
+,+(Name_Table.Image (Iirs_Utils.Get_Operator_Name (Expr))));
+      null;--      Put (" (");
+      Disp_Expression (N,NewN(N,+"u"),Get_Operand (Expr)); -- p:u
+      null;--      Put (")");
+   end Disp_Monadic_Operator;
+
+   procedure Disp_Case_Statement (P,N:X;Stmt: Iir_Case_Statement)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      Assoc: Iir;
+      Sel_Stmt : Iir;
+      Ec : X;
+      pragma Unreferenced (Indent);
+   begin
+      SetTag(N.all,+"case_statement");
+      Indent := Col;
+      null;--      Put ("case ");
+      Disp_Expression (N,NewN(N,+"e"),Get_Expression (Stmt)); -- p:e
+      null;--      Put_Line (" is");
+      Assoc := Get_Case_Statement_Alternative_Chain (Stmt);
+      while Assoc /= Null_Iir loop -- chain:[v=Ec|n=Choice]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"Choice");
+         null;--         Set_Col (Indent + Indentation);
+         null;--         Put ("when ");
+         Sel_Stmt := Get_Associated (Assoc);
+         Disp_Choice (Ec,NewN(Ec,+"v"),Assoc); -- p:v
+         null;--         Put_Line (" =>");
+         null;--         Set_Col (Indent + 2 * Indentation);
+         Disp_Sequential_Statements (Ec,NewN(Ec,+"b"),Sel_Stmt); -- p:b
+      end loop;
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("end case;");
+   end Disp_Case_Statement;
+
+   procedure Disp_Wait_Statement (P,N:X;Stmt: Iir_Wait_Statement) is
+      pragma Unreferenced (P);
+      List: Iir_List;
+      Expr: Iir;
+   begin
+      SetTag(N.all,+"wait_statement");
+      null;--      Put ("wait");
+      List := Get_Sensitivity_List (Stmt);
+      if List /= Null_Iir_List then
+         null;--         Put (" on ");
+         Disp_Designator_List (N,NewN(N,+"-"),List);
+      end if;
+      Expr := Get_Condition_Clause (Stmt);
+      if Expr /= Null_Iir then
+         null;--         Put (" until ");
+         Disp_Expression (N,NewN(N,+"-"),Expr);
+      end if;
+      Expr := Get_Timeout_Clause (Stmt);
+      if Expr /= Null_Iir then
+         null;--         Put (" for ");
+         Disp_Expression (N,NewN(N,+"-"),Expr);
+      end if;
+      null;--      Put_Line (";");
+   end Disp_Wait_Statement;
+
+   procedure Disp_If_Statement (P,N:X;Stmt: Iir_If_Statement) is
+      pragma Unreferenced (P);
+      Clause: Iir;
+      Expr: Iir;
+      Start: Count;
+      Ec : X;
+      pragma Unreferenced (Start);
+   begin
+      SetTag(N.all,+"if_statement");
+      Ec := NewN(N,+"-");
+      SetTag(Ec.all,+"clause");
+      Start := Col; -- open:[v=Ec|n=clause]
+      AddAttr(Ec,+"ctyp",+("if"));
+      Clause := Stmt;
+      Disp_Expression (Ec,NewN(Ec,+"e"),Get_Condition (Clause)); -- p:e
+      null;--      Put_Line (" then");
+      while Clause /= Null_Iir loop -- none
+         null;--         Set_Col (Start + Indentation);
+         Disp_Sequential_Statements (Ec,NewN(Ec,+"b")
+,Get_Sequential_Statement_Chain (Clause)); -- p:b
+         Clause := Get_Else_Clause (Clause);
+         exit when Clause = Null_Iir;
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"clause");
+         Expr := Get_Condition (Clause); -- reopen:[v=Ec|n=clause]
+         null;--         Set_Col (Start);
+         if Expr /= Null_Iir then
+            AddAttr(Ec,+"ctyp",+("elsif"));
+            Disp_Expression (Ec,NewN(Ec,+"e"),Expr); -- p:e
+            null;--            Put_Line (" then");
+         else
+            AddAttr(Ec,+"ctyp",+("else"));
+         end if;
+      end loop;
+      null;--      Set_Col (Start); --close:clause
+      null;--      Put_Line ("end if;");
+   end Disp_If_Statement;
+
+   procedure Disp_Iterator (P,N:X;Iterator: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Iterator);
+      SetTag(N.all,+"iterator");
+      Disp_Subtype_Indication (N,NewN(N,+"-"),Iterator);
+   end Disp_Iterator;
+
+   procedure Disp_Parameter_Specification
+     (P,N:X;Iterator : Iir_Iterator_Declaration) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"parameter_specification");
+      AddAttr(N,+"n",Str_Identifier(Iterator)); -- f:n
+      null;--      Put (" in ");
+      Disp_Iterator (N,NewN(N,+"-"),Get_Type (Iterator));
+   end Disp_Parameter_Specification;
+
+   procedure Disp_Procedure_Call (P,N:X;Call : Iir)
+   is
+      pragma Unreferenced (P);
+      Obj : Iir;
+   begin
+      SetId(N,Call);
+      SetTag(N.all,+"procedure_call");
+      Obj := Get_Method_Object (Call);
+      if Obj /= Null_Iir then
+         AddAttr(N,+"obj",Str_Name(Obj)); -- f:obj
+         null;--         Put ('.');
+      end if;
+      AddAttr(N,+"n",Str_Identifier(Get_Implementation (Call))); -- f:n
+      null;--      Put (' ');
+      Disp_Association_Chain (N,NewN(N,+"-")
+,Get_Parameter_Association_Chain (Call));
+      null;--      Put_Line (";");
+   end Disp_Procedure_Call;
+
+   procedure Disp_Sequential_Statements (P,N:X;First : Iir)
+   is
+      pragma Unreferenced (P);
+      Stmt: Iir;
+      Start: Count;
+      Ec : X;
+      pragma Unreferenced (Start);
+   begin
+      SetId(N,First);
+      SetTag(N.all,+"sequential_statements");
+      Start := Col;
+      Stmt := First;
+      while Stmt /= Null_Iir loop
+         null;--         Set_Col (Start);
+         case Get_Kind (Stmt) is
+            when Iir_Kind_Null_Statement =>
+               null;--               Put_Line ("null;");
+            when Iir_Kind_If_Statement =>
+               Disp_If_Statement (N,NewN(N,+"-"),Stmt);
+            when Iir_Kind_For_Loop_Statement =>
+               Ec := NewN(N,+"-");
+               SetTag(Ec.all,+"loop");
+               AddAttr(Ec,+"typ",+("for"));
+               Disp_Parameter_Specification(Ec,NewN(Ec,+"param")
+,Get_Iterator_Scheme(Stmt));--p:param
+               null;--               Put_Line (" loop");
+               null;--               Set_Col (Start + Indentation);
+               Disp_Sequential_Statements(Ec,NewN(Ec,+"-")
+,Get_Sequential_Statement_Chain (Stmt));
+               null;--               Set_Col (Start);
+               null;--               Put_Line ("end loop;"); --close:loop
+            when Iir_Kind_While_Loop_Statement =>
+               Ec := NewN(N,+"-");
+               SetTag(Ec.all,+"while");
+               AddAttr(Ec,+"typ",+("while"));
+               if Get_Condition (Stmt) /= Null_Iir then
+                  null;--                  Put ("while ");
+                  Disp_Expression (Ec,NewN(Ec,+"param")
+,Get_Condition (Stmt)); -- p:param
+                  null;--                  Put (" ");
+               end if;
+               null;--               Put_Line ("loop");
+               null;--               Set_Col (Start + Indentation);
+               Disp_Sequential_Statements(Ec,NewN(Ec,+"-")
+,Get_Sequential_Statement_Chain (Stmt));
+               null;--               Set_Col (Start);
+               null;--               Put_Line ("end loop;"); --close:while
+            when Iir_Kind_Signal_Assignment_Statement =>
+               Disp_Signal_Assignment (N,NewN(N,+"-"),Stmt);
+            when Iir_Kind_Variable_Assignment_Statement =>
+               Disp_Variable_Assignment (N,NewN(N,+"-"),Stmt);
+            when Iir_Kind_Assertion_Statement =>
+               Disp_Assertion_Statement (N,NewN(N,+"-"),Stmt);
+            when Iir_Kind_Report_Statement =>
+               Disp_Report_Statement (N,NewN(N,+"-"),Stmt);
+            when Iir_Kind_Return_Statement =>
+               if Get_Expression (Stmt) /= Null_Iir then-- open:[v=Ec|n=return]
+
+                  null;--                  Put ("return ");
+                  Disp_Expression (N,NewN(N,+"-"),Get_Expression (Stmt));
+                  null;--                  Put_Line (";");
+               else
+                  null;--                  Put_Line ("return;");
+               end if; --close:loop
+            when Iir_Kind_Case_Statement =>
+               Disp_Case_Statement (N,NewN(N,+"-"),Stmt);
+            when Iir_Kind_Wait_Statement =>
+               Disp_Wait_Statement (N,NewN(N,+"-"),Stmt);
+            when Iir_Kind_Procedure_Call_Statement =>
+               Disp_Procedure_Call (N,NewN(N,+"-"),Get_Procedure_Call (Stmt))
+;
+            when Iir_Kind_Exit_Statement
+              | Iir_Kind_Next_Statement =>
+               if Get_Kind (Stmt) = Iir_Kind_Exit_Statement then
+                  Ec := NewN(N,+"-");
+                  SetTag(Ec.all,+"break");
+                  AddAttr(Ec,+"typ",+("exit"));
+               else
+                  Ec := NewN(Ec,+"-");
+                  SetTag(Ec.all,+"break");
+                  AddAttr(Ec,+"typ",+("next"));
+               end if;
+               -- FIXME: label.
+               if Get_Condition (Stmt) /= Null_Iir then
+                  null;--                  Put (" when ");
+                  Disp_Expression (Ec,NewN(Ec,+"-"),Get_Condition (Stmt));
+               end if;
+               null;--               Put_Line (";"); --close:loop
+
+            when others =>
+               Error_Kind ("disp_sequential_statements", Stmt);
+         end case;
+         Stmt := Get_Chain (Stmt);
+      end loop;
+   end Disp_Sequential_Statements;
+
+   procedure Disp_Process_Statement (P,N:X;Process: Iir)
+   is
+      pragma Unreferenced (P);
+      Start: Count;
+   begin
+      SetId(N,Process);
+      SetTag(N.all,+"process_statement");
+      Start := Col;
+      AddAttr(N,+"lab",Str_Label( (Process))); -- f:lab
+
+      null;--      Put ("process ");
+      if Get_Kind (Process) = Iir_Kind_Sensitized_Process_Statement then
+         null;--         Put ("(");
+         Disp_Designator_List (N,NewN(N,+"-"),Get_Sensitivity_List (Process))
+;
+         null;--         Put (")");
+      end if;
+      if Vhdl_Std >= Vhdl_93 then
+         null;--         Put_Line (" is");
+      else
+         null;--         New_Line;
+      end if;
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Process, Start + Indentation);
+      null;--      Set_Col (Start);
+      null;--      Put_Line ("begin");
+      null;--      Set_Col (Start + Indentation);
+      Disp_Sequential_Statements (N,NewN(N,+"-")
+,Get_Sequential_Statement_Chain (Process));
+      null;--      Set_Col (Start);
+      null;--      Put_Line ("end process;");
+   end Disp_Process_Statement;
+
+   procedure Disp_Association_Chain (P,N:X;Chain : Iir)
+   is
+      pragma Unreferenced (P);
+      El: Iir;
+      Formal: Iir;
+      Need_Comma : Boolean;
+      Conv : Iir;
+      Ec : X;
+   begin
+      SetId(N,Chain);
+      SetTag(N.all,+"association_chain");
+      if Chain = Null_Iir then
+         return;
+      end if;
+      null;--      Put ("(");
+      Need_Comma := False;
+
+      El := Chain;
+      while El /= Null_Iir loop -- chain:[v=Ec|n=Association]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"Association");
+         if Get_Kind (El) /= Iir_Kind_Association_Element_By_Individual then
+            if Need_Comma then
+               null;--               Put (", ");
+            end if;
+            if Get_Kind (El) = Iir_Kind_Association_Element_By_Expression then
+
+               Conv := Get_Out_Conversion (El);
+               if Conv /= Null_Iir then
+                  AddAttr(Ec,+"from",Str_Function_Name(Conv)); -- f:from
+                  null;--                  Put (" (");
+               end if;
+            else
+               Conv := Null_Iir;
+            end if;
+            Formal := Get_Formal (El);
+            if Formal /= Null_Iir then
+               Disp_Expression (Ec,NewN(Ec,+"-"),Formal);
+               if Conv /= Null_Iir then
+                  null;--                  Put (")");
+               end if;
+               null;--               Put (" => ");
+            end if;
+            if Get_Kind (El) = Iir_Kind_Association_Element_Open then
+               null;--               Put ("open");
+            else
+               Conv := Get_In_Conversion (El);
+               if Conv /= Null_Iir then
+                  AddAttr(Ec,+"to",Str_Function_Name(Conv)); -- f:to
+                  null;--                  Put (" (");
+               end if;
+               Disp_Expression (Ec,NewN(Ec,+"-"),Get_Actual (El));
+               if Conv /= Null_Iir then
+                  null;--                  Put (")");
+               end if;
+            end if;
+            Need_Comma := True;
+         end if;
+         El := Get_Chain (El);
+      end loop;
+      null;--      Put (")");
+   end Disp_Association_Chain;
+
+   procedure Disp_Generic_Map_Aspect (P,N:X;Parent : Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Parent);
+      SetTag(N.all,+"generic_map_aspect");
+      null;--      Put ("generic map ");
+      Disp_Association_Chain (N,NewN(N,+"-")
+,Get_Generic_Map_Aspect_Chain (Parent));
+   end Disp_Generic_Map_Aspect;
+
+   procedure Disp_Port_Map_Aspect (P,N:X;Parent : Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Parent);
+      SetTag(N.all,+"port_map_aspect");
+      null;--      Put ("port map ");
+      Disp_Association_Chain (N,NewN(N,+"-")
+,Get_Port_Map_Aspect_Chain (Parent));
+   end Disp_Port_Map_Aspect;
+
+   procedure Disp_Entity_Aspect (P,N:X;Aspect : Iir) is
+      pragma Unreferenced (P);
+      Arch : Iir;
+   begin
+      SetId(N,Aspect);
+      SetTag(N.all,+"entity_aspect");
+      ChangeTag(N,Aspect);
+      AddAttr(N,+"typ",+"aspect");
+      case Get_Kind (Aspect) is -- rename:Aspect,flags:[typ=aspect]
+         when Iir_Kind_Entity_Aspect_Entity =>
+            null;--            Put ("entity ");
+            AddAttr(N,+"n",Str_Name_Of(Get_Entity (Aspect))); -- f:n
+            Arch := Get_Architecture (Aspect);
+            if Arch /= Null_Iir then
+               null;--               Put (" (");
+               AddAttr(N,+"arch",Str_Name_Of(Arch)); -- f:arch
+               null;--               Put (")");
+            end if;
+         when Iir_Kind_Entity_Aspect_Configuration =>
+            null;--            Put ("configuration ");
+            AddAttr(N,+"n",Str_Name_Of(Get_Configuration (Aspect))); -- f:n
+         when Iir_Kind_Entity_Aspect_Open =>
+            null;--            Put ("open");
+         when others =>
+            Error_Kind ("disp_entity_aspect", Aspect);
+      end case;
+   end Disp_Entity_Aspect;
+
+   procedure Disp_Component_Instantiation_Statement
+     (P,N:X;Stmt: Iir_Component_Instantiation_Statement)
+   is
+      pragma Unreferenced (P);
+      Component: Iir;
+      Alist: Iir;
+   begin
+      SetTag(N.all,+"component_instantiation_statement");
+      AddAttr(N,+"lab",Str_Label( (Stmt))); -- f:lab
+      Component := Get_Instantiated_Unit (Stmt);
+      if Get_Kind (Component) = Iir_Kind_Component_Declaration then
+         AddAttr(N,+"n",Str_Name_Of(Component)); -- f:n
+      else
+         Disp_Entity_Aspect (N,NewN(N,+"-"),Component);
+      end if;
+      Alist := Get_Generic_Map_Aspect_Chain (Stmt);
+      if Alist /= Null_Iir then
+         null;--         Put (" ");
+         Disp_Generic_Map_Aspect (N,NewN(N,+"-"),Stmt);
+      end if;
+      Alist := Get_Port_Map_Aspect_Chain (Stmt);
+      if Alist /= Null_Iir then
+         null;--         Put (" ");
+         Disp_Port_Map_Aspect (N,NewN(N,+"-"),Stmt);
+      end if;
+      null;--      Put (";");
+   end Disp_Component_Instantiation_Statement;
+
+   procedure Disp_Function_Call (P,N:X;Expr: Iir_Function_Call) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"function_call");
+      AddAttr(N,+"n",Str_Function_Name(Get_Implementation (Expr))); -- f:n
+      Disp_Association_Chain (N,NewN(N,+"-")
+,Get_Parameter_Association_Chain (Expr));
+   end Disp_Function_Call;
+
+   procedure Disp_Indexed_Name (P,N:X;Indexed: Iir)
+   is
+      pragma Unreferenced (P);
+      List : Iir_List;
+      El: Iir;
+      Ec : X;
+   begin
+      SetId(N,Indexed);
+      SetTag(N.all,+"indexed_name");
+      Disp_Expression (N,NewN(N,+"-"),Get_Prefix (Indexed));
+      null;--      Put (" (");
+      List := Get_Index_List (Indexed);
+      for I in Natural loop -- chain:[v=Ec|n=Name]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"Name");
+         El := Get_Nth_Element (List, I);
+         if El = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when El = Null_Iir; --exitchain:Ec
+         if I /= 0 then
+            null;--            Put (", ");
+         end if;
+         Disp_Expression (Ec,NewN(Ec,+"-"),El);
+      end loop;
+      null;--      Put (")");
+   end Disp_Indexed_Name;
+
+   procedure Disp_Choice (P,N:X;Choice: in out Iir) is
+      pragma Unreferenced (P);
+      Ec : X;
+   begin
+      SetTag(N.all,+"choice");
+      loop -- chain:[v=Ec|n=Choice]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"Choice");
+         case Get_Kind (Choice) is
+            when Iir_Kind_Choice_By_Others =>
+               AddAttr(Ec,+"val",+("others"));
+            when Iir_Kind_Choice_By_None =>
+               null;
+            when Iir_Kind_Choice_By_Expression =>
+               Disp_Expression (Ec,NewN(Ec,+"-"),Get_Expression (Choice));
+            when Iir_Kind_Choice_By_Range =>
+               Disp_Range (Ec,NewN(Ec,+"-"),Get_Expression (Choice));
+            when Iir_Kind_Choice_By_Name =>
+               AddAttr(Ec,+"val",Str_Name_Of(Get_Name (Choice))); -- f:val
+            when others =>
+               Error_Kind ("disp_choice", Choice);
+         end case;
+         Choice := Get_Chain (Choice);
+         exit when Choice = Null_Iir;
+         exit when Get_Same_Alternative_Flag (Choice) = False;
+         --exit when Choice = Null_Iir;
+         null;--         Put (" | ");
+      end loop;
+   end Disp_Choice;
+
+   procedure Disp_Aggregate (P,N:X;Aggr: Iir_Aggregate)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      Assoc: Iir;
+      Expr : Iir;
+      Ec : X;
+      pragma Unreferenced (Indent);
+   begin
+      SetTag(N.all,+"aggregate");
+      null;--      Put ("(");
+      Indent := Col;
+      Assoc := Get_Association_Choices_Chain (Aggr);
+      loop -- chain:[v=Ec|n=AggE]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"AggE");
+         Expr := Get_Associated (Assoc);
+         if Get_Kind (Assoc) /= Iir_Kind_Choice_By_None then
+            Disp_Choice (Ec,NewN(Ec,+"-"),Assoc);
+            null;--            Put (" => ");
+         else
+            Assoc := Get_Chain (Assoc);
+         end if;
+         if Get_Kind (Expr) = Iir_Kind_Aggregate
+           or else Get_Kind (Expr) = Iir_Kind_String_Literal then
+            null;--            Set_Col (Indent);
+         end if;
+         Disp_Expression (Ec,NewN(Ec,+"-"),Expr);
+         exit when Assoc = Null_Iir;
+         null;--         Put (", ");
+      end loop;
+      null;--      Put (")");
+   end Disp_Aggregate;
+
+   procedure Disp_Simple_Aggregate (P,N:X;Aggr: Iir_Simple_Aggregate)
+   is
+      pragma Unreferenced (P);
+      List : Iir_List;
+      El : Iir;
+      First : Boolean := True;
+      Ec : X;
+   begin
+      SetTag(N.all,+"simple_aggregate");
+      null;--      Put ("(");
+      List := Get_Simple_Aggregate_List (Aggr);
+      for I in Natural loop -- chain:[v=Ec|n=AggE]
+         Ec := NewN(N,+"-");
+         SetTag(Ec.all,+"AggE");
+         El := Get_Nth_Element (List, I);
+         if El = Null_Iir then
+            RemFrom(N,Ec);
+         end if;
+         exit when El = Null_Iir; --exitchain:Ec
+         if First then
+            First := False;
+         else
+            null;--            Put (", ");
+         end if;
+         Disp_Expression (Ec,NewN(Ec,+"-"),El);
+      end loop;
+      null;--      Put (")");
+   end Disp_Simple_Aggregate;
+
+   procedure Disp_Parametered_Attribute (P,N:X;Name : String; Expr : Iir)
+   is
+      pragma Unreferenced (P);
+      Param : Iir;
+      Pfx : Iir;
+   begin
+      SetTag(N.all,+"parametered_attribute");
+      Pfx := Get_Prefix (Expr);
+      case Get_Kind (Pfx) is
+         when Iir_Kind_Type_Declaration
+           | Iir_Kind_Subtype_Declaration =>
+            AddAttr(N,+"n",Str_Name_Of(Pfx)); -- f:n
+         when others =>
+            Disp_Expression (N,NewN(N,+"-"),Pfx);
+      end case;
+      null;--      Put ("'");
+      AddAttr(N,+"attribute",+(Name));
+      Param := Get_Parameter (Expr);
+      if Param /= Null_Iir then
+         null;--         Put (" (");
+         Disp_Expression (N,NewN(N,+"-"),Param);
+         null;--         Put (")");
+      end if;
+   end Disp_Parametered_Attribute;
+
+   procedure Disp_String_Literal (P,N:X;Str : Iir)
+   is
+      pragma Unreferenced (P);
+      Ptr : String_Fat_Acc;
+      Len : Int32;
+   begin
+      SetId(N,Str);
+      SetTag(N.all,+"string_literal");
+      Ptr := Get_String_Fat_Acc (Str);
+      Len := Get_String_Length (Str);
+      Put (String (Ptr (1 .. Len)));
+   end Disp_String_Literal;
+   pragma Unreferenced (Disp_String_Literal);
+
+   procedure Disp_Expression (P,N:X;Expr: Iir)
+   is
+      Orig : Iir;
+   begin
+      SetId(N,Expr);
+      SetTag(N.all,+"expression");
+      ChangeTag(N,Expr);
+      AddAttr(N,+"typ",+"expr");
+      case Get_Kind (Expr) is -- rename:Expr,flags:[typ=expr]
+         when Iir_Kind_Integer_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (P,N,Orig); --reent:1
+            else
+               AddAttr(N,+"val",Str_Int64(Get_Value (Expr))); -- f:val
+            end if;
+         when Iir_Kind_Floating_Point_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (P,N,Orig); --reent:1
+            else
+               AddAttr(N,+"val",Str_Fp64(Get_Fp_Value (Expr))); -- f:val
+            end if;
+         when Iir_Kind_String_Literal =>
+            null;--            Put (""""); -- nop:1
+            AddAttr(N,+"val",Str_String_Literal(Expr)); -- f:val
+            null;--            Put (""""); -- nop:1
+            if Disp_String_Literal_Type or Flags.List_Verbose then
+               null;--               Put ("[type: ");
+               Disp_Type (N,NewN(N,+"-"),Get_Type (Expr));
+               null;--               Put ("]");
+            end if;
+         when Iir_Kind_Bit_String_Literal =>
+            if False then
+               case Get_Bit_String_Base (Expr) is
+                  when Base_2 =>
+                     null;--                     Put ('B');
+                  when Base_8 =>
+                     null;--                     Put ('O');
+                  when Base_16 =>
+                     null;--                     Put ('X');
+               end case;
+            end if;
+            null;--            Put ("B"""); -- nop:1
+            AddAttr(N,+"val",Str_String_Literal(Expr)); -- f:val
+            null;--            Put (""""); -- nop:1
+         when Iir_Kind_Physical_Fp_Literal
+           | Iir_Kind_Physical_Int_Literal =>
+            Orig := Get_Literal_Origin (Expr);
+            if Orig /= Null_Iir then
+               Disp_Expression (N,NewN(N,+"-"),Orig);
+            else
+               Disp_Physical_Literal (N,NewN(N,+"-"),Expr); -- f:val
+            end if;
+         when Iir_Kind_Unit_Declaration =>
+            AddAttr(N,+"val",Str_Name_Of(Expr)); -- f:val
+         when Iir_Kind_Enumeration_Literal =>
+            AddAttr(N,+"val",Str_Name_Of(Expr)); -- f:val
+         when Iir_Kind_Object_Alias_Declaration =>
+            AddAttr(N,+"val",Str_Name_Of(Expr)); -- f:val
+         when Iir_Kind_Aggregate =>
+            Disp_Aggregate (P,N,Expr); --reent:1
+         when Iir_Kind_Null_Literal =>
+            null;--            Put ("null");
+         when Iir_Kind_Simple_Aggregate =>
+            Disp_Simple_Aggregate (P,N,Expr); --reent:1
+
+         when Iir_Kind_Element_Declaration =>
+            AddAttr(N,+"val",Str_Name_Of(Expr)); -- f:val
+
+         when Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Guard_Signal_Declaration
+           | Iir_Kind_Variable_Declaration
+           | Iir_Kind_Variable_Interface_Declaration
+           | Iir_Kind_Constant_Declaration
+           | Iir_Kind_Constant_Interface_Declaration
+           | Iir_Kind_File_Declaration
+           | Iir_Kind_File_Interface_Declaration
+           | Iir_Kind_Iterator_Declaration =>
+            AddAttr(N,+"val",Str_Name_Of(Expr)); -- f:val
+            return;
+
+         when Iir_Kind_Simple_Name =>
+            AddAttr(N,+"val",Str_Name(Expr)); -- f:val
+
+         when Iir_Kinds_Dyadic_Operator =>
+            Disp_Dyadic_Operator (P,N,Expr); --reent:1
+         when Iir_Kinds_Monadic_Operator =>
+            Disp_Monadic_Operator (P,N,Expr); --reent:1
+         when Iir_Kind_Function_Call =>
+            Disp_Function_Call (P,N,Expr); --reent:1
+         when Iir_Kind_Type_Conversion =>
+            Disp_Type (N,NewN(N,+"-"),Get_Type (Expr));
+            null;--            Put (" (");
+            Disp_Expression (N,NewN(N,+"-"),Get_Expression (Expr));
+            null;--            Put (")");
+         when Iir_Kind_Qualified_Expression =>
+            Disp_Type (N,NewN(N,+"-"),Get_Type_Mark (Expr));
+            null;--            Put ("'(");
+            Disp_Expression (N,NewN(N,+"-"),Get_Expression (Expr));
+            null;--            Put (")");
+         when Iir_Kind_Allocator_By_Expression =>
+            null;--            Put ("new ");
+            Disp_Expression (N,NewN(N,+"-"),Get_Expression (Expr));
+         when Iir_Kind_Allocator_By_Subtype =>
+            null;--            Put ("new ");
+            Disp_Subtype_Indication (N,NewN(N,+"-"),Get_Expression (Expr));
+
+         when Iir_Kind_Indexed_Name =>
+            Disp_Indexed_Name (P,N,Expr); --reent:1
+         when Iir_Kind_Slice_Name =>
+            Disp_Expression (N,NewN(N,+"-"),Get_Prefix (Expr));
+            null;--            Put (" (");
+            Disp_Range (N,NewN(N,+"-"),Get_Suffix (Expr));
+            null;--            Put (")");
+         when Iir_Kind_Selected_Element =>
+            Disp_Expression (N,NewN(N,+"-"),Get_Prefix (Expr));
+            null;--            Put (".");
+            AddAttr(N,+"elem",Str_Name_Of(Get_Selected_Element (Expr)))
+; -- f:elem
+         when Iir_Kind_Implicit_Dereference =>
+            Disp_Expression (N,NewN(N,+"-"),Get_Prefix (Expr));
+         when Iir_Kind_Dereference =>
+            Disp_Expression (N,NewN(N,+"-"),Get_Prefix (Expr));
+            null;--            Put (".all");
+
+         when Iir_Kind_Left_Type_Attribute =>
+            AddAttr(N,+"attribute",+("'left"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Right_Type_Attribute =>
+            AddAttr(N,+"attribute",+("'right"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_High_Type_Attribute =>
+            AddAttr(N,+"attribute",+("'high"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Low_Type_Attribute =>
+            AddAttr(N,+"attribute",+("'low"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+
+         when Iir_Kind_Stable_Attribute =>
+            Disp_Parametered_Attribute (P,N,"stable", Expr); --reent:1
+         when Iir_Kind_Delayed_Attribute =>
+            Disp_Parametered_Attribute (P,N,"delayed", Expr); --reent:1
+         when Iir_Kind_Transaction_Attribute =>
+            AddAttr(N,+"attribute",+("'transaction"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Event_Attribute =>
+            AddAttr(N,+"attribute",+("'event"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Active_Attribute =>
+            AddAttr(N,+"attribute",+("'active"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Last_Value_Attribute =>
+            AddAttr(N,+"attribute",+("'last_value"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+         when Iir_Kind_Last_Event_Attribute =>
+            AddAttr(N,+"attribute",+("'last_event"));
+            Disp_Expression (P,N,Get_Prefix (Expr)); --reent:1
+
+         when Iir_Kind_Pos_Attribute =>
+            Disp_Parametered_Attribute (P,N,"pos", Expr); --reent:1
+         when Iir_Kind_Val_Attribute =>
+            Disp_Parametered_Attribute (P,N,"val", Expr); --reent:1
+         when Iir_Kind_Succ_Attribute =>
+            Disp_Parametered_Attribute (P,N,"succ", Expr); --reent:1
+         when Iir_Kind_Pred_Attribute =>
+            Disp_Parametered_Attribute (P,N,"pred", Expr); --reent:1
+
+         when Iir_Kind_Length_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"length", Expr); --reent:1
+         when Iir_Kind_Range_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"range", Expr); --reent:1
+         when Iir_Kind_Reverse_Range_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"reverse_range", Expr)
+; --reent:1
+         when Iir_Kind_Left_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"left", Expr); --reent:1
+         when Iir_Kind_Right_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"right", Expr); --reent:1
+         when Iir_Kind_Low_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"low", Expr); --reent:1
+         when Iir_Kind_High_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"high", Expr); --reent:1
+         when Iir_Kind_Ascending_Array_Attribute =>
+            Disp_Parametered_Attribute (P,N,"ascending", Expr); --reent:1
+
+         when Iir_Kind_Image_Attribute =>
+            Disp_Parametered_Attribute (P,N,"image", Expr); --reent:1
+         when Iir_Kind_Simple_Name_Attribute =>
+            AddAttr(N,+"n",Str_Name_Of(Get_Prefix (Expr))); -- f:n
+            AddAttr(N,+"attribute",+("'simple_name"));
+         when Iir_Kind_Instance_Name_Attribute =>
+            AddAttr(N,+"n",Str_Name_Of(Get_Prefix (Expr))); -- f:n
+            AddAttr(N,+"attribute",+("'instance_name"));
+         when Iir_Kind_Path_Name_Attribute =>
+            AddAttr(N,+"n",Str_Name_Of(Get_Prefix (Expr))); -- f:n
+            AddAttr(N,+"attribute",+("'path_name"));
+
+         when Iir_Kind_Selected_By_All_Name =>
+            Disp_Expression (N,NewN(N,+"-"),Get_Prefix (Expr));
+            null;--            Put ("");
+            return;
+         when Iir_Kind_Selected_Name =>
+            Disp_Expression (P,N,Get_Named_Entity (Expr)); --reent:1
+
+         when Iir_Kinds_Type_And_Subtype_Definition =>
+            Disp_Type (P,N,Expr); --reent:1
+
+         when Iir_Kind_Proxy =>
+            Disp_Expression (N,NewN(N,+"-"),Get_Proxy (Expr));
+
+         when Iir_Kind_Range_Expression =>
+            Disp_Range (P,N,Expr); --reent:1
+         when Iir_Kind_Subtype_Declaration =>
+            AddAttr(N,+"n",Str_Name_Of(Expr)); -- f:n
+
+         when others =>
+            Error_Kind ("disp_expression", Expr);
+      end case;
+   end Disp_Expression;
+
+   --  procedure Disp_PSL_HDL_Expr
+   -- (NPSL : PSL.Nodes.HDL_Node) is
+   --  begin
+   --     Disp_Expression (N,NewN(N,+"-"),Iir (NPSL));
+   --  end Disp_PSL_HDL_Expr;
+
+   procedure Disp_Psl_Expression (P,N:X;Expr : PSL_Node) is
+      pragma Unreferenced (P);
+      pragma Unreferenced (Expr);
+   begin
+      SetTag(N.all,+"psl_expression");
+      null;--      Put_Line("Error Psl not supported\n");
+      --PSL.Prints.HDL_Expr_Printer := Disp_PSL_HDL_Expr'Access;
+      --PSL.Prints.Print_Property (Expr);
+   end Disp_Psl_Expression;
+
+   procedure Disp_Block_Header (P,N:X;Header : Iir_Block_Header
+; Indent: Count)
+   is
+      pragma Unreferenced (P);
+      Chain : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      SetTag(N.all,+"block_header");
+      if Header = Null_Iir then
+         return;
+      end if;
+      Chain := Get_Generic_Chain (Header);
+      if Chain /= Null_Iir then
+         null;--         Set_Col (Indent + Indentation);
+         Disp_Generics (N,NewN(N,+"-"),Header);
+         Chain := Get_Generic_Map_Aspect_Chain (Header);
+         if Chain /= Null_Iir then
+            null;--            Set_Col (Indent + Indentation);
+            Disp_Generic_Map_Aspect (N,NewN(N,+"-"),Header);
+            null;--            Put_Line (";");
+         end if;
+      end if;
+      Chain := Get_Port_Chain (Header);
+      if Chain /= Null_Iir then
+         null;--         Set_Col (Indent + Indentation);
+         Disp_Ports (N,NewN(N,+"-"),Header);
+         Chain := Get_Port_Map_Aspect_Chain (Header);
+         if Chain /= Null_Iir then
+            null;--            Set_Col (Indent + Indentation);
+            Disp_Port_Map_Aspect (N,NewN(N,+"-"),Header);
+            null;--            Put_Line (";");
+         end if;
+      end if;
+   end Disp_Block_Header;
+
+   procedure Disp_Block_Statement (P,N:X;Block: Iir_Block_Statement)
+   is
+      pragma Unreferenced (P);
+      Indent: Count;
+      Sensitivity: Iir_List;
+      Guard : Iir_Guard_Signal_Declaration;
+   begin
+      SetTag(N.all,+"block_statement");
+      Indent := Col;
+      AddAttr(N,+"lab",Str_Label( (Block))); -- f:lab
+      null;--      Put ("block");
+      Guard := Get_Guard_Decl (Block);
+      if Guard /= Null_Iir then
+         null;--         Put (" (");
+         Disp_Expression (N,NewN(N,+"-"),Get_Guard_Expression (Guard));
+         null;--         Put_Line (")");
+         Sensitivity := Get_Guard_Sensitivity_List (Guard);
+         if Sensitivity /= Null_Iir_List then
+            null;--            Set_Col (Indent + Indentation);
+            null;--            Put ("-- guard sensitivity list ");
+            Disp_Designator_List (N,NewN(N,+"-"),Sensitivity);
+         end if;
+      else
+         null;--         New_Line;
+      end if;
+      Disp_Block_Header (N,NewN(N,+"-"),Get_Block_Header (Block),
+                         Indent + Indentation);
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Block, Indent + Indentation);
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (N,NewN(N,+"-"),Block
+, Indent + Indentation);
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("end;");
+   end Disp_Block_Statement;
+
+   procedure Disp_Generate_Statement (P,N:X;Stmt : Iir_Generate_Statement)
+   is
+      pragma Unreferenced (P);
+      Indent : Count;
+      Scheme : Iir;
+   begin
+      SetTag(N.all,+"generate_statement");
+      Indent := Col;
+      AddAttr(N,+"lab",Str_Label( (Stmt))); -- f:lab
+      Scheme := Get_Generation_Scheme (Stmt);
+      case Get_Kind (Scheme) is
+         when Iir_Kind_Iterator_Declaration =>
+            null;--            Put ("for ");
+            Disp_Parameter_Specification (N,NewN(N,+"-"),Scheme);
+         when others =>
+            null;--            Put ("if ");
+            Disp_Expression (N,NewN(N,+"-"),Scheme);
+      end case;
+      null;--      Put_Line (" generate");
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Stmt, Indent);
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("begin");
+      Disp_Concurrent_Statement_Chain (N,NewN(N,+"-"),Stmt
+, Indent + Indentation);
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("end generate;");
+   end Disp_Generate_Statement;
+
+   procedure Disp_Psl_Default_Clock (P,N:X;Stmt : Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"psl_default_clock");
+      null;--      Put ("--psl default clock is ");
+      Disp_Psl_Expression (N,NewN(N,+"-"),Get_Psl_Boolean (Stmt));
+      null;--      Put_Line (";");
+   end Disp_Psl_Default_Clock;
+
+   procedure Disp_Psl_Assert_Statement (P,N:X;Stmt : Iir)
+   is
+      pragma Unreferenced (P);
+      use PSL.NFAs;
+      use PSL.Nodes;
+
+      procedure Disp_State (P,N:X;S : NFA_State) is
+         pragma Unreferenced (P);
+         Str : constant String := Int32'Image (Get_State_Label (S));
+      begin
+         SetTag(N.all,+"state");
+         Put (Str (2 .. Str'Last));
+      end Disp_State;
+
+      NPSL : NFA;
+      S : NFA_State;
+      E : NFA_Edge;
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"psl_assert_statement");
+      null;--      Put ("--psl assert ");
+      Disp_Psl_Expression (N,NewN(N,+"-"),Get_Psl_Property (Stmt));
+      null;--      Put_Line (";");
+      NPSL := Get_PSL_NFA (Stmt);
+      if True and then NPSL /= No_NFA then
+         S := Get_First_State (NPSL);
+         while S /= No_State loop
+            E := Get_First_Src_Edge (S);
+            while E /= No_Edge loop
+               null;--               Put ("-- ");
+               Disp_State (N,NewN(N,+"-"),S);
+               null;--               Put (" -> ");
+               Disp_State (N,NewN(N,+"-"),Get_Edge_Dest (E));
+               null;--               Put (": ");
+               Disp_Psl_Expression (N,NewN(N,+"-"),Get_Edge_Expr (E));
+               null;--               New_Line;
+               E := Get_Next_Src_Edge (E);
+            end loop;
+            S := Get_Next_State (S);
+         end loop;
+      end if;
+   end Disp_Psl_Assert_Statement;
+
+   procedure Disp_Concurrent_Statement (P,N:X;Stmt: Iir) is
+   begin
+      SetId(N,Stmt);
+      SetTag(N.all,+"concurrent_statement");
+      ChangeTag(N,Stmt);
+      AddAttr(N,+"typ",+"concur");
+      case Get_Kind (Stmt) is -- rename:Stmt,flags:[typ=concur]
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            Disp_Concurrent_Conditional_Signal_Assignment (P,N,Stmt)
+;-- reent:1
+         when Iir_Kind_Concurrent_Selected_Signal_Assignment =>
+            Disp_Concurrent_Selected_Signal_Assignment (P,N,Stmt);-- reent:1
+         when Iir_Kind_Sensitized_Process_Statement
+           | Iir_Kind_Process_Statement =>
+            Disp_Process_Statement (N,NewN(N,+"-"),Stmt);
+         when Iir_Kind_Concurrent_Assertion_Statement =>
+            Disp_Assertion_Statement (N,NewN(N,+"-"),Stmt);
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Component_Instantiation_Statement (N,NewN(N,+"-"),Stmt);
+         when Iir_Kind_Concurrent_Procedure_Call_Statement =>
+            Disp_Procedure_Call (N,NewN(N,+"-"),Get_Procedure_Call (Stmt));
+         when Iir_Kind_Block_Statement =>
+            Disp_Block_Statement (N,NewN(N,+"-"),Stmt);
+         when Iir_Kind_Generate_Statement =>
+            Disp_Generate_Statement (N,NewN(N,+"-"),Stmt);
+         when Iir_Kind_Psl_Default_Clock =>
+            Disp_Psl_Default_Clock (N,NewN(N,+"-"),Stmt);
+         when Iir_Kind_Psl_Assert_Statement =>
+            Disp_Psl_Assert_Statement (N,NewN(N,+"-"),Stmt);
+         when others =>
+            Error_Kind ("disp_concurrent_statement", Stmt);
+      end case;
+   end Disp_Concurrent_Statement;
+
+   procedure Disp_Package_Declaration (P,N:X
+;Decl: Iir_Package_Declaration) is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"package_declaration");
+      null;--      Put ("package ");
+      AddAttr(N,+"n",Str_Identifier(Decl)); -- f:n
+      null;--      Put_Line (" is");
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Decl, Col + Indentation);
+      null;--      Put_Line ("end;");
+   end Disp_Package_Declaration;
+
+   procedure Disp_Package_Body (P,N:X;Decl: Iir)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,Decl);
+      SetTag(N.all,+"package_body");
+      null;--      Put ("package body ");
+      AddAttr(N,+"n",Str_Identifier(Decl)); -- f:n
+      null;--      Put_Line (" is");
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Decl, Col + Indentation);
+      null;--      Put_Line ("end;");
+   end Disp_Package_Body;
+
+   procedure Disp_Binding_Indication (P,N:X;Bind : Iir; Indent : Count)
+   is
+      pragma Unreferenced (P);
+      El : Iir;
+      pragma Unreferenced (Indent);
+   begin
+      SetId(N,Bind);
+      SetTag(N.all,+"binding_indication");
+      El := Get_Entity_Aspect (Bind);
+      if El /= Null_Iir then
+         null;--         Set_Col (Indent);
+         null;--         Put ("use ");
+         Disp_Entity_Aspect (N,NewN(N,+"-"),El);
+      end if;
+      El := Get_Generic_Map_Aspect_Chain (Bind);
+      if El /= Null_Iir then
+         null;--         Set_Col (Indent);
+         Disp_Generic_Map_Aspect (N,NewN(N,+"-"),Bind);
+      end if;
+      El := Get_Port_Map_Aspect_Chain (Bind);
+      if El /= Null_Iir then
+         null;--         Set_Col (Indent);
+         Disp_Port_Map_Aspect (N,NewN(N,+"-"),Bind);
+      end if;
+   end Disp_Binding_Indication;
+
+   procedure Disp_Component_Configuration
+     (P,N:X;Conf : Iir_Component_Configuration; Indent : Count)
+   is
+      pragma Unreferenced (P);
+      Block : Iir_Block_Configuration;
+      Binding : Iir;
+   begin
+      SetTag(N.all,+"component_configuration");
+      null;--      Set_Col (Indent);
+      null;--      Put ("for ");
+      Disp_Instantiation_List (N,NewN(N,+"-"),Get_Instantiation_List (Conf))
+;
+      null;--      Put(" : ");
+      AddAttr(N,+"n",Str_Name_Of(Get_Component_Name (Conf))); -- f:n
+      null;--      New_Line;
+      Binding := Get_Binding_Indication (Conf);
+      if Binding /= Null_Iir then
+         Disp_Binding_Indication (N,NewN(N,+"-"),Binding
+, Indent + Indentation);
+      end if;
+      Block := Get_Block_Configuration (Conf);
+      if Block /= Null_Iir then
+         Disp_Block_Configuration (N,NewN(N,+"-"),Block
+, Indent + Indentation);
+      end if;
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("end for;");
+   end Disp_Component_Configuration;
+
+   procedure Disp_Configuration_Items
+     (P,N:X;Conf : Iir_Block_Configuration; Indent : Count)
+   is
+      pragma Unreferenced (P);
+      El : Iir;
+   begin
+      SetTag(N.all,+"configuration_items");
+      El := Get_Configuration_Item_Chain (Conf);
+      while El /= Null_Iir loop
+         case Get_Kind (El) is
+            when Iir_Kind_Block_Configuration =>
+               Disp_Block_Configuration (N,NewN(N,+"-"),El, Indent);
+            when Iir_Kind_Component_Configuration =>
+               Disp_Component_Configuration (N,NewN(N,+"-"),El, Indent);
+            when Iir_Kind_Configuration_Specification =>
+               --  This may be created by canon.
+               null;--               Set_Col (Indent);
+               Disp_Configuration_Specification (N,NewN(N,+"-"),El);
+               null;--               Set_Col (Indent);
+               null;--               Put_Line ("end for;");
+            when others =>
+               Error_Kind ("disp_configuration_item_list", El);
+         end case;
+         El := Get_Chain (El);
+      end loop;
+   end Disp_Configuration_Items;
+
+   procedure Disp_Block_Configuration
+     (P,N:X;Block: Iir_Block_Configuration; Indent: Count)
+   is
+      pragma Unreferenced (P);
+      Spec : Iir;
+   begin
+      SetTag(N.all,+"block_configuration");
+      null;--      Set_Col (Indent);
+      null;--      Put ("for ");
+      Spec := Get_Block_Specification (Block);
+      case Get_Kind (Spec) is
+         when Iir_Kind_Block_Statement
+           | Iir_Kind_Generate_Statement
+           | Iir_Kind_Architecture_Declaration =>
+            AddAttr(N,+"n",Str_Name_Of(Spec)); -- f:n
+         when Iir_Kind_Indexed_Name =>
+            AddAttr(N,+"prefix",Str_Name_Of(Get_Prefix (Spec)))
+; -- f:prefix
+            null;--            Put (" (");
+            Disp_Expression (N,NewN(N,+"-")
+,Get_First_Element (Get_Index_List (Spec)));
+            null;--            Put (")");
+         when Iir_Kind_Selected_Name =>
+            AddAttr(N,+"prefix",Str_Name_Of(Get_Prefix (Spec)))
+; -- f:prefix
+            null;--            Put (" (");
+            AddAttr(N,+"n",+(Iirs_Utils.Image_Identifier (Spec)));
+            null;--            Put (")");
+         when Iir_Kind_Slice_Name =>
+            AddAttr(N,+"prefix",Str_Name_Of(Get_Prefix (Spec)))
+; -- f:prefix
+            null;--            Put (" (");
+            Disp_Range (N,NewN(N,+"-"),Get_Suffix (Spec));
+            null;--            Put (")");
+         when others =>
+            Error_Kind ("disp_block_configuration", Spec);
+      end case;
+      null;--      New_Line;
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Block, Indent + Indentation);
+      Disp_Configuration_Items (N,NewN(N,+"-"),Block, Indent + Indentation);
+      null;--      Set_Col (Indent);
+      null;--      Put_Line ("end for;");
+   end Disp_Block_Configuration;
+
+   procedure Disp_Configuration_Declaration
+     (P,N:X;Decl: Iir_Configuration_Declaration)
+   is
+      pragma Unreferenced (P);
+   begin
+      SetTag(N.all,+"configuration_declaration");
+      null;--      Put ("configuration ");
+      AddAttr(N,+"n",Str_Name_Of(Decl)); -- f:n
+      null;--      Put (" of ");
+      AddAttr(N,+"of",Str_Name_Of(Get_Entity (Decl))); --f:of
+      null;--      Put_Line (" is");
+      Disp_Declaration_Chain (N,NewN(N,+"-"),Decl, Col);
+      Disp_Block_Configuration (N,NewN(N,+"-"),Get_Block_Configuration (Decl)
+,
+                                Col + Indentation);
+      null;--      Put_Line ("end;");
+   end Disp_Configuration_Declaration;
+
+   procedure Disp_Design_Unit (P,N:X;Unit: Iir_Design_Unit)
+   is
+      pragma Unreferenced (P);
+      Decl: Iir;
+      Indent: Count;
+      pragma Unreferenced (Indent);
+   begin
+      SetTag(N.all,+"design_unit");
+      Indent := Col;
+      Decl := Get_Context_Items (Unit);
+      while Decl /= Null_Iir loop
+         null;--         Set_Col (Indent);
+         case Get_Kind (Decl) is
+            when Iir_Kind_Use_Clause =>
+               Disp_Use_Clause (N,NewN(N,+"-"),Decl);
+            when Iir_Kind_Library_Clause =>
+               null;--               Put ("library ");
+               AddAttr(N,+"n",Str_Identifier(Decl)); -- f:n
+               null;--               Put_Line (";");
+            when others =>
+               Error_Kind ("disp_design_unit1", Decl);
+         end case;
+         Decl := Get_Chain (Decl);
+      end loop;
+
+      Decl := Get_Library_Unit (Unit);
+      null;--      Set_Col (Indent);
+      case Get_Kind (Decl) is
+         when Iir_Kind_Entity_Declaration =>
+            Disp_Entity_Declaration (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Architecture_Declaration =>
+            Disp_Architecture_Declaration (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Package_Declaration =>
+            Disp_Package_Declaration (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Package_Body =>
+            Disp_Package_Body (N,NewN(N,+"-"),Decl);
+         when Iir_Kind_Configuration_Declaration =>
+            Disp_Configuration_Declaration (N,NewN(N,+"-"),Decl);
+         when others =>
+            Error_Kind ("disp_design_unit2", Decl);
+      end case;
+      null;--      New_Line (2);
+   end Disp_Design_Unit;
+
+   procedure Disp_Xml_Vhdl (P,N:X;An_Iir: Iir) is
+      pragma Unreferenced (P);
+   begin
+      SetId(N,An_Iir);
+      SetTag(N.all,+"xml_vhdl");
+      --Set_Line_Length (80);
+      -- Put (Count'Image (Line_Length));
+      case Get_Kind (An_Iir) is
+         when Iir_Kind_Design_Unit =>
+            Disp_Design_Unit (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Character_Literal =>
+            Disp_Character_Literal (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Enumeration_Type_Definition =>
+            Disp_Enumeration_Type_Definition (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Enumeration_Subtype_Definition =>
+            Disp_Enumeration_Subtype_Definition (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Concurrent_Conditional_Signal_Assignment =>
+            Disp_Concurrent_Conditional_Signal_Assignment (N,NewN(N,+"-")
+,An_Iir);
+         when Iir_Kinds_Dyadic_Operator =>
+            Disp_Dyadic_Operator (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Signal_Interface_Declaration
+           | Iir_Kind_Signal_Declaration
+           | Iir_Kind_Object_Alias_Declaration =>
+            AddAttr(N,+"n",Str_Name_Of(An_Iir)); -- f:n
+         when Iir_Kind_Enumeration_Literal =>
+            AddAttr(N,+"n",Str_Identifier(An_Iir)); -- f:n
+         when Iir_Kind_Component_Instantiation_Statement =>
+            Disp_Component_Instantiation_Statement (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Integer_Subtype_Definition =>
+            Disp_Integer_Subtype_Definition (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Array_Subtype_Definition =>
+            Disp_Array_Subtype_Definition (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Array_Type_Definition =>
+            Disp_Array_Type_Definition (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Package_Declaration =>
+            Disp_Package_Declaration (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Wait_Statement =>
+            Disp_Wait_Statement (N,NewN(N,+"-"),An_Iir);
+         when Iir_Kind_Selected_Name
+           | Iir_Kind_Selected_Element
+           | Iir_Kind_Indexed_Name
+           | Iir_Kind_Slice_Name =>
+            Disp_Expression (N,NewN(N,+"-"),An_Iir);
+         when others =>
+            Error_Kind ("disp", An_Iir);
+      end case;
+   end Disp_Xml_Vhdl;
+   function NewN(P:X;Pos:U_String) return X is
+      N : X;
+   begin
+      N := X(Create_Xml_Node_Pretty(P,+"undef"));
+      AddAttr(N,+"pos",Pos);
+      return N;
+   end NewN;
+   procedure Disp_Int64 (P,N:X;Val: Iir_Int64)
+   is
+      pragma Unreferenced (P);
+      Str: constant String := Iir_Int64'Image (Val);
+   begin
+      SetTag(N.all,+"int64");
+      if Str(Str'First) = ' ' then
+         Put (Str (Str'First + 1 .. Str'Last));
+      else
+         Put (Str);
+      end if;
+   end Disp_Int64;
+   pragma Unreferenced (Disp_Int64);
+
+   --  procedure Disp_Int32 (N,NewN(N,+"-"),Val: Iir_Int32)
+   --  is
+   --     Str: constant String := Iir_Int32'Image (Val);
+   --  begin
+   --     if Str(Str'First) = ' ' then
+   --        Put (Str (Str'First + 1 .. Str'Last));
+   --     else
+   --        Put (Str);
+   --     end if;
+   --  end Disp_Int32;
+
+   procedure Disp_Fp64 (P,N:X;Val: Iir_Fp64)
+   is
+      pragma Unreferenced (P);
+      Str: constant String := Iir_Fp64'Image (Val);
+   begin
+      SetTag(N.all,+"fp64");
+      if Str(Str'First) = ' ' then
+         Put (Str (Str'First + 1 .. Str'Last));
+      else
+         Put (Str);
+      end if;
+   end Disp_Fp64;
+   pragma Unreferenced (Disp_Fp64);
+
+end disp_xml_vhdl;
\ No newline at end of file
--- ghdl-r150-ori/disp_xml_vhdl.ads	2013-07-10 13:07:47.000000000 +0200
+++ ghdl-r150/disp_xml_vhdl.ads	2013-06-08 12:53:58.000000000 +0200
@@ -0,0 +1,8 @@
+with Iirs; use Iirs;
+with disp_xml_node; use disp_xml_node;
+
+package disp_xml_vhdl is
+   subtype X is Xml_Node_Acc;
+   procedure Disp_Xml_Vhdl (P,N:X;An_Iir: Iir);
+   function NewN(P:X;Pos:U_String) return X;
+end disp_xml_vhdl;
